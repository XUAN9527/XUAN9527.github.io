---
title: 草稿文件
date: 2024-01-31 08:30:02
tags:
description: 记录日常开发过程中遇到的一些小问题，以及解决方法。
---

## Linux 打开端口~/.bashrc不会自动刷新
解决linux每次打开新终端都要重新source ~/.bashrc问题
执行以下代码：

	vi ~/.bash_profile

有可能此文件是空白新建的，无所谓。然后在此文件末尾加入：
```c
if [ -f ~/.bashrc ];then
source ~/.bashrc
fi
```
然后:wq保存即可。
此时打开新终端可以自动执行source ~/.bashrc

## J-Link/J-Flash

**J-Flash批处理脚本配置烧录：**当然，前提是要添加J-Link的可执行程序路径到`$PATH`环境变量中
- program.bat脚本代码如下，参考修改即可：
```
echo start...

JLink -device N32L406CB -if swd -speed 4000 -CommanderScript "C:\Users\Breo\Desktop\Wireless moxibustion\Software\program.jlink"
```
- program.jlink文件代码如下，其中目标设备、文件路径、烧录地址等根据需要配置：
```
connect
device N32L406CB
si SWD
speed 4000
h		// halt-停止
r		// 复位，可以考虑去掉
erase		// 或 erase 0x8002800，去掉也行，但可能会出现error fail address 0x00000000错误提示

loadfile app.bin 0x8002800      // loadfile app.hex 或 loadfile app.bin 0x8000000
verifybin app.bin 0x8002800
r
go		// r go表示reset and run
q		// 退出J-Link命令行工具
```

## Ubuntu 无法更新问题
Ubuntu 无法使用apt update

### 更改软件源
编辑 /etc/apt/sources.list 文件，将以下内容添加到文件末尾

	deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
	deb-src https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse

	deb https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse
	deb-src https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse

	deb https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
	deb-src https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse

### 清除 apt 缓存

	sudo apt clean
	sudo apt autoclean

### 尝试更新系统

	sudo apt update

显示 ModuleNotFoundError: No module named 'apt_pkg'，重新安装 "apt_pkg" 模块：

	sudo apt install --reinstall python3-apt

显示 ERROR：

	E: Could not read response to hello message from hook [ ! -f /usr/bin/snap ] || /usr/bin/snap advise-snap --from-apt 2>/dev/null || true: Success

如果问题仍然存在，尝试修复 Python 包：

	sudo apt install --fix-broken

然后就更新系统了：

	sudo apt update
	sudo apt upgrade

执行sudo apt upgrade后显示ERROR：

	Errors were encountered while processing:
	/tmp/apt-dpkg-install-cQBLJW/626-linux-iot-tools-common_5.4.0-1030.31_all.deb
	E: Sub-process /usr/bin/dpkg returned an error code (1)

最后一步，修复损坏的软件包配置：

	sudo dpkg --configure -a
	sudo apt upgrade

## Breo蓝牙启动异常

### Breo蓝牙初始化
蓝牙初始化没完成，透传未开启，app就连接蓝牙了。
设置透传参数，开启透传的的状态中增加连接蓝牙接受指令。

### 心跳包回复超时
现在是接收/刷新设备数据200ms超时，延迟太长还可以缩短。

## SPI级联led灯调试小助手

产品名称：1209RGB幻彩雾状
产品型号：XTQ-016B.RGB-2307125-20

### SPI级联led灯问题汇总

#### 充电闪灯问题

##### 问题分析
	
充电中拔掉电源，立即再次插入，会闪一下灯；若等两秒再插入则不会出现，初步判断是此款芯片有锁存功能，会保存到寄存器中，未完全掉电再次插入则会继续执行上次的寄存器数据。

##### 解决方法

充电中拔掉电源，程序不要立即断电，持续两秒反初始化spi灯珠，即给spi寄存器写全灭数据。

#### 呼吸灯闪烁问题

##### 问题分析

程序中呼吸灯会跑偶尔闪烁，影响显示效果。分析发现，代码中有电机的FG检测，此检测开启了输入捕获功能，会持续中断触发，虽然spi灯的驱动是dma发送，但是也是由CPU来调度的，并不能与中断并行。spi呼吸灯效果需要持续发送数据，且时序要求很高，中断会抢占spi的dma发送，打断spi传输数据，导致数据传输出错，造成闪灯效果。

##### 解决方法
1、提高芯片主频，n32l403KB最高主频为64MHz，如果主频提高效果会好一些。
2、spi呼吸灯效果持续发送数据，不能与中断频繁的代码一起使用。

## Sclap 3s充电保护仍充电
修改代码：
``` bash
{-1, 1, PIN_CHARGE_CC_DETECT, PIN_MODE_INPUT},	//input/output switch

static void board_charge_cc_set(bool en)
{	
	struct pin_status_desc *pin = pin_handle(PIN_CHARGE_CC_DETECT);
	if(en)
	{
		pin->type = PIN_MODE_INPUT;
		drv_pin_mode(pin->pin_id,pin->type);
		pin->lvl_rt = -1;			//重置lvl_rt，以防止output出问题
	}else{
		pin->type = PIN_MODE_OUTPUT;
		drv_pin_mode(pin->pin_id,pin->type);
		pin_set_func(pin, PIN_HIGH);
	}
}
```

## Git小贴士

#### 执行 git pull 会覆盖本地的修改吗？
  
没有冲突的情况下，远端会直接更新至本地上，但不会改变本地未提交的变动；如果本地修改已提交，则会执行一个远端分支和本地分支的合并

#### git fetch 和 git pull 的区别与联系

`git fetch`用于从远程仓库获取最新的提交，保存到本地的远程跟踪分支中（`FETCH_HEAD`），可以通过查看此分支了解远程仓库的更新情况
- `git diff FETCH_HEAD`比较查看该分支和当前工作分支的内容

<br>

`git pull`会自动获取远程仓库的更新，并且合并到当前分支上，相当于`git fetch` + `git merge FETCH_HEAD`
- 将远程仓库中指定分支的最新提交 ID 保存到本地的 FETCH_HEAD 分支中
- 将 FETCH_HEAD 分支合并到当前工作分支中


### 基础非典型操作

#### 本地git配置
<br>

**配置本地与远端的SSH密钥连接流程：**
- 本地生成SSH公钥和私钥(如果没有的话，另，linux下公钥通常存放于`~/.ssh/*.pub`)
  - `ssh-keygen -t rsa -b 4096 -C xxx@xxx.com`
- 复制公钥，添加至远端平台的SSH设置上
<br>

**查看本地配置：**
- `git config --list`查看当前项目的所有配置
- `git config --global --list`查看全局配置
<br>

**修改用户名(全局/当前项目)**

此用户名即提交日志上所展示的用户名称

  - 修改全局用户名：`git config --global user.name "xxx"`，影响用户的所有仓库
  - 修改当前路径项目的用户名：`git config user.name "xxx"`
  - 查看全局用户名：`git config user.name`
<br>

**初始化本地工程并与远端已有仓库的main分支关联：**
- 进入工程根目录，`git init`初始化本地仓库
- 添加远程仓库：`git remote add origin <远程仓库地址>`
- `git branch -M main`将当前分支重命名为`main`，M即`--move --force`的缩写。（可以分别输入`git add --all`，`git commit -m "first commit"`完成对本地分支的首次提交）
- 使用`git pull origin main`，将远程仓库的main分支拉取到本地，或者`git push -u origin main -f`将本地的xxx分支强制推送到远端main分支，其中-u是`--set-upstream`的缩写，后续会保持这个跟踪关系

## makefile问题汇总

### 修改.h文件没有重新编译

原来的编译规则：

	-include $(wildcard $(OUTPUT_DIR)/*/*.d)	# 包含所有生成的依赖文件，避免重复编译、提高效率

	/*/*.d 意思是当前目录下的二级所有文件检索。


修改为以下编译规则：

	# 找到所有的 .d 文件
	DEP_FILES := $(shell find $(BUILD_DIR) -type f -name '*.d')# 包含所有生成的依赖文件，避免重复编译、提高效率

	# 包含所有的 .d 文件
	-include $(DEP_FILES)

或者：

	-include $(wildcard $(OUTPUT_DIR)/**/*.d)
	-include $(wildcard $(OUTPUT_DIR)/*/*/*.d)

	/**/*.d 意思是当前目录下的二级所有文件检索，根据具体情况修改。
	/*/*/*.d 意思是当前目录下的三级所有文件检索，根据具体情况修改。


## windows子系统wsl

### arm-none-eabi-gcc工具链问题

arm-none-eabi-gcc工具链需加入用户变量：

	export PATH=/home/xuan/OpenHarmony/install-software/gcc-arm-none-eabi-9-2019-q4-major/bin:$PATH

注意：需确认路径，否则找不到用户路径会搜索系统自带编译链 /usr/lib/gcc/arm-none-eabi/10.3.1

<br>

## Linux下编写Python合并脚本

### 合并 bootloader + app  = mix

**1. 安装 PyInstaller**

	pip install pyinstaller

<br>

**2. 编写Python合并程序**
	
[代码链接](https://github.com/XUAN9527/script)

<br>

**3. 打包 Python 程序**

**参数说明：**

- -F：生成单一可执行文件。
- -D：生成包含所有依赖项的目录。
- -n：指定可执行文件名。
- --distpath：指定可执行文件输出目录。
- --noconfirm：覆盖输出文件时无需确认。

**以下是一些常用的高级选项：**

- --hidden-import：指定要隐藏导入的模块。
- --exclude-module：指定要排除的模块。
- --onefile：将所有文件打包成一个可执行文件。
- --runtime：指定 Python 运行时版本。

**执行规则:**

	cd new_file,copy file.py and file.ico
	pyinstaller -F -w (-i icofile) 文件名.py

**example:**
	pyinstaller -F file.py
	pyinstaller -F -w -i file.ico file.py

<br>

**4. 运行可执行文件**

	./dist/file

<br>

**5. 例程**

**以下例程为合并bootloader.bin和app.bin文件，生成mix.bin文件。**

``` python
import os
import shutil
import struct
 
bin1_path = 'bootloader.bin'
bin2_path = 'app.bin'
bin_result_path = 'mix.bin'

offset1 = 0x00000000
offset2 = 0x00002800

shutil.copyfile(bin1_path, bin_result_path)

bin_1 = open(bin1_path, 'rb')
bin_2 = open(bin2_path, 'rb')
bin_merge = open(bin_result_path, 'ab')
bin2_size = os.path.getsize(bin2_path)

bin_result_size = os.path.getsize(bin_result_path)
final_size = offset2 + bin2_size

offset = bin_result_size
value_default = struct.pack('B', 0xff)

while offset < final_size:
    if offset == offset2:
        data = bin_2.read()
        bin_merge.write(data)
        offset = bin_merge.tell()
    else:
        bin_merge.write(value_default)
        offset = bin_merge.tell()

bin_1.close()
bin_2.close()
bin_merge.close()
```

<br>

**以下例程为app.bin文件加检验头128bytes，生成papp.bin文件(适配专用IAP升级)。**

``` python
import os
import shutil
import struct
import binascii

# 查表算法常量 (替换为实际的 CRC32 查表)
crc32_table = [
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
]

def calc_crc32(filename):
  """
  Calculates the CRC32 value of a file.

  Args:
      filename: Path to the file.

  Returns:
      The calculated CRC32 value (uint32_t).
  """

  # Initialize CRC value (same as C code)
  crc = 0xFFFFFFFF

  # Open the file in binary read mode
  with open(filename, "rb") as f:
    # Read the file data in chunks (improves memory efficiency)
    chunk_size = 4096
    while True:
      chunk = f.read(chunk_size)
      if not chunk:
        break
      # Process each byte using the CRC32 table
      for byte in chunk:
        index = (crc ^ byte) & 0xFF
        crc = crc32_table[index] ^ (crc >> 8)

  # Finalize CRC (same as C code)
  return crc ^ 0xFFFFFFFF


def merge_bin_files(input_file_path, output_file_path, offset=128):
  """
  合并两个 bin 文件。

  Args:
    input_file_path: 输入文件路径。
    output_file_path: 输出文件路径。
    offset: 偏移量。

  Returns:
    None.
  """

  # 读取输入文件长度
  with open(input_file_path, "rb") as input_file:
    input_file_size = input_file.seek(0, os.SEEK_END)

  # 计算 CRC32 校验码
  crc32_value = calc_crc32(input_file_path)

  # 创建输出文件
  with open(output_file_path, "wb") as output_file:
    # 写入头部信息
    head_flag = struct.pack("<I", 0x52617221)
    version = "V100"
    output_file.write(head_flag)
    output_file.write(version.encode())
    output_file.write(input_file_size.to_bytes(4, byteorder="little"))
    output_file.write(crc32_value.to_bytes(4, byteorder="little"))

    # 写入偏移量
    write_size = output_file.tell()
    output_file.write(b"\x00" * (offset - write_size))

    # 读取输入文件内容并写入输出文件
    with open(input_file_path, "rb") as input_file:
      input_file.seek(0)
      output_file.write(input_file.read())


if __name__ == "__main__":
  # 输入文件路径
  input_file_path = "app.bin"

  # 输出文件路径
  output_file_path = "papp.bin"

  # 偏移量
  offset = 128

  # 合并文件
  merge_bin_files(input_file_path, output_file_path, offset)
```

<br>

**6. 实际应用场景**

- 单独使用：Linux环境下单独执行使用。
- 集成在makefile中，使用make编译自动生成文件：
``` c
.PHONY : clean all

all: $(TARGET).bin $(TARGET).list $(TARGET).hex
	$(SZ) $(TARGET).elf
	@make copy
	./papp_up			# add ./papp_up
	./mix_10K			# add ./mix_10K

.PHONY: copy

copy: $(TARGET).bin
	cp $(TARGET).bin app.bin
	cp $(TARGET).hex app.hex

clean:
	rm -rf $(BUILD_DIR)
	rm app.bin
	rm app.hex
	rm papp.bin		# add rm papp.bin
	rm mix.bin		# add rm mix.bin
```
