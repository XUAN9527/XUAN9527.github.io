---
title: 杂项
date: 2024-01-31 08:30:02
tags:
description: 记录日常开发过程中遇到的一些小问题，以及解决方法。
---

## Linux 打开端口~/.bashrc不会自动刷新
解决linux每次打开新终端都要重新source ~/.bashrc问题
执行以下代码：

	vi ~/.bash_profile

有可能此文件是空白新建的，无所谓。然后在此文件末尾加入：
```c
if [ -f ~/.bashrc ];then
source ~/.bashrc
fi
```
然后:wq保存即可。
此时打开新终端可以自动执行source ~/.bashrc

## J-Link/J-Flash

**J-Flash批处理脚本配置烧录：**当然，前提是要添加J-Link的可执行程序路径到`$PATH`环境变量中
- program.bat脚本代码如下，参考修改即可：
```
echo start...

JLink -device N32L406CB -if swd -speed 4000 -CommanderScript "C:\Users\Breo\Desktop\Wireless moxibustion\Software\program.jlink"
```
- program.jlink文件代码如下，其中目标设备、文件路径、烧录地址等根据需要配置：
```
connect
device N32L406CB
si SWD
speed 4000
h		// halt-停止
r		// 复位，可以考虑去掉
erase		// 或 erase 0x8002800，去掉也行，但可能会出现error fail address 0x00000000错误提示

loadfile app.bin 0x8002800      // loadfile app.hex 或 loadfile app.bin 0x8000000
verifybin app.bin 0x8002800
r
go		// r go表示reset and run
q		// 退出J-Link命令行工具
```

## Ubuntu 无法更新问题
Ubuntu 无法使用apt update

### 更改软件源
编辑 /etc/apt/sources.list 文件，将以下内容添加到文件末尾

	deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
	deb-src https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse

	deb https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse
	deb-src https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse

	deb https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
	deb-src https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse

### 清除 apt 缓存

	sudo apt clean
	sudo apt autoclean

### 尝试更新系统

	sudo apt update

显示 ModuleNotFoundError: No module named 'apt_pkg'，重新安装 "apt_pkg" 模块：

	sudo apt install --reinstall python3-apt

显示 ERROR：

	E: Could not read response to hello message from hook [ ! -f /usr/bin/snap ] || /usr/bin/snap advise-snap --from-apt 2>/dev/null || true: Success

如果问题仍然存在，尝试修复 Python 包：

	sudo apt install --fix-broken

然后就更新系统了：

	sudo apt update
	sudo apt upgrade

执行sudo apt upgrade后显示ERROR：

	Errors were encountered while processing:
	/tmp/apt-dpkg-install-cQBLJW/626-linux-iot-tools-common_5.4.0-1030.31_all.deb
	E: Sub-process /usr/bin/dpkg returned an error code (1)

最后一步，修复损坏的软件包配置：

	sudo dpkg --configure -a
	sudo apt upgrade

## Breo蓝牙启动异常

### Breo蓝牙初始化
蓝牙初始化没完成，透传未开启，app就连接蓝牙了。
设置透传参数，开启透传的的状态中增加连接蓝牙接受指令。

### 心跳包回复超时
现在是接收/刷新设备数据200ms超时，延迟太长还可以缩短。

## SPI级联led灯调试小助手

产品名称：1209RGB幻彩雾状
产品型号：XTQ-016B.RGB-2307125-20

### SPI级联led灯问题汇总

#### 充电闪灯问题

##### 问题分析
	
充电中拔掉电源，立即再次插入，会闪一下灯；若等两秒再插入则不会出现，初步判断是此款芯片有锁存功能，会保存到寄存器中，未完全掉电再次插入则会继续执行上次的寄存器数据。

##### 解决方法

充电中拔掉电源，程序不要立即断电，持续两秒反初始化spi灯珠，即给spi寄存器写全灭数据。

#### 呼吸灯闪烁问题

##### 问题分析

程序中呼吸灯会跑偶尔闪烁，影响显示效果。分析发现，代码中有电机的FG检测，此检测开启了输入捕获功能，会持续中断触发，虽然spi灯的驱动是dma发送，但是也是由CPU来调度的，并不能与中断并行。spi呼吸灯效果需要持续发送数据，且时序要求很高，中断会抢占spi的dma发送，打断spi传输数据，导致数据传输出错，造成闪灯效果。

##### 解决方法
1、提高芯片主频，n32l403KB最高主频为64MHz，如果主频提高效果会好一些。
2、spi呼吸灯效果持续发送数据，不能与中断频繁的代码一起使用。

## 某项目充电保护仍充电
修改代码：
``` bash
{-1, 1, PIN_CHARGE_CC_DETECT, PIN_MODE_INPUT},	//input/output switch

static void board_charge_cc_set(bool en)
{	
	struct pin_status_desc *pin = pin_handle(PIN_CHARGE_CC_DETECT);
	if(en)
	{
		pin->type = PIN_MODE_INPUT;
		drv_pin_mode(pin->pin_id,pin->type);
		pin->lvl_rt = -1;			//重置lvl_rt，以防止output出问题
	}else{
		pin->type = PIN_MODE_OUTPUT;
		drv_pin_mode(pin->pin_id,pin->type);
		pin_set_func(pin, PIN_HIGH);
	}
}
```

## Git小贴士

### 执行 git pull 会覆盖本地的修改吗？
  
没有冲突的情况下，远端会直接更新至本地上，但不会改变本地未提交的变动；如果本地修改已提交，则会执行一个远端分支和本地分支的合并

### git fetch 和 git pull 的区别与联系

`git fetch`用于从远程仓库获取最新的提交，保存到本地的远程跟踪分支中（`FETCH_HEAD`），可以通过查看此分支了解远程仓库的更新情况
- `git diff FETCH_HEAD`比较查看该分支和当前工作分支的内容

<br>

`git pull`会自动获取远程仓库的更新，并且合并到当前分支上，相当于`git fetch` + `git merge FETCH_HEAD`
- 将远程仓库中指定分支的最新提交 ID 保存到本地的 FETCH_HEAD 分支中
- 将 FETCH_HEAD 分支合并到当前工作分支中


### 基础非典型操作

### 本地git配置
<br>

**配置本地与远端的SSH密钥连接流程：**
- 本地生成SSH公钥和私钥(如果没有的话，另，linux下公钥通常存放于`~/.ssh/*.pub`)
  - `ssh-keygen -t rsa -b 4096 -C xxx@xxx.com`
- 复制公钥，添加至远端平台的SSH设置上
<br>

**查看本地配置：**
- `git config --list`查看当前项目的所有配置
- `git config --global --list`查看全局配置
<br>

**修改用户名(全局/当前项目)**

此用户名即提交日志上所展示的用户名称

  - 修改全局用户名：`git config --global user.name "xxx"`，影响用户的所有仓库
  - 修改当前路径项目的用户名：`git config user.name "xxx"`
  - 查看全局用户名：`git config user.name`
<br>

**初始化本地工程并与远端已有仓库的main分支关联：**
- 进入工程根目录，`git init`初始化本地仓库
- 添加远程仓库：`git remote add origin <远程仓库地址>`
- `git branch -M main`将当前分支重命名为`main`，M即`--move --force`的缩写。（可以分别输入`git add --all`，`git commit -m "first commit"`完成对本地分支的首次提交）
- 使用`git pull origin main`，将远程仓库的main分支拉取到本地，或者`git push -u origin main -f`将本地的xxx分支强制推送到远端main分支，其中-u是`--set-upstream`的缩写，后续会保持这个跟踪关系

<br>

## makefile问题汇总

### 修改.h文件没有重新编译

原来的编译规则：

	-include $(wildcard $(OUTPUT_DIR)/*/*.d)	# 包含所有生成的依赖文件，避免重复编译、提高效率

	/*/*.d 意思是当前目录下的二级所有文件检索。


修改为以下编译规则：

	# 找到所有的 .d 文件
	DEP_FILES := $(shell find $(BUILD_DIR) -type f -name '*.d')# 包含所有生成的依赖文件，避免重复编译、提高效率

	# 包含所有的 .d 文件
	-include $(DEP_FILES)

或者：

	-include $(wildcard $(OUTPUT_DIR)/**/*.d)
	-include $(wildcard $(OUTPUT_DIR)/*/*/*.d)

	/**/*.d 意思是当前目录下的二级所有文件检索，根据具体情况修改。
	/*/*/*.d 意思是当前目录下的三级所有文件检索，根据具体情况修改。


<br>

## windows子系统wsl

### arm-none-eabi-gcc工具链问题

arm-none-eabi-gcc工具链需加入用户变量：

	export PATH=/home/xuan/OpenHarmony/install-software/gcc-arm-none-eabi-9-2019-q4-major/bin:$PATH

注意：需确认路径，否则找不到用户路径会搜索系统自带编译链 /usr/lib/gcc/arm-none-eabi/10.3.1

<br>

## Linux下编写Python合并脚本

### 合并 bootloader + app  = mix

**1. 安装 PyInstaller**

	pip install pyinstaller

<br>

**2. 编写Python合并程序**
	
[代码链接](https://github.com/XUAN9527/script)

<br>

**3. 打包 Python 程序**

**参数说明：**

- -F：生成单一可执行文件。
- -D：生成包含所有依赖项的目录。
- -n：指定可执行文件名。
- --distpath：指定可执行文件输出目录。
- --noconfirm：覆盖输出文件时无需确认。

**以下是一些常用的高级选项：**

- --hidden-import：指定要隐藏导入的模块。
- --exclude-module：指定要排除的模块。
- --onefile：将所有文件打包成一个可执行文件。
- --runtime：指定 Python 运行时版本。

**执行规则:**

	cd new_file,copy file.py and file.ico
	pyinstaller -F -w (-i icofile) 文件名.py

**example:**
	pyinstaller -F file.py
	pyinstaller -F -w -i file.ico file.py

<br>

**4. 运行可执行文件**

	./dist/file

<br>

**5. 例程**

[代码链接](https://github.com/XUAN9527/script)

<br>

**6. 实际应用场景**

- 单独使用：Linux环境下单独执行使用。
- 集成在makefile中，使用make编译自动生成文件：
	- 将papp_up和mix_10K打包至tools文件夹，放在makefile同一目录下。
	- 需要bootloder.bin在../bootloader目录下。
	- 修改makefile生成规则。
``` c
.PHONY : clean all

all: $(TARGET).bin $(TARGET).list $(TARGET).hex
	$(SZ) $(TARGET).elf
	@make copy
	@make mix

.PHONY: copy

copy: $(TARGET).bin
	cp $(TARGET).bin app.bin
	cp ../bootloader/bootloader.bin bootloader.bin
#	cp $(TARGET).hex app.hex

mix:
	./tools/papp_up
	./tools/mix_10K
	$(OC) -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex
	rm bootloader.bin
	rm app.bin
	rm mix.bin

clean:
	rm -rf $(BUILD_DIR)
	rm papp.bin
	rm mix.hex
```

<br>

## 可变参数函数详解

在C语言中，printf 是一个标准库函数，用于在终端或其他输出设备上打印格式化的文本。它是一个**可变参数函数**，接受一个格式字符串作为第一个参数，后面是可变数量的参数，用于替换格式字符串中的格式占位符。

让我们来详细解析一下可变参数函数和宏，以及如何实现一个类似于 printf 的函数。

**1. 可变参数函数：**

- 可变参数函数允许在函数定义中接受不定数量的参数。
- C语言提供了 stdarg.h 头文件来支持可变参数函数的实现。
- 下面是一个示例代码，展示了如何实现一个可变参数函数 sum，它接受一个整数参数 count，表示接下来的可变参数的数量：

``` c
#include <stdio.h>
#include <stdarg.h>

int sum(int count, ...) {
    int total = 0;
    va_list args;
    va_start(args, count);
    for (int i = 0; i < count; i++) {
        int num = va_arg(args, int);
        total += num;
    }
    va_end(args);
    return total;
}

int main() {
    int result = sum(4, 10, 20, 30, 40);
    printf("Sum: %d\n", result);
    return 0;
}
```

- 在这个示例中，我们定义了一个可变参数函数 sum，它计算传入的整数参数的总和。

<br>

**2. 可变参数宏：**

- 可变参数宏允许在宏调用中接受可变数量的参数。
- 在C语言中，可变参数宏使用 __VA_ARGS__ 表示可变参数的部分。
- 下面是一个示例代码，展示了如何定义一个可变参数宏 PRINT_VALUES，它使用 printf 函数来打印可变数量的值:

``` c
#include <stdio.h>

#define PRINT_VALUES(...) do { \
    printf("Values: "); \
    printf(__VA_ARGS__); \
    printf("\n"); \
} while (0)

int main() {
    PRINT_VALUES("%d %s %f", 10, "hello", 3.14);
    return 0;
}
```

- 在这个示例中，我们定义了一个可变参数宏 PRINT_VALUES，它使用 printf 函数来打印多个值。

<br>

**3. 实现自己的 printf 函数：**

- `printf` 函数接受一个格式字符串作为第一个参数，后面是可变数量的参数，用于替换格式字符串中的格式占位符。
- 以下是一个简化版的示例代码，展示了一个实现类似于 `printf` 函数的功能的函数：

```c
#include <stdio.h>
#include <stdarg.h>

void my_printf(const char* format, ...) {
    va_list args;
    va_start(args, format);
    while (*format != '\0') {
        if (*format == '%') {
            format++; // 移动到占位符的下一个字符
            if (*format == 'd') {
                int value = va_arg(args, int);
                printf("%d", value);
            } else if (*format == 'f') {
                double value = va_arg(args, double);
                printf("%f", value);
            } else if (*format == 's') {
                char* value = va_arg(args, char*);
                printf("%s", value);
            } else if (*format == 'c') {
                int value = va_arg(args, int);
                printf("%c", value);
            } else {
                printf("Unsupported format specifier: %c", *format);
            }
        } else {
            printf("%c", *format);
        }
        format++; // 移动到下一个字符
    }
    va_end(args);
}

int main() {
	int num = 42;
	double pi = 3.14159;
	char str[] = "Hello, world!";
	char ch = 'A';

	my_printf("Integer: %d\n", num);
	my_printf("Float: %f\n", pi);
	my_printf("Float: %s\n", str);
	my_printf("Float: %c\n", ch);

	return 0;
}
```

<br>
