<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ESP32开发小贴士</title>
    <url>/2024/02/22/ESP32%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
    <content><![CDATA[<h2 id="ESP32-ESP-IDF自定义组件"><a href="#ESP32-ESP-IDF自定义组件" class="headerlink" title="ESP32 ESP-IDF自定义组件"></a>ESP32 ESP-IDF自定义组件</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p><a href="https://link.zhihu.com/?target=https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/build-system.html%23component-cmakelists-files">英文官方文档链接</a><br><a href="https://link.zhihu.com/?target=https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-guides/build-system.html%23id21">中文官方文档链接</a></p>
<h4 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h4><p>此示例在《ESP32 smart_config和airkiss配网》<br><a href="https://zhuanlan.zhihu.com/p/440454542">https://zhuanlan.zhihu.com/p/440454542</a><br><a href="https://link.zhihu.com/?target=https://blog.csdn.net/chentuo2000/article/details/121687760">https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/121687760</a><br>基础上，增加连接成功后点亮板载LED功能。<br>实现所需功能后将各功能代码分离，再将分离后的代码构造成组件，使得项目有清晰的结构，方便功能代码移植.</p>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>《Win10启用Linux子系统安装Ubuntu》<br><a href="https://link.zhihu.com/?target=https://blog.csdn.net/chentuo2000/article/details/112131624">https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/112131624</a></p>
<p>《用乐鑫国内Gitee镜像搭建ESP32开发环境》<br><a href="https://link.zhihu.com/?target=https://blog.csdn.net/chentuo2000/article/details/113424934">https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/113424934</a></p>
<h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><h4 id="拷贝-初始化例程"><a href="#拷贝-初始化例程" class="headerlink" title="拷贝 &amp;&amp; 初始化例程"></a>拷贝 &amp;&amp; 初始化例程</h4><p>将例子项目<code>hello_world</code>复制到ESP-IDF开发工具之外,更名为components_demo:</p>
<pre><code>cd ~/esp
cp -r ~/esp/esp-adf/esp-idf/examples/get-started/hello_world ./components_demo
</code></pre>
<p>清空build目录:</p>
<pre><code>cd ~/esp/components_demo
rm -r build/*
</code></pre>
<p>注意，每当添加了新组件就要删除build目录下的全部内容，或者执行下面这条命令：</p>
<pre><code>idf.py fullclean
</code></pre>
<p>清除以前的构建。</p>
<h4 id="添加组件letter-shell"><a href="#添加组件letter-shell" class="headerlink" title="添加组件letter_shell"></a>添加组件letter_shell</h4><pre><code>idf.py -C components create-component letter_shell
</code></pre>
<p>该命令会创建一个新组件,新组件将包含构建组件所需的一组空文件。我们的工作就是在这一组空文件中写上我们的代码。<br>如果熟悉了组件结构，也可以直接在项目中手工创建。</p>
<h4 id="项目树"><a href="#项目树" class="headerlink" title="项目树"></a>项目树</h4><p>构建好的项目结构如下:</p>
<p><img src="/../pictures/component_demo%E8%AE%BE%E5%A4%87%E6%A0%91.png" alt="component_demo设备树"></p>
<p>注意：组件目录components名字不能改，其下的组件名可以随意取。build目录是编译时生成的，编译的结果都放在其中。dependencies.lock是随原来的项目复制过来的不要改。sdkconfig文件可以用idf.py menuconfig命令修改。</p>
<h3 id="代码和说明"><a href="#代码和说明" class="headerlink" title="代码和说明"></a>代码和说明</h3><p>各文件的位置关系很重要，请对照前面的项目树看代码文件。</p>
<h4 id="项目的根CMakeLists-txt文件"><a href="#项目的根CMakeLists-txt文件" class="headerlink" title="项目的根CMakeLists.txt文件"></a>项目的根CMakeLists.txt文件</h4><pre><code># The following lines of boilerplate have to be in your project&#39;s
# CMakeLists in this exact order for cmake to work correctly
cmake_minimum_required(VERSION 3.16)

include($ENV&#123;IDF_PATH&#125;/tools/cmake/project.cmake)
project(components_demo)
</code></pre>
<p>只需要修改<code>project</code>中的项目名称。</p>
<h4 id="main目录"><a href="#main目录" class="headerlink" title="main目录"></a>main目录</h4><p>CMakeLists.txt</p>
<pre><code>idf_component_register(SRCS &quot;main.c&quot;
                INCLUDE_DIRS &quot;.&quot;)
</code></pre>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shell_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *TAG = <span class="string">&quot;sample test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">esp_err_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize NVS.</span></span><br><span class="line">    ret = nvs_flash_init();</span><br><span class="line">    <span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) &#123;</span><br><span class="line">        ESP_ERROR_CHECK(nvs_flash_erase());</span><br><span class="line">        ret = nvs_flash_init();</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_ERROR_CHECK( ret );</span><br><span class="line"></span><br><span class="line">	esp_log_level_set(TAG, ESP_LOG_INFO);</span><br><span class="line">	ESP_LOGI(TAG,<span class="string">&quot;this is a test program&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	userShellInit();</span><br><span class="line"></span><br><span class="line">	logInfo(<span class="string">&quot;log info!&quot;</span>);</span><br><span class="line">	logDebug(<span class="string">&quot;log debug!&quot;</span>);</span><br><span class="line">	logWarning(<span class="string">&quot;log warning!&quot;</span>);</span><br><span class="line">	logError(<span class="string">&quot;log error!&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		logDebug(<span class="string">&quot;log loop!&quot;</span>);</span><br><span class="line">		vTaskDelay(pdMS_TO_TICKS(<span class="number">2000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头文件nvs_flash.h是对系统组件的引用，shell_port.h是对自定义组件的引用。</p>
<h4 id="letter-shell组件"><a href="#letter-shell组件" class="headerlink" title="letter_shell组件"></a>letter_shell组件</h4><p><code>CMakeLists.txt</code>:</p>
<pre><code>idf_component_register(
    SRCS &quot;shell.c&quot;
        &quot;shell_ext.c&quot;
        &quot;log.c&quot;
        &quot;shell_port.c&quot;
    INCLUDE_DIRS &quot;include&quot;
    LDFRAGMENTS &quot;shell.lf&quot;
    # PRIV_REQUIRES led
    REQUIRES esp_driver_uart
)
</code></pre>
<h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><p>1、PRIV_REQUIRES<br>该参数指定对其它自定义组件的依赖，即私有依赖项。</p>
<p><code>PRIV_REQUIRES led</code>表示指出在<code>smart_config</code>组件中要用到自定义的<code>led</code>组件。组件名字可以加引号，也可以不加。多个组件用空格分开。</p>
<p>2、 REQUIRES<br>该参数指定对系统组件的依赖，即公共依赖项。</p>
<p><code>REQUIRES esp_driver_uart</code> 表示在<code>letter_shell</code>组件中要用到系统组件<code>esp_driver_uart</code>。</p>
<p>3、系统组件的确定</p>
<p>对于要依赖的系统组件不像私有依赖项那样一目了然，有时我们并不清楚所要的系统组件名称。比如我们不知道需要组件wpa_supplicant，这时我们可以先编译一次，看看错误信息：</p>
<p><img src="/../pictures/requires_error.png" alt="requires_error"></p>
<p>在<code>CMakeLists.txt</code>中添加依赖组件<code>REQUIRES esp_driver_uart</code>，编译通过。</p>
<h4 id="关于CMakeLists-txt文件"><a href="#关于CMakeLists-txt文件" class="headerlink" title="关于CMakeLists.txt文件"></a>关于CMakeLists.txt文件</h4><p>根和每个目录都有一个<code>CMakeLists.txt</code>文件，开始遇到的问题是不知道目录结构和怎样写<code>CMakeLists.txt</code>文件，要注意每一层目录中<code>CMakeLists.txt</code>文件的写法，本文的例子给出了一个简单的示范。对于复杂的项目还需要更多编写<code>CMakeLists.txt</code>文件的知识，请看简介中给出的官方文档。</p>
<h2 id="ESP32移植Letter-shell问题"><a href="#ESP32移植Letter-shell问题" class="headerlink" title="ESP32移植Letter_shell问题"></a>ESP32移植Letter_shell问题</h2><h3 id="添加shell组件及其log，编译出错"><a href="#添加shell组件及其log，编译出错" class="headerlink" title="添加shell组件及其log，编译出错"></a>添加shell组件及其log，编译出错</h3><h4 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因:"></a>可能原因:</h4><ol>
<li><p>宏使用不正确: 如果 SHELL_FREE 旨在实际释放与 <code>companions</code> 对象关联的内存或资源，则当前定义不正确。它应该调用内存管理函数或执行其他必要的清理任务。</p>
</li>
<li><p>编译器警告被视为错误: <code>-Werror=unused-value</code> 标志已启用，它将警告视为错误。即使宏使用本身可能不是关键问题，这也可能导致编译失败。</p>
</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><h5 id="修复-SHELL-FREE-定义"><a href="#修复-SHELL-FREE-定义" class="headerlink" title="修复 SHELL_FREE 定义:"></a>修复 SHELL_FREE 定义:</h5><ol>
<li>如果 <code>companions</code> 需要内存分配，请更新 <code>shell_cfg.h</code> 中的 SHELL_FREE 宏以调用适当的内存管理函数，例如 <code>free()</code>。</li>
<li>如果 <code>companions</code> 不需要内存管理，请从 <code>shell_companion.c</code> 中的第 57 行删除 <code>SHELL_FREE</code> 调用；或者将<code>shell_cfg.h</code> 中的第 36 行 <code>SHELL_USING_COMPANION</code> 的宏定义改为 0。</li>
</ol>
<h5 id="禁用-Werror-unused-value-如果适用"><a href="#禁用-Werror-unused-value-如果适用" class="headerlink" title="禁用 -Werror&#x3D;unused-value (如果适用):"></a>禁用 -Werror&#x3D;unused-value (如果适用):</h5><p>如果您希望将未使用的值警告视为警告而不是错误，您可以暂时在编译期间禁用 <code>-Werror=unused-value</code> 标志。但是，通常建议修复底层问题以避免潜在的内存泄漏或资源管理问题。</p>
<h5 id="其他提示"><a href="#其他提示" class="headerlink" title="其他提示:"></a>其他提示:</h5><ol>
<li>提供有关您的项目更多信息，例如具体的 ESP-IDF 版本、涉及的组件以及 <code>SHELL_FREE</code> 宏的用途。这将有助于了解根本原因并提供更定制的指导。</li>
<li>分享 <code>shell_cfg.h</code> 头文件和 <code>shell_companion.c</code> 文件的相关部分，以便分析代码结构和上下文。<br>考虑使用调试器逐步执行代码并检查 <code>companions</code> 在 <code>SHELL_FREE</code> 调用之前和之后的 值，以了解其使用情况和潜在的内存管理问题。</li>
<li>通过遵循这些步骤并提供更多信息，我可以帮助您有效地解决编译错误并确保您的 ESP-IDF 项目成功构建。</li>
</ol>
<h4 id="配置shell优先级"><a href="#配置shell优先级" class="headerlink" title="配置shell优先级"></a>配置shell优先级</h4><p>将shell的freertos优先级设置为 <code>tskIDLE_PRIORITY</code>，为0级，跟空闲函数优先级一样，所有其他优先级任务执行完后才会执行 <code>tskIDLE_PRIORITY</code>优先级任务。</p>
<h4 id="源代码例程"><a href="#源代码例程" class="headerlink" title="源代码例程"></a>源代码例程</h4><p><a href="git@github.com:XUAN9527/components_demo.git">ESP32移植letter_shell组件例程</a></p>
]]></content>
      <categories>
        <category>ESP32解决方案</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32开发环境搭建</title>
    <url>/2024/02/19/ESP32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p><a href="https://espressif-docs.readthedocs-hosted.com/projects/esp-adf/zh-cn/latest/get-started/index.html#quick-start">ESP-ADF快速上手连接</a><br><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32/get-started/linux-macos-setup.html#get-started-linux-macos-first-steps">ESP-IDF快速上手连接</a></p>
<h3 id="获取ESP-ADF"><a href="#获取ESP-ADF" class="headerlink" title="获取ESP-ADF"></a>获取ESP-ADF</h3><p>打开Linux or macOS终端,新建搭建环境所需文件夹。</p>
<pre><code>mkdir ~/esp
cd ~/esp
</code></pre>
<p>编译 ESP-IDF 需要以下软件包。请根据使用的 Linux 发行版本，选择合适的安装：<br>Ubuntu 和 Debian:</p>
<pre><code>sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0
</code></pre>
<p>CentOS 7 &amp; 8:</p>
<pre><code>sudo yum -y update &amp;&amp; sudo yum install git wget flex bison gperf python3 python3-setuptools cmake ninja-build ccache dfu-util libusbx
</code></pre>
<p>Arch:</p>
<pre><code>sudo pacman -S --needed gcc git make flex bison gperf python cmake ninja ccache dfu-util libusb
</code></pre>
<p>克隆最新版ESP-ADF：</p>
<pre><code>git clone --recursive https://github.com/espressif/esp-adf.git
</code></pre>
<p>若克隆失败，尝试以下指令：</p>
<pre><code>git clone --recursive git@github.com:espressif/esp-adf.git
</code></pre>
<p>若子模块拉取失败，尝试手动逐个拉取子模块：</p>
<pre><code>cd ~/esp/esp-adf/components
git clone git@github.com:espressif/esp-adf-libs.git

cd ~/esp/esp-adf/components
git clone git@github.com:espressif/esp-sr.git

cd ~/esp/esp-adf
git clone git@github.com:espressif/esp-idf.git
</code></pre>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>按自己实际路径，可按自己喜好设置，也可不配置，手动敲指令也可。</p>
<p><code>vi ~/.bashrc</code><br>在后面加上以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启ESP32编译环境</span></span><br><span class="line"><span class="built_in">alias</span> get-idf=<span class="string">&#x27;. $HOME/esp/esp-adf/esp-idf/export.sh&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> get-adf=<span class="string">&#x27;. $HOME/esp/esp-adf/export.sh&#x27;</span></span><br><span class="line"><span class="comment">#打开本地文件夹（wsl）</span></span><br><span class="line"><span class="built_in">alias</span> open-file=<span class="string">&#x27;explorer.exe .&#x27;</span></span><br><span class="line"><span class="comment">#烧录到设备，并打开监视器，/dev/ttyS15为USB挂载端口，需测试后填写，115200为监视器波特率，与设备UART0波特率对应</span></span><br><span class="line"><span class="built_in">alias</span> esp-download=<span class="string">&#x27;idf.py -p /dev/ttyS15 -b 115200 flash monitor&#x27;</span></span><br><span class="line"><span class="built_in">export</span> PATH=/home/qx_song/esp/esp-adf/esp-idf/tools:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> IDF_PATH=/home/qx_song/esp/esp-adf/esp-idf</span><br><span class="line"><span class="built_in">export</span> ADF_PATH=/home/qx_song/esp/esp-adf</span><br></pre></td></tr></table></figure>
<p>保存退出 <code>:wq</code></p>
<h3 id="设置工具"><a href="#设置工具" class="headerlink" title="设置工具"></a>设置工具</h3><p>除了 ESP-IDF 本身，还需要为支持 ESP32 的项目安装 ESP-IDF 使用的各种工具，比如编译器、调试器、Python 包等。</p>
<pre><code>cd ~/esp/esp-adf/esp-idf
</code></pre>
<p>安装esp32，esp32s2工具，运行以下指令：（按需求安装）</p>
<pre><code>./install.sh esp32,esp32s2
</code></pre>
<p>若需要安装所有工具，运行以下指令：</p>
<pre><code>./install.sh all
</code></pre>
<p>以下为ESP-IDF编译所需环境，请在需要运行ESP-IDF的终端窗口运行以下命令：</p>
<pre><code>. $HOME/esp/esp-adf/esp-idf/export.sh   
</code></pre>
<p>或者使用快捷指令：</p>
<pre><code>get-idf
</code></pre>
<h2 id="ESP32工程示例"><a href="#ESP32工程示例" class="headerlink" title="ESP32工程示例"></a>ESP32工程示例</h2><h3 id="开始创建工程"><a href="#开始创建工程" class="headerlink" title="开始创建工程"></a>开始创建工程</h3><p>现在，可以准备开发 ESP32 应用程序了。<br>从 ESP-IDF 中 examples 目录下的 <code>get-started/hello_world</code> 工程开始，将 <code>get-started/hello_world</code> 工程复制至本地的 ~&#x2F;esp 目录下：</p>
<pre><code>cd ~/esp
get-idf
cp -r $IDF_PATH/examples/get-started/hello_world .
</code></pre>
<h3 id="配置工程"><a href="#配置工程" class="headerlink" title="配置工程"></a>配置工程</h3><pre><code>cd ~/esp/hello_world
idf.py set-target esp32
</code></pre>
<p>由于ESP32是单核，默认配置是双核模式，需要配置参数：</p>
<pre><code>idf.py menuconfig
Component config -&gt; FreeRTOS -&gt;  [*]Run FreeRTOS only on first core
</code></pre>
<p>保存退出</p>
<h3 id="编译工程"><a href="#编译工程" class="headerlink" title="编译工程"></a>编译工程</h3><pre><code>idf.py build
</code></pre>
<h3 id="烧录工程"><a href="#烧录工程" class="headerlink" title="烧录工程"></a>烧录工程</h3><pre><code>idf.py -p PORT flash
</code></pre>
<p>请将 PORT 替换为 ESP32 开发板的串口名称。如果 PORT 未经定义，<code>idf.py</code> 将尝试使用可用的串口自动连接。</p>
<h3 id="合并执行构建、烧录和监视过程："><a href="#合并执行构建、烧录和监视过程：" class="headerlink" title="合并执行构建、烧录和监视过程："></a>合并执行构建、烧录和监视过程：</h3><pre><code>idf.py -p PORT [-b BAUD] flash monitor
</code></pre>
<p>注：[-b BAUD] 和 monitor 配合使用，BAUD为程序中UART0的波特率	</p>
<pre><code>idf.py -p /dev/ttyS15 -b  115200  flash monitor	
idf.py -p [挂载端口]   -b [波特率] flash monitor
</code></pre>
<h3 id="擦除flash"><a href="#擦除flash" class="headerlink" title="擦除flash"></a>擦除flash</h3><pre><code>idf.py -p PORT erase-flash
</code></pre>
<p>若存在需要擦除的 OTA 数据，请运行以下命令：</p>
<pre><code>idf.py -p PORT erase-otadata
</code></pre>
<h3 id="挂载端口"><a href="#挂载端口" class="headerlink" title="挂载端口"></a>挂载端口</h3><h4 id="windows-子系统-wsl"><a href="#windows-子系统-wsl" class="headerlink" title="windows 子系统 wsl"></a>windows 子系统 wsl</h4><p>输入烧录指令：</p>
<pre><code>idf.py flash
</code></pre>
<p>观察终端设备是挂载在哪个端口上，有ERROR忽略，选择端口例如 <code>/dev/ttyS15</code>，程序中<code>UART0</code>的波特率115200，下次就可以直接输此端口就可以烧录啦。</p>
<pre><code>idf.py -p /dev/ttyS15 -b 115200 flash monitor	
</code></pre>
<p>如果 ESP-IDF 监视器在烧录后很快发生错误，或打印信息全是乱码（如下），很有可能是因为开发板采用了 26 MHz 晶振，而 ESP-IDF 默认支持大多数开发板使用的 40 MHz 晶振。</p>
<pre><code>x���ff�f�����`�~�~���f���x��f�f�����ff��`���f����`��~x������ff�f�����`�~�~�f����f����f`���x��f�f�����ff��`���f
</code></pre>
<p>此时，可以：<br>1、退出监视器。<br>2、返回 idf.py menuconfig。<br>3、进入 Component config –&gt; Hardware Settings –&gt; Main XTAL Config –&gt; Main XTAL frequency 进行配置，将 CONFIG_XTAL_FREQ_SEL 设置为 26 MHz。<br>4、重新编译和烧录应用程序。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>启动终端ESP32编译只需要进行以下步骤：</p>
<pre><code>. $HOME/esp/esp-adf/esp-idf/export.sh	//开启编译环境
idf.py set-target esp32			//首次搭建项目时配置
idf.py menuconfig   			//选择需要的配置
idf.py build
idf.py flash
</code></pre>
<p>快捷方式：</p>
<pre><code>get-idf
idf.py set-target esp32
idf.py menuconfig
idf.py build
esp-download
</code></pre>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>环境搭建</category>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C调试记录</title>
    <url>/2024/03/01/I2C%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="I2C基本原理介绍"><a href="#I2C基本原理介绍" class="headerlink" title="I2C基本原理介绍"></a>I2C基本原理介绍</h2><h3 id="时序介绍"><a href="#时序介绍" class="headerlink" title="时序介绍"></a>时序介绍</h3><p>参考Vishay的i2c时序图：</p>
<p><img src="/../pictures/i2c%E6%97%B6%E5%BA%8F%E5%9B%BE1.png" alt="i2c时序图1"><br><img src="/../pictures/i2c%E6%97%B6%E5%BA%8F%E5%9B%BE2.png" alt="i2c时序图2"></p>
<h3 id="代码实现详解"><a href="#代码实现详解" class="headerlink" title="代码实现详解"></a>代码实现详解</h3><p>I2C协议实现有硬件I2C和软件I2C之分，这里只讲解软件I2C实现的版本。一下列出主要结构体和初始化函数。</p>
<h4 id="I2C协议初始化"><a href="#I2C协议初始化" class="headerlink" title="I2C协议初始化"></a>I2C协议初始化</h4><p>I2C协议的scl和sda配置为开漏输出,需要外部上拉（一般为10K电阻）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define i2c_pin_mode(pin,mode)		drv_pin_mode(pin,mode)</span></span><br><span class="line"><span class="comment">#define i2c_pin_write(pin,level) 	drv_pin_write(pin,level)</span></span><br><span class="line"><span class="comment">#define i2c_pin_read(pin) 		drv_pin_read(pin)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DRV_I2C_WR                      0x00</span></span><br><span class="line"><span class="comment">#define DRV_I2C_RD                      (1u &lt;&lt; 0)</span></span><br><span class="line"><span class="comment">#define DRV_I2C_ADDR_10BIT              (1u &lt;&lt; 2)  /* this is a ten bit chip address */</span></span><br><span class="line"><span class="comment">#define DRV_I2C_NO_START                (1u &lt;&lt; 4)</span></span><br><span class="line"><span class="comment">#define DRV_I2C_IGNORE_NACK             (1u &lt;&lt; 5)</span></span><br><span class="line"><span class="comment">#define DRV_I2C_NO_READ_ACK             (1u &lt;&lt; 6)  /* when I2C reading, we do not ACK */</span></span><br><span class="line"><span class="comment">#define DRV_I2C_NO_STOP                 (1u &lt;&lt; 7)</span></span><br><span class="line"></span><br><span class="line">typedef enum&#123;</span><br><span class="line">	EI2C_DEV_1 = 1,</span><br><span class="line">	EI2C_DEV_2,</span><br><span class="line">	EI2C_DEV_3</span><br><span class="line">&#125;EI2C_DEVICE;</span><br><span class="line"></span><br><span class="line">struct drv_soft_i2c_config</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t scl;</span><br><span class="line">	uint8_t sda;</span><br><span class="line">	uint8_t i2c_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct drv_i2c_msg</span><br><span class="line">&#123;</span><br><span class="line">    uint16_t addr;</span><br><span class="line">    uint16_t flags;</span><br><span class="line">    uint16_t len;</span><br><span class="line">	uint8_t reg_addr;</span><br><span class="line">    uint8_t  *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct drv_i2c_bit_ops</span><br><span class="line">&#123;</span><br><span class="line">    void *data;            /* private data <span class="keyword">for</span> lowlevel routines */</span><br><span class="line">    void (*set_sda)(void *data, int state);</span><br><span class="line">    void (*set_scl)(void *data, int state);</span><br><span class="line">    int (*get_sda)(void *data);</span><br><span class="line">    int (*get_scl)(void *data);</span><br><span class="line"></span><br><span class="line">    void (*udelay)(uint32_t us);</span><br><span class="line"></span><br><span class="line">    uint32_t delay_us;  /* scl and sda line delay */</span><br><span class="line">    uint32_t <span class="built_in">timeout</span>;   /* <span class="keyword">in</span> tick */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct drv_i2c_bus_device</span><br><span class="line">&#123;</span><br><span class="line">	struct drv_i2c_msg msg;</span><br><span class="line">	struct drv_i2c_bit_ops ops;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void drv_i2c_gpio_init(struct drv_soft_i2c_config *i2c)</span><br><span class="line">&#123;</span><br><span class="line">    struct drv_soft_i2c_config* cfg = i2c;</span><br><span class="line"></span><br><span class="line">    i2c_pin_mode(cfg-&gt;scl, I2C_PIN_MODE_OUTPUT_OD);	//PIN_MODE_OUTPUT</span><br><span class="line">    i2c_pin_mode(cfg-&gt;sda, I2C_PIN_MODE_OUTPUT_OD);</span><br><span class="line"></span><br><span class="line">    i2c_pin_write(cfg-&gt;scl, I2C_PIN_HIGH);</span><br><span class="line">    i2c_pin_write(cfg-&gt;sda, I2C_PIN_HIGH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int drv_hw_i2c_init(EI2C_DEVICE dev_e)</span><br><span class="line">&#123;</span><br><span class="line">	int size = sizeof(i2c_pin_config)/sizeof(struct drv_soft_i2c_config);</span><br><span class="line">	struct drv_i2c_bus_device *dev = get_i2c_device(dev_e);</span><br><span class="line">	uint8_t dev_num = (uint8_t)dev_e;</span><br><span class="line">	struct drv_soft_i2c_config *pin_cfg = NULL;</span><br><span class="line">	struct drv_i2c_bit_ops *ops = &amp;dev-&gt;ops;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;size;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i2c_pin_config[i].i2c_num == dev_num)</span><br><span class="line">		&#123;</span><br><span class="line">			pin_cfg = (struct drv_soft_i2c_config *)&amp;i2c_pin_config[i];</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pin_cfg == NULL)</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">    ops-&gt;data  = (void*)pin_cfg;</span><br><span class="line">    ops-&gt;set_sda  = n32_set_sda;</span><br><span class="line">    ops-&gt;set_scl  = n32_set_scl;</span><br><span class="line">    ops-&gt;get_sda  = n32_get_sda;</span><br><span class="line">    ops-&gt;get_scl  = n32_get_scl;</span><br><span class="line">    ops-&gt;udelay   = n32_udelay;</span><br><span class="line">    ops-&gt;delay_us = 1;</span><br><span class="line">    ops-&gt;<span class="built_in">timeout</span>  = 5;</span><br><span class="line">    </span><br><span class="line">    drv_i2c_gpio_init(pin_cfg);</span><br><span class="line">    drv_i2c_bus_unlock(pin_cfg);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int drv_i2c_bit_xfer(struct drv_i2c_bit_ops *bus,</span><br><span class="line">                 struct drv_i2c_msg msgs[],</span><br><span class="line">                 uint32_t num);</span><br><span class="line">struct drv_i2c_bus_device *get_i2c_device(EI2C_DEVICE dev_e);</span><br><span class="line">static uint64_t i2c_tick_get(void);</span><br><span class="line">int drv_hw_i2c_init(EI2C_DEVICE dev_e);</span><br><span class="line">int drv_i2c_send_data(EI2C_DEVICE dev_e,uint16_t addr,uint8_t reg_addr,uint8_t *buf,uint16_t len);</span><br><span class="line">int drv_i2c_recv_data(EI2C_DEVICE dev_e,uint16_t addr,uint8_t reg_addr,uint8_t *buf,uint16_t len);</span><br></pre></td></tr></table></figure>

<h2 id="实战开发问题分析"><a href="#实战开发问题分析" class="headerlink" title="实战开发问题分析"></a>实战开发问题分析</h2><p>实际开发过程中，同样的I2C驱动程序，在不同厂家芯片的使用上出现一些问题，导致部分厂家通信异常，导致数据接收不正确，以下进行分析对比，作证并解决问题。</p>
<h3 id="Vishay-和-亿光-接近传感器模块对比"><a href="#Vishay-和-亿光-接近传感器模块对比" class="headerlink" title="Vishay 和 亿光 接近传感器模块对比"></a>Vishay 和 亿光 接近传感器模块对比</h3><p>Vishay 使用VCNL3682S型号芯片，亿光 使用APM-16D24-U6E型号芯片，I2C协议对比。</p>
<h5 id="Vishay-："><a href="#Vishay-：" class="headerlink" title="Vishay ："></a>Vishay ：</h5><p><img src="/../pictures/Vishay%E5%86%99i2c%E5%8D%8F%E8%AE%AE.png" alt="Vishay写i2c协议"><br><img src="/../pictures/Vishay%E8%AF%BBi2c%E5%8D%8F%E8%AE%AE.png" alt="Vishay读i2c协议"></p>
<h5 id="亿光："><a href="#亿光：" class="headerlink" title="亿光："></a>亿光：</h5><p><img src="/../pictures/%E4%BA%BF%E5%85%89i2c%E5%8D%8F%E8%AE%AE.png" alt="亿光i2c协议"></p>
<h6 id="对比波形"><a href="#对比波形" class="headerlink" title="对比波形"></a>对比波形</h6><p>对比协议来看基本上是一致的，用JI2C工具测的i2c波形也基本上一致，但是我自己写的软件i2c驱动，Vishay可以正常使用，亿光读取的数据就有问题，用逻辑分析仪抓一波波形分析一下。</p>
<p>发现每次读完都会多恢复一个ack，而协议上读完最后一个字节需要恢复nack。</p>
<h6 id="修改了以下代码"><a href="#修改了以下代码" class="headerlink" title="修改了以下代码"></a>修改了以下代码</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int i2c_send_ack_or_nack(struct drv_i2c_bit_ops *bus, int ack)</span><br><span class="line">&#123;</span><br><span class="line">    struct drv_i2c_bit_ops *ops = bus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ack)				//if(ack &gt;= 0) 改成 <span class="keyword">if</span>(ack)</span><br><span class="line">        SET_SDA(ops, 0);</span><br><span class="line">    i2c_delay(ops);</span><br><span class="line">    <span class="keyword">if</span> (SCL_H(ops) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">//        logVerbose(<span class="string">&quot;ACK or NACK timeout.&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> -2;</span><br><span class="line">    &#125;</span><br><span class="line">    SCL_L(ops);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>static int i2c_send_ack_or_nack(struct drv_i2c_bit_ops *bus, int ack)&#123;&#125;</code><br>函数主要处理响应回复。</p>
<pre><code>if(ack &gt;= 0)表示每次都会回复ack/nack
if(ack)表示除最后一次数据不回复，其他每次都会回复ack/nack
</code></pre>
]]></content>
      <categories>
        <category>硬件调试</category>
      </categories>
      <tags>
        <tag>逻辑分析仪</tag>
        <tag>接近传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机开发问题汇总</title>
    <url>/2024/01/31/MCU%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="内核复位（kernel-reset）"><a href="#内核复位（kernel-reset）" class="headerlink" title="内核复位（kernel reset）"></a>内核复位（kernel reset）</h2><ul>
<li><strong>内核复位代码，如ADC：</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kernel_reset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __DSB();</span><br><span class="line">    __disable_irq();							<span class="comment">//close irq</span></span><br><span class="line">	drv_adc_deinit(EADC_DEV1,EDMA_CH6);			<span class="comment">//disable adc data</span></span><br><span class="line">    SCB-&gt;AIRCR = ((<span class="number">0x5FA</span> &lt;&lt; SCB_AIRCR_VECTKEY_Pos)      |</span><br><span class="line">                  (SCB-&gt;AIRCR &amp; SCB_AIRCR_PRIGROUP_Msk) |</span><br><span class="line">                   SCB_AIRCR_VECTRESET_Msk);</span><br><span class="line">    __DSB();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>板级初始化前先要重置状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DMA_DeInit(dma_chx);		<span class="comment">//DMA开启循环接收后会持续接收字节</span></span><br><span class="line">ADC_DeInit(adc_handler);</span><br></pre></td></tr></table></figure>
</li>
<li><p>ADC驱动初始化&#x2F;反初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">drv_adc_init</span><span class="params">(EADC_DEVICE adc_dev,EDMA_CHANNEL dma_ch)</span></span><br><span class="line">&#123;</span><br><span class="line">	drv_adc_configuration(adc_dev);</span><br><span class="line">	drv_dma_configuration(adc_dev,dma_ch);</span><br><span class="line">	drv_adc_enable(adc_dev,DISABLE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">drv_adc_deinit</span><span class="params">(EADC_DEVICE adc_dev,EDMA_CHANNEL dma_ch)</span></span><br><span class="line">&#123;</span><br><span class="line">	ADC_Module *adc_handler = drv_get_adc_device(adc_dev)-&gt;ADC_Handler;</span><br><span class="line">	DMA_ChannelType * dma_chx = drv_get_dma_channel(dma_ch);</span><br><span class="line">	</span><br><span class="line">	drv_adc_enable(adc_dev,DISABLE);</span><br><span class="line">	DMA_EnableChannel(dma_chx,DISABLE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<h2 id="MCU复位后状态"><a href="#MCU复位后状态" class="headerlink" title="MCU复位后状态"></a>MCU复位后状态</h2><ul>
<li>复位期间和刚复位后,复用功能未开启,I&#x2F;O端口被配置成模拟功能模式(PCFGy[1:0]&#x3D;00b, PMODEy[1:0]&#x3D;00b)。<br></li>
<li>但有以下几个例外的信号：BOOT0、 NRST、 OSC_IN、 OSC_OUT 默认无 GPIO 功能：<ul>
<li>BOOT0 引脚默认输入下拉</li>
<li>NRST 上拉输入输出<br></li>
</ul>
</li>
<li>复位后，调试系统相关的引脚默认状态为启动 SWD-JTAG， JTAG 引脚被置于输入上拉或下拉模式：<ul>
<li>PA15:JTDI 置于输入上拉模式 </li>
<li>PA14:JTCK 置于输入下拉模式 </li>
<li>PA13:JTMS 置于输入上拉模式</li>
<li>PB4:NJTRST 置于输入上拉模式</li>
<li>PB3:JTD0 置于推挽输出无上下拉<br></li>
</ul>
</li>
<li>PD0 和 PD1<ul>
<li>PD0 和 PD1 在 80 及以上引脚封装默认为模拟模式</li>
<li>PD0 和 PD1 在 80 以下引脚封装复用到 OSC_IN&#x2F;OUT</li>
</ul>
</li>
<li>PC13、 PC14、 PC15：<ul>
<li>PC13～15 为备电域下的三个 IO， 备份域初次上电默认为模拟模式；<br></li>
</ul>
</li>
<li>PB2&#x2F;BOOT1：<ul>
<li>PB2&#x2F;BOOT1 默认处于下拉输入状态；<br></li>
</ul>
</li>
<li>BOOT0 默认输入下拉，参照下表， 若 BOOT 的引脚未连接，则默认选择 Flash 主存储区。</li>
</ul>
<p><img src="/../pictures/mcu%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E8%A1%A8.png" alt="mcu启动选项表"><br><br></p>
<h2 id="printf重定向"><a href="#printf重定向" class="headerlink" title="printf重定向"></a>printf重定向</h2><ul>
<li>MDK版本，勾选Use MicroLIB选项：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> is_lr_sent = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE* f)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (ch == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       is_lr_sent = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (!is_lr_sent)</span><br><span class="line">   	&#123;</span><br><span class="line">           USART_SendData(USART1, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">           <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET);</span><br><span class="line">   	&#125;</span><br><span class="line">   	is_lr_sent = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">   	is_lr_sent = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   USART_SendData(USART1, ch);</span><br><span class="line">   <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET);</span><br><span class="line">   <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>GCC版本</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _write(<span class="type">int</span> fd, <span class="type">char</span>* pBuffer, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        USART_SendData(USART1, pBuffer[i]);</span><br><span class="line">        <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="RT-THREAD调试问题"><a href="#RT-THREAD调试问题" class="headerlink" title="RT-THREAD调试问题"></a>RT-THREAD调试问题</h2><h3 id="串口通信异常"><a href="#串口通信异常" class="headerlink" title="串口通信异常"></a>串口通信异常</h3><ul>
<li>打开UART7接收为<code>DMA IDLE</code>中断，申请一个超时定时器，发送&#x2F;接受各一个任务，发送&#x2F;接受两个队列,以下是错误信息：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">psr: 0x60000000</span><br><span class="line">r00: 0x00000000</span><br><span class="line">r01: 0x20007978</span><br><span class="line">r02: 0x20007978</span><br><span class="line">r03: 0x00000000</span><br><span class="line">r04: 0x00000000</span><br><span class="line">r05: 0x00000000</span><br><span class="line">r06: 0x00000000</span><br><span class="line">r07: 0x20000920</span><br><span class="line">r08: 0x20005908</span><br><span class="line">r09: 0x20000568</span><br><span class="line">r10: 0xdeadbeef</span><br><span class="line">r11: 0xdeadbeef</span><br><span class="line">r12: 0x00000000</span><br><span class="line"> lr: 0x0801156f</span><br><span class="line"> pc: 0x00000000</span><br><span class="line">hard fault on thread: timer</span><br><span class="line"></span><br><span class="line">E [00:00:07,324] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue) assertion failed at <span class="keyword">function</span>:rt_mq_send_wait, line number:2026 </span><br><span class="line"></span><br><span class="line">E [00:00:00,659] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type(&amp;timer-&gt;parent) == RT_Object_Class_Timer) assertion failed at <span class="keyword">function</span>:rt_timer_control, line number:474 </span><br><span class="line"></span><br><span class="line">E [00:00:39,282] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread) assertion failed at function:rt_thread_resume, line number:<span class="number">760</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>问题定位到指针变量<code>p_srx_mq[0]</code>和<code>&amp;p_srx_mq[0]</code>的区别，代码如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define COMM_MAX_NUM     3</span></span><br><span class="line">static uint8_t *p_srx_mq[COMM_MAX_NUM];</span><br><span class="line">static struct comm_serial_mq srx_mq_data[COMM_MAX_NUM];</span><br><span class="line">static struct rt_timer comm_rx_stimer[COMM_MAX_NUM];</span><br><span class="line"></span><br><span class="line">static void comm_serial_recieve_data_deinit(uint8_t num)</span><br><span class="line">&#123;</span><br><span class="line">	srx_mq_data[num].size = 0;</span><br><span class="line">	p_srx_mq[num] = srx_mq_data[num].data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int usart_key_rx_indicate(ESERIAL_DEV serial_dev, uint16_t size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p_srx_mq[0] - srx_mq_data[0].data + size &gt; sizeof(srx_mq_data[0].data))</span><br><span class="line">	&#123;</span><br><span class="line">		comm_serial_recieve_data_deinit(0);</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	rt_timer_start(&amp;comm_rx_stimer[0]);                   // 启动定时器</span><br><span class="line">	drv_fifo_data_get(serial_dev, (uint8_t *)p_srx_mq[0], size);</span><br><span class="line">	logPrintln(<span class="string">&quot;test = [%p][%p][%p]&quot;</span>,p_srx_mq[0],&amp;p_srx_mq[0],srx_mq_data[0].data);</span><br><span class="line">	p_srx_mq[0] += size;</span><br><span class="line">	srx_mq_data[0].size += size;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针取址符-与取值-的区别"><a href="#指针取址符-与取值-的区别" class="headerlink" title="指针取址符&amp;与取值*的区别"></a>指针取址符&amp;与取值*的区别</h4><p><strong>1. 指针取址符(&amp;)</strong></p>
<pre><code>指针取址符 &amp; 用于获取一个变量的地址，并将该地址存储在一个指针变量中。
</code></pre>
<p><strong>具体来说:</strong></p>
<ul>
<li>&amp; 运算符位于变量名前面。</li>
<li>&amp; 运算符的返回值是一个指针，指向该变量的内存地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num; <span class="comment">// p 指向 num 的地址</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 取值符(*)</strong></p>
<pre><code>取值符 * 用于获取指针变量所指向的变量的值。
</code></pre>
<p><strong>具体来说:</strong></p>
<ul>
<li>运算符位于指针变量名前面。</li>
<li>运算符的返回值是该指针变量所指向变量的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num;</span><br><span class="line"><span class="type">int</span> value = *p;		<span class="comment">// 访问 num 的值</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>指针取址符 &amp; 用于获取变量的地址，并将该地址存储在一个指针变量中。</li>
<li>取值符 * 用于获取指针变量所指向的变量的值。</li>
</ul>
<p><strong>需要注意的是：</strong></p>
<ul>
<li>不能对不存在的变量进行取址。</li>
<li>**<code>不能对指针变量进行取址</code>**。</li>
<li>取址操作可能会产生空指针，需要进行空指针检查。</li>
</ul>
<h4 id="为什么不能对指针变量进行取址"><a href="#为什么不能对指针变量进行取址" class="headerlink" title="为什么不能对指针变量进行取址"></a>为什么不能对指针变量进行取址</h4><p><strong>1. 指针变量本身也是一个变量</strong></p>
<p>指针变量也是一个变量，它存储的是另一个变量的地址。与其他变量一样，**<code>指针变量也存在于内存中，并拥有自己的地址</code>**。</p>
<p><strong>2. 取址操作会产生无限循环</strong></p>
<p>**<code>如果对指针变量进行取址，那么就会得到该指针变量的地址</code>**。但是，该指针变量本身也是一个变量，所以其地址也是存储在另一个变量中的。如此循环往复，就会产生无限循环。</p>
<p><strong>3. 违背了指针的定义</strong></p>
<p>指针的定义是指向另一个变量的地址。如果对指针变量进行取址，那么就意味着指针指向了它自己的地址，这违背了指针的定义。</p>
<p><strong>4. 可能导致程序崩溃</strong></p>
<p>在大多数情况下，对指针变量进行取址会导致程序崩溃。这是因为程序会试图访问一个不存在的内存地址。<br><br></p>
<h2 id="TFT屏ST7735S调试问题"><a href="#TFT屏ST7735S调试问题" class="headerlink" title="TFT屏ST7735S调试问题"></a>TFT屏ST7735S调试问题</h2><h3 id="硬件-软件spi初始化"><a href="#硬件-软件spi初始化" class="headerlink" title="硬件&#x2F;软件spi初始化"></a>硬件&#x2F;软件spi初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HARDWARE_SPI_MODE 1	<span class="comment">//1：hardware；0：software</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_SCLK_Clr() GPIO_ResetBits(GPIOA, GPIO_PIN_5)	<span class="comment">//SCL=SCLK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_SCLK_Set() GPIO_SetBits(GPIOA, GPIO_PIN_5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_MOSI_Clr() GPIO_ResetBits(GPIOA, GPIO_PIN_7)		<span class="comment">//SDA=MOSI</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_MOSI_Set() GPIO_SetBits(GPIOA, GPIO_PIN_7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_RES_Clr()  GPIO_ResetBits(GPIOB, GPIO_PIN_0)		<span class="comment">//RES</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_RES_Set()  GPIO_SetBits(GPIOB, GPIO_PIN_0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_DC_Clr()   GPIO_ResetBits(GPIOB, GPIO_PIN_1)		<span class="comment">//DC</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_DC_Set()   GPIO_SetBits(GPIOB, GPIO_PIN_1)</span></span><br><span class="line"> 		     </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_CS_Clr()   GPIO_ResetBits(GPIOA, GPIO_PIN_4)		<span class="comment">//CS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_CS_Set()   GPIO_SetBits(GPIOA, GPIO_PIN_4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_BLK_Clr()											<span class="comment">//BLK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_BLK_Set()</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitType GPIO_InitStructure;</span><br><span class="line">	RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_GPIOA | RCC_APB2_PERIPH_GPIOB , ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HARDWARE_SPI_MODE</span></span><br><span class="line">	SPI_InitType SPI_InitStructure;</span><br><span class="line">	RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_SPI1 | RCC_APB2_PERIPH_AFIO, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct(&amp;GPIO_InitStructure);</span><br><span class="line">    GPIO_InitStructure.Pin        = GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7;</span><br><span class="line">    GPIO_InitStructure.GPIO_Alternate = GPIO_AF0_SPI1;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitPeripheral(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SPIy Config -------------------------------------------------------------*/</span></span><br><span class="line">    SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_TX;</span><br><span class="line">    SPI_InitStructure.SpiMode       = SPI_MODE_MASTER;</span><br><span class="line">    SPI_InitStructure.DataLen       = SPI_DATA_SIZE_8BITS;</span><br><span class="line">    SPI_InitStructure.CLKPOL        = SPI_CLKPOL_HIGH;</span><br><span class="line">    SPI_InitStructure.CLKPHA        = SPI_CLKPHA_FIRST_EDGE;</span><br><span class="line">    SPI_InitStructure.NSS           = SPI_NSS_HARD;</span><br><span class="line">    SPI_InitStructure.BaudRatePres  = SPI_BR_PRESCALER_2;</span><br><span class="line">    SPI_InitStructure.FirstBit      = SPI_FB_MSB;</span><br><span class="line">    SPI_InitStructure.CRCPoly       = <span class="number">7</span>;</span><br><span class="line">    SPI_Init(SPI1, &amp;SPI_InitStructure);</span><br><span class="line"></span><br><span class="line">	SPI_SSOutputEnable(SPI1, ENABLE);</span><br><span class="line">	SPI_EnableCalculateCrc(SPI1, DISABLE);</span><br><span class="line">    <span class="comment">/* Enable SPIy */</span></span><br><span class="line">    SPI_Enable(SPI1, ENABLE);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	GPIO_InitStruct(&amp;GPIO_InitStructure);</span><br><span class="line">	GPIO_InitStructure.Pin = GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitPeripheral(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(GPIOA, GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	GPIO_InitStruct(&amp;GPIO_InitStructure);</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1;</span><br><span class="line">	GPIO_InitPeripheral(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(GPIOB, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Writ_Bus</span><span class="params">(u8 dat)</span> </span><br><span class="line">&#123;	</span><br><span class="line">	LCD_CS_Clr();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HARDWARE_SPI_MODE</span></span><br><span class="line">	SPI_I2S_TransmitData(SPI1, dat);</span><br><span class="line">	<span class="keyword">while</span> (SPI_I2S_GetStatus(SPI1, SPI_I2S_TE_FLAG) == RESET); <span class="comment">//必须等到SPI数据发完，才能拉高CS片选，发下一次数据，否则数据会出错</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	u8 i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;			  </span><br><span class="line">		LCD_SCLK_Clr();</span><br><span class="line">		<span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		   LCD_MOSI_Set();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		   LCD_MOSI_Clr();</span><br><span class="line">		&#125;</span><br><span class="line">		LCD_SCLK_Set();</span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   LCD_CS_Set();	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_DATA8</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">	LCD_Writ_Bus(dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_DATA</span><span class="params">(u16 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">	LCD_Writ_Bus(dat&gt;&gt;<span class="number">8</span>);</span><br><span class="line">	LCD_Writ_Bus(dat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>MCU</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown小贴士</title>
    <url>/2024/02/19/Markdown%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
    <content><![CDATA[<h3 id="Markdown-的基本语法"><a href="#Markdown-的基本语法" class="headerlink" title="Markdown 的基本语法"></a>Markdown 的基本语法</h3><p>Markdown 的语法非常简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。以下是一些常用的 Markdown 标记符号：</p>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题	
</code></pre>
<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><pre><code>普通文本
**加粗文本**
* 斜体文本*
**~删除线文本~**
</code></pre>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><pre><code>* 无序列表
1. 有序列表
    * 嵌套列表
</code></pre>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><pre><code>链接文本: [https://www.example.com](https://www.example.com)
</code></pre>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><pre><code>网络地址: ![这是一张示例图片](https://www.example.com/example.png)
本地文件路径：![这是一张示例图片](../pictures/这是一张示例图片.png)
图片链接跳转: ![这是一张示例图片](example.png) &#123;link=https://www.example.com/&#125;
图片标题: ![这是一张示例图片](example.png) &#123;title=这是一张示例图片&#125;
图片居中: ![这是一张示例图片](example.png) &#123;align=center&#125;

示例：
![这是一张示例图片](example.png)
![这是一张 200x100 像素的图片](example.png) &#123;width=200 height=100&#125;
![这是一张居中的图片](example.png) &#123;align=center&#125;
![点击图片跳转到 https://www.example.com/](example.png) &#123;link=https://www.example.com/&#125;
![这是一张示例图片](example.png) &#123;title=这是一张示例图片&#125;
</code></pre>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><table>
<thead>
<tr>
<th>头部1</th>
<th>头部2</th>
<th>头部3</th>
</tr>
</thead>
<tbody><tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
<tr>
<td>内容4</td>
<td>内容5</td>
<td>内容6</td>
</tr>
</tbody></table>
<h3 id="Markdown-的应用"><a href="#Markdown-的应用" class="headerlink" title="Markdown 的应用"></a>Markdown 的应用</h3><pre><code>博客文章
技术文档
README 文件
演示文稿
电子书
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>Markdown 是一种易于学习和使用的标记语言，非常适合编写各种文档。如果您还没有使用过 Markdown，建议您尝试一下。
</code></pre>
<p>以下是 Markdown 官方教学网站：<br><a href="https://markdown.com.cn/basic-syntax/headings.html">Markdown 官方网站</a></p>
]]></content>
      <categories>
        <category>文本编辑工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下开发单片机</title>
    <url>/2024/03/28/linux-arm-gcc%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="Ubuntu-Wsl环境搭建"><a href="#Ubuntu-Wsl环境搭建" class="headerlink" title="Ubuntu Wsl环境搭建"></a>Ubuntu Wsl环境搭建</h2><h3 id="Windows10系统安装子系统Wsl"><a href="#Windows10系统安装子系统Wsl" class="headerlink" title="Windows10系统安装子系统Wsl"></a>Windows10系统安装子系统Wsl</h3><p><strong>1. 通过 Microsoft Store 安装</strong></p>
<ul>
<li>打开 Microsoft Store。</li>
<li>搜索 “适用于 Linux 的 Windows 子系统”。</li>
<li>选择 “Ubuntu” 或您喜欢的其他 Linux 发行版。</li>
<li>点击 “获取”。</li>
<li>安装完成后，点击 “启动”。</li>
</ul>
<p><strong>2. 通过命令行</strong></p>
<ul>
<li><p>打开 PowerShell 或 命令提示符 以管理员身份运行。</p>
</li>
<li><p>输入以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启您的计算机。</p>
</li>
<li><p>安装完成后，您可以通过以下命令启动 WSL：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ul>
<li>WSL 需要 Windows 10 版本 1709 或更高版本。</li>
<li>您可以通过以下命令检查您的 Windows 版本：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">winver</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果您使用的是 Windows 10 家庭版，您需要启用 “<strong>适用于 Linux 的 Windows 子系统</strong>” 功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">控制面板-&gt;程序和功能-&gt;启用或关闭 Windows 功能-&gt;适用于 Linux 的 Windows 子系统-&gt;确定</span><br></pre></td></tr></table></figure>
</li>
<li><p>您可以通过以下命令启用 “<strong>适用于 Linux 的 Windows 子系统</strong>” 功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启您的计算机后，您就可以通过上述方法安装 WSL 了。</p>
</li>
</ul>
<p>安装Windows Terminal</p>
<h3 id="编译环境配置"><a href="#编译环境配置" class="headerlink" title="编译环境配置"></a>编译环境配置</h3><ul>
<li><p>gcc-arm-none-eabi工具链安装</p>
<ul>
<li>手动安装：<a href="https://developer.arm.com/downloads/-/gnu-rm">官方链接地址</a> 下载所需版本；  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install bzip2</span><br><span class="line">sudo tar -xvf ~/n32_gcc/software_package/gcc-arm-none-eabi-9-2019-q4-major-x86_64-linux.tar.bz2 -C ~/n32_gcc</span><br></pre></td></tr></table></figure></li>
<li>自动安装：<code>sudo apt-get install gcc-arm-none-eabi</code></li>
<li>打开 <code>~/.bashrc</code></li>
<li>添加<code>export PATH=$PATH:~/n32_gcc/gcc-arm-none-eabi-9-2019-q4-major/bin</code></li>
<li>添加<code>alias open-file=&#39;explorer.exe .&#39;</code></li>
<li>使能用户环境变量<code>source ~/.bashrc</code></li>
</ul>
</li>
<li><p>Make</p>
<ul>
<li><code>sudo apt-get install make</code></li>
</ul>
</li>
</ul>
<h3 id="Winodows-Gcc-Make-环境搭建"><a href="#Winodows-Gcc-Make-环境搭建" class="headerlink" title="Winodows Gcc + Make 环境搭建"></a>Winodows Gcc + Make 环境搭建</h3><ul>
<li>安装software_package目录下的gcc-arm-none-eabi-9-2019-q4-major-win32-sha2.exe和make-3.81.exe</li>
<li>分别将其安装目录下的 .&#x2F;bin添加到系统环境变量，重启生效</li>
<li>复制裸机工程至Windows下，修改部分Makefile的linux指令以适配Windows即可</li>
</ul>
<h3 id="裸机工程编译"><a href="#裸机工程编译" class="headerlink" title="裸机工程编译"></a>裸机工程编译</h3><ul>
<li>cd n32g452_gcc</li>
<li>make</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>杂项</title>
    <url>/2024/01/31/%E6%9D%82%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="Linux-打开端口-bashrc不会自动刷新"><a href="#Linux-打开端口-bashrc不会自动刷新" class="headerlink" title="Linux 打开端口~&#x2F;.bashrc不会自动刷新"></a>Linux 打开端口~&#x2F;.bashrc不会自动刷新</h2><p>解决linux每次打开新终端都要重新<code>source ~/.bashrc</code>问题<br>执行以下代码：</p>
<pre><code>vi ~/.bash_profile
</code></pre>
<p>有可能此文件是空白新建的，无所谓。然后在此文件末尾加入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ];then</span><br><span class="line">source ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>然后<code>:wq</code>保存即可。<br>此时打开新终端可以自动执行<code>source ~/.bashrc</code></p>
<h2 id="J-Link-J-Flash"><a href="#J-Link-J-Flash" class="headerlink" title="J-Link&#x2F;J-Flash"></a>J-Link&#x2F;J-Flash</h2><p><strong>J-Flash批处理脚本配置烧录：</strong>当然，前提是要添加J-Link的可执行程序路径到<code>$PATH</code>环境变量中</p>
<ul>
<li><code>program.bat</code>脚本代码如下，参考修改即可：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo start...</span><br><span class="line"></span><br><span class="line">JLink -device N32L406CB -if swd -speed 4000 -CommanderScript &quot;C:\Users\Breo\Desktop\Wireless moxibustion\Software\program.jlink&quot;</span><br></pre></td></tr></table></figure></li>
<li><code>program.jlink</code>文件代码如下，其中目标设备、文件路径、烧录地址等根据需要配置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connect</span><br><span class="line">device N32L406CB</span><br><span class="line">si SWD</span><br><span class="line">speed 4000</span><br><span class="line">h		// halt-停止</span><br><span class="line">r		// 复位，可以考虑去掉</span><br><span class="line">erase		// 或 erase 0x8002800，去掉也行，但可能会出现error fail address 0x00000000错误提示</span><br><span class="line"></span><br><span class="line">loadfile app.bin 0x8002800      // loadfile app.hex 或 loadfile app.bin 0x8000000</span><br><span class="line">verifybin app.bin 0x8002800</span><br><span class="line">r</span><br><span class="line">go		// r go表示reset and run</span><br><span class="line">q		// 退出J-Link命令行工具</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Ubuntu-无法更新问题"><a href="#Ubuntu-无法更新问题" class="headerlink" title="Ubuntu 无法更新问题"></a>Ubuntu 无法更新问题</h2><p>Ubuntu 无法使用<code>apt update</code></p>
<h3 id="更改软件源"><a href="#更改软件源" class="headerlink" title="更改软件源"></a>更改软件源</h3><p>编辑 <code>/etc/apt/sources.list</code> 文件，将以下内容添加到文件末尾</p>
<pre><code>deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse

deb https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse

deb https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
</code></pre>
<h3 id="清除-apt-缓存"><a href="#清除-apt-缓存" class="headerlink" title="清除 apt 缓存"></a>清除 apt 缓存</h3><pre><code>sudo apt clean
sudo apt autoclean
</code></pre>
<h3 id="尝试更新系统"><a href="#尝试更新系统" class="headerlink" title="尝试更新系统"></a>尝试更新系统</h3><pre><code>sudo apt update
</code></pre>
<p>显示 <code>ModuleNotFoundError: No module named &#39;apt_pkg&#39;</code>，重新安装 “<code>apt_pkg</code>“ 模块：</p>
<pre><code>sudo apt install --reinstall python3-apt
</code></pre>
<p>显示 ERROR：</p>
<pre><code>E: Could not read response to hello message from hook [ ! -f /usr/bin/snap ] || /usr/bin/snap advise-snap --from-apt 2&gt;/dev/null || true: Success
</code></pre>
<p>如果问题仍然存在，尝试修复 Python 包：</p>
<pre><code>sudo apt install --fix-broken
</code></pre>
<p>然后就更新系统了：</p>
<pre><code>sudo apt update
sudo apt upgrade
</code></pre>
<p>执行<code>sudo apt upgrade</code>后显示ERROR：</p>
<pre><code>Errors were encountered while processing:
/tmp/apt-dpkg-install-cQBLJW/626-linux-iot-tools-common_5.4.0-1030.31_all.deb
E: Sub-process /usr/bin/dpkg returned an error code (1)
</code></pre>
<p>最后一步，修复损坏的软件包配置：</p>
<pre><code>sudo dpkg --configure -a
sudo apt upgrade
</code></pre>
<h2 id="Breo蓝牙启动异常"><a href="#Breo蓝牙启动异常" class="headerlink" title="Breo蓝牙启动异常"></a>Breo蓝牙启动异常</h2><h3 id="Breo蓝牙初始化"><a href="#Breo蓝牙初始化" class="headerlink" title="Breo蓝牙初始化"></a>Breo蓝牙初始化</h3><p>蓝牙初始化没完成，透传未开启，app就连接蓝牙了。<br>设置透传参数，开启透传的的状态中增加连接蓝牙接受指令。</p>
<h3 id="心跳包回复超时"><a href="#心跳包回复超时" class="headerlink" title="心跳包回复超时"></a>心跳包回复超时</h3><p>现在是接收&#x2F;刷新设备数据200ms超时，延迟太长还可以缩短。</p>
<h2 id="SPI级联led灯调试小助手"><a href="#SPI级联led灯调试小助手" class="headerlink" title="SPI级联led灯调试小助手"></a>SPI级联led灯调试小助手</h2><p>产品名称：1209RGB幻彩雾状<br>产品型号：XTQ-016B.RGB-2307125-20</p>
<h3 id="SPI级联led灯问题汇总"><a href="#SPI级联led灯问题汇总" class="headerlink" title="SPI级联led灯问题汇总"></a>SPI级联led灯问题汇总</h3><h4 id="充电闪灯问题"><a href="#充电闪灯问题" class="headerlink" title="充电闪灯问题"></a>充电闪灯问题</h4><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>充电中拔掉电源，立即再次插入，会闪一下灯；若等两秒再插入则不会出现，初步判断是此款芯片有锁存功能，会保存到寄存器中，未完全掉电再次插入则会继续执行上次的寄存器数据。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>充电中拔掉电源，程序不要立即断电，持续两秒反初始化spi灯珠，即给spi寄存器写全灭数据。</p>
<h4 id="呼吸灯闪烁问题"><a href="#呼吸灯闪烁问题" class="headerlink" title="呼吸灯闪烁问题"></a>呼吸灯闪烁问题</h4><h5 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h5><p>程序中呼吸灯会跑偶尔闪烁，影响显示效果。分析发现，代码中有电机的FG检测，此检测开启了输入捕获功能，会持续中断触发，虽然spi灯的驱动是dma发送，但是也是由CPU来调度的，并不能与中断并行。spi呼吸灯效果需要持续发送数据，且时序要求很高，中断会抢占spi的dma发送，打断spi传输数据，导致数据传输出错，造成闪灯效果。</p>
<h5 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h5><p>1、提高芯片主频，n32l403KB最高主频为64MHz，如果主频提高效果会好一些。<br>2、spi呼吸灯效果持续发送数据，不能与中断频繁的代码一起使用。</p>
<h2 id="某项目充电保护仍充电"><a href="#某项目充电保护仍充电" class="headerlink" title="某项目充电保护仍充电"></a>某项目充电保护仍充电</h2><p>修改代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;-1, 1, PIN_CHARGE_CC_DETECT, PIN_MODE_INPUT&#125;,	//input/output switch</span><br><span class="line"></span><br><span class="line">static void board_charge_cc_set(bool en)</span><br><span class="line">&#123;	</span><br><span class="line">	struct pin_status_desc *pin = pin_handle(PIN_CHARGE_CC_DETECT);</span><br><span class="line">	<span class="keyword">if</span>(en)</span><br><span class="line">	&#123;</span><br><span class="line">		pin-&gt;<span class="built_in">type</span> = PIN_MODE_INPUT;</span><br><span class="line">		drv_pin_mode(pin-&gt;pin_id,pin-&gt;<span class="built_in">type</span>);</span><br><span class="line">		pin-&gt;lvl_rt = -1;			//重置lvl_rt，以防止output出问题</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		pin-&gt;<span class="built_in">type</span> = PIN_MODE_OUTPUT;</span><br><span class="line">		drv_pin_mode(pin-&gt;pin_id,pin-&gt;<span class="built_in">type</span>);</span><br><span class="line">		pin_set_func(pin, PIN_HIGH);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Git小贴士"><a href="#Git小贴士" class="headerlink" title="Git小贴士"></a>Git小贴士</h2><h3 id="执行-git-pull-会覆盖本地的修改吗？"><a href="#执行-git-pull-会覆盖本地的修改吗？" class="headerlink" title="执行 git pull 会覆盖本地的修改吗？"></a>执行 git pull 会覆盖本地的修改吗？</h3><p>没有冲突的情况下，远端会直接更新至本地上，但不会改变本地未提交的变动；如果本地修改已提交，则会执行一个远端分支和本地分支的合并</p>
<h3 id="git-fetch-和-git-pull-的区别与联系"><a href="#git-fetch-和-git-pull-的区别与联系" class="headerlink" title="git fetch 和 git pull 的区别与联系"></a>git fetch 和 git pull 的区别与联系</h3><p><code>git fetch</code>用于从远程仓库获取最新的提交，保存到本地的远程跟踪分支中（<code>FETCH_HEAD</code>），可以通过查看此分支了解远程仓库的更新情况</p>
<ul>
<li><code>git diff FETCH_HEAD</code>比较查看该分支和当前工作分支的内容</li>
</ul>
<br>

<p><code>git pull</code>会自动获取远程仓库的更新，并且合并到当前分支上，相当于<code>git fetch</code> + <code>git merge FETCH_HEAD</code></p>
<ul>
<li>将远程仓库中指定分支的最新提交 ID 保存到本地的 <code>FETCH_HEAD</code> 分支中</li>
<li>将 <code>FETCH_HEAD</code> 分支合并到当前工作分支中</li>
</ul>
<h3 id="基础非典型操作"><a href="#基础非典型操作" class="headerlink" title="基础非典型操作"></a>基础非典型操作</h3><h3 id="本地git配置"><a href="#本地git配置" class="headerlink" title="本地git配置"></a>本地git配置</h3><br>

<p><strong>配置本地与远端的SSH密钥连接流程：</strong></p>
<ul>
<li>本地生成SSH公钥和私钥(如果没有的话，另，linux下公钥通常存放于<code>~/.ssh/*.pub</code>)<ul>
<li><code>ssh-keygen -t rsa -b 4096 -C xxx@xxx.com</code></li>
</ul>
</li>
<li>复制公钥，添加至远端平台的SSH设置上<br></li>
</ul>
<p><strong>查看本地配置：</strong></p>
<ul>
<li><code>git config --list</code>查看当前项目的所有配置</li>
<li><code>git config --global --list</code>查看全局配置<br></li>
</ul>
<p><strong>修改用户名(全局&#x2F;当前项目)</strong></p>
<p>此用户名即提交日志上所展示的用户名称</p>
<ul>
<li>修改全局用户名：<code>git config --global user.name &quot;xxx&quot;</code>，影响用户的所有仓库</li>
<li>修改当前路径项目的用户名：<code>git config user.name &quot;xxx&quot;</code></li>
<li>查看全局用户名：<code>git config user.name</code><br></li>
</ul>
<p><strong>初始化本地工程并与远端已有仓库的main分支关联：</strong></p>
<ul>
<li>进入工程根目录，<code>git init</code>初始化本地仓库</li>
<li>添加远程仓库：<code>git remote add origin &lt;远程仓库地址&gt;</code></li>
<li><code>git branch -M main</code>将当前分支重命名为<code>main</code>，M即<code>--move --force</code>的缩写。（可以分别输入<code>git add --all</code>，<code>git commit -m &quot;first commit&quot;</code>完成对本地分支的首次提交）</li>
<li>使用<code>git pull origin main</code>，将远程仓库的main分支拉取到本地，或者<code>git push -u origin main -f</code>将本地的xxx分支强制推送到远端main分支，其中-u是<code>--set-upstream</code>的缩写，后续会保持这个跟踪关系</li>
</ul>
<br>

<h2 id="makefile问题汇总"><a href="#makefile问题汇总" class="headerlink" title="makefile问题汇总"></a>makefile问题汇总</h2><h3 id="修改-h文件没有重新编译"><a href="#修改-h文件没有重新编译" class="headerlink" title="修改.h文件没有重新编译"></a>修改.h文件没有重新编译</h3><p>原来的编译规则：</p>
<pre><code>-include $(wildcard $(OUTPUT_DIR)/*/*.d)	# 包含所有生成的依赖文件，避免重复编译、提高效率

/*/*.d 当前目录下的二级所有文件检索。
</code></pre>
<p>修改为以下编译规则：</p>
<pre><code># 找到所有的 .d 文件
DEP_FILES := $(shell find $(BUILD_DIR) -type f -name &#39;*.d&#39;)# 包含所有生成的依赖文件，避免重复编译、提高效率

# 包含所有的 .d 文件
-include $(DEP_FILES)
</code></pre>
<p>或者：</p>
<pre><code>-include $(wildcard $(OUTPUT_DIR)/**/*.d)
-include $(wildcard $(OUTPUT_DIR)/*/*/*.d)

/**/*.d 当前目录下的二级所有文件检索，根据具体情况修改。
/*/*/*.d 当前目录下的三级所有文件检索，根据具体情况修改。
</code></pre>
<br>

<h2 id="windows子系统wsl"><a href="#windows子系统wsl" class="headerlink" title="windows子系统wsl"></a>windows子系统wsl</h2><h3 id="arm-none-eabi-gcc工具链问题"><a href="#arm-none-eabi-gcc工具链问题" class="headerlink" title="arm-none-eabi-gcc工具链问题"></a>arm-none-eabi-gcc工具链问题</h3><p>arm-none-eabi-gcc工具链需加入用户变量：</p>
<pre><code>export PATH=/home/xuan/OpenHarmony/install-software/gcc-arm-none-eabi-9-2019-q4-major/bin:$PATH
</code></pre>
<p>注意：需确认路径，否则找不到用户路径会搜索系统自带编译链 &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;arm-none-eabi&#x2F;10.3.1</p>
<br>

<h2 id="Linux下编写Python合并脚本"><a href="#Linux下编写Python合并脚本" class="headerlink" title="Linux下编写Python合并脚本"></a>Linux下编写Python合并脚本</h2><h3 id="合并-bootloader-app-mix"><a href="#合并-bootloader-app-mix" class="headerlink" title="合并 bootloader + app  &#x3D; mix"></a>合并 bootloader + app  &#x3D; mix</h3><p><strong>1. 安装 PyInstaller</strong></p>
<pre><code>pip install pyinstaller
</code></pre>
<br>

<p><strong>2. 编写Python合并程序</strong></p>
<p><a href="https://github.com/XUAN9527/script">代码链接</a></p>
<br>

<p><strong>3. 打包 Python 程序</strong></p>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-F</code>：生成单一可执行文件。</li>
<li><code>-D</code>：生成包含所有依赖项的目录。</li>
<li><code>-n</code>：指定可执行文件名。</li>
<li><code>--distpath</code>：指定可执行文件输出目录。</li>
<li><code>--noconfirm</code>：覆盖输出文件时无需确认。</li>
</ul>
<p><strong>以下是一些常用的高级选项：</strong></p>
<ul>
<li><code>--hidden-import</code>：指定要隐藏导入的模块。</li>
<li><code>--exclude-module</code>：指定要排除的模块。</li>
<li><code>--onefile</code>：将所有文件打包成一个可执行文件。</li>
<li><code>--runtime</code>：指定 Python 运行时版本。</li>
</ul>
<p><strong>执行规则:</strong></p>
<pre><code>cd new_file,copy file.py and file.ico
pyinstaller -F -w (-i icofile) 文件名.py
</code></pre>
<p><strong>example:</strong></p>
<pre><code>pyinstaller -F file.py
pyinstaller -F -w -i file.ico file.py
</code></pre>
<br>

<p><strong>4. 运行可执行文件</strong></p>
<pre><code>./dist/file
</code></pre>
<br>

<p><strong>5. 例程</strong></p>
<p><a href="https://github.com/XUAN9527/script">代码链接</a></p>
<br>

<p><strong>6. 实际应用场景</strong></p>
<ul>
<li>单独使用：Linux环境下单独执行使用。</li>
<li>集成在<code>makefile</code>中，使用<code>make</code>编译自动生成文件：<ul>
<li>将<code>papp_up</code>和<code>mix_10K</code>打包至<code>tools</code>文件夹，放在<code>makefile</code>同一目录下。</li>
<li>需要<code>bootloder.bin</code>在<code>../bootloader</code>目录下。</li>
<li>修改makefile生成规则。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.PHONY : clean all</span><br><span class="line"></span><br><span class="line">all: $(TARGET).bin $(TARGET).<span class="built_in">list</span> $(TARGET).hex</span><br><span class="line">	$(SZ) $(TARGET).elf</span><br><span class="line">	@make copy</span><br><span class="line">	@make mix</span><br><span class="line"></span><br><span class="line">.PHONY: copy</span><br><span class="line"></span><br><span class="line">copy: $(TARGET).bin</span><br><span class="line">	cp $(TARGET).bin app.bin</span><br><span class="line">	cp ../bootloader/bootloader.bin bootloader.bin</span><br><span class="line"><span class="meta">#	cp $(TARGET).hex app.hex</span></span><br><span class="line"></span><br><span class="line">mix:</span><br><span class="line">	./tools/papp_up</span><br><span class="line">	./tools/mix_10K</span><br><span class="line">	$(OC) -I binary -O ihex --change-addresses <span class="number">0x8000000</span> mix.bin mix.hex</span><br><span class="line">	rm bootloader.bin</span><br><span class="line">	rm app.bin</span><br><span class="line">	rm mix.bin</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -rf $(BUILD_DIR)</span><br><span class="line">	rm papp.bin</span><br><span class="line">	rm mix.hex</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<br>

<h2 id="可变参数函数详解"><a href="#可变参数函数详解" class="headerlink" title="可变参数函数详解"></a>可变参数函数详解</h2><p>在C语言中，<code>printf</code> 是一个标准库函数，用于在终端或其他输出设备上打印格式化的文本。它是一个<strong>可变参数函数</strong>，接受一个格式字符串作为第一个参数，后面是可变数量的参数，用于替换格式字符串中的格式占位符。</p>
<p>让我们来详细解析一下可变参数函数和宏，以及如何实现一个类似于 <code>printf</code> 的函数。</p>
<p><strong>1. 可变参数函数：</strong></p>
<ul>
<li>可变参数函数允许在函数定义中接受不定数量的参数。</li>
<li>C语言提供了 <code>stdarg.h</code> 头文件来支持可变参数函数的实现。</li>
<li>下面是一个示例代码，展示了如何实现一个可变参数函数 sum，它接受一个整数参数 count，表示接下来的可变参数的数量：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> count, ...)</span> &#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">        total += num;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = sum(<span class="number">4</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个示例中，我们定义了一个可变参数函数 sum，它计算传入的整数参数的总和。</li>
</ul>
<br>

<p><strong>2. 可变参数宏：</strong></p>
<ul>
<li>可变参数宏允许在宏调用中接受可变数量的参数。</li>
<li>在C语言中，可变参数宏使用 <code>__VA_ARGS__</code> 表示可变参数的部分。</li>
<li>下面是一个示例代码，展示了如何定义一个可变参数宏 <code>PRINT_VALUES</code>，它使用 printf 函数来打印可变数量的值:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_VALUES(...) do &#123; \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;Values: &quot;</span>); \</span></span><br><span class="line"><span class="meta">    printf(__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;\n&quot;</span>); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    PRINT_VALUES(<span class="string">&quot;%d %s %f&quot;</span>, <span class="number">10</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个示例中，我们定义了一个可变参数宏 <code>PRINT_VALUES</code>，它使用 <code>printf</code> 函数来打印多个值。</li>
</ul>
<br>

<p><strong>3. 实现自己的 printf 函数：</strong></p>
<ul>
<li><code>printf</code> 函数接受一个格式字符串作为第一个参数，后面是可变数量的参数，用于替换格式字符串中的格式占位符。</li>
<li>以下是一个简化版的示例代码，展示了一个实现类似于 <code>printf</code> 函数的功能的函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span> &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line">    <span class="keyword">while</span> (*format != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*format == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">            format++; <span class="comment">// 移动到占位符的下一个字符</span></span><br><span class="line">            <span class="keyword">if</span> (*format == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> value = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">double</span> value = va_arg(args, <span class="type">double</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">char</span>* value = va_arg(args, <span class="type">char</span>*);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> value = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Unsupported format specifier: %c&quot;</span>, *format);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *format);</span><br><span class="line">        &#125;</span><br><span class="line">        format++; <span class="comment">// 移动到下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">	<span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">	<span class="type">char</span> str[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	my_printf(<span class="string">&quot;Integer: %d\n&quot;</span>, num);</span><br><span class="line">	my_printf(<span class="string">&quot;Float: %f\n&quot;</span>, pi);</span><br><span class="line">	my_printf(<span class="string">&quot;Float: %s\n&quot;</span>, str);</span><br><span class="line">	my_printf(<span class="string">&quot;Float: %c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="移植cmbacktrace到cm4内核"><a href="#移植cmbacktrace到cm4内核" class="headerlink" title="移植cmbacktrace到cm4内核"></a>移植cmbacktrace到cm4内核</h2>]]></content>
  </entry>
</search>
