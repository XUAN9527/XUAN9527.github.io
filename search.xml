<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ESP32开发小贴士</title>
    <url>/2024/02/22/ESP32%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
    <content><![CDATA[<h2 id="ESP32-ESP-IDF自定义组件"><a href="#ESP32-ESP-IDF自定义组件" class="headerlink" title="ESP32 ESP-IDF自定义组件"></a>ESP32 ESP-IDF自定义组件</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p><a href="https://link.zhihu.com/?target=https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/build-system.html%23component-cmakelists-files">英文官方文档链接</a><br><a href="https://link.zhihu.com/?target=https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-guides/build-system.html%23id21">中文官方文档链接</a></p>
<h4 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h4><p>此示例在《<strong>ESP32 smart_config和airkiss配网</strong>》<br><a href="https://zhuanlan.zhihu.com/p/440454542">https://zhuanlan.zhihu.com/p/440454542</a><br><a href="https://link.zhihu.com/?target=https://blog.csdn.net/chentuo2000/article/details/121687760">https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/121687760</a><br>基础上，增加连接成功后点亮板载LED功能。<br>实现所需功能后将各功能代码分离，再将分离后的代码构造成组件，使得项目有清晰的结构，方便功能代码移植.</p>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>以下有三种方法：</p>
<ol>
<li><p>《Win10启用Linux子系统安装Ubuntu》<br><a href="https://link.zhihu.com/?target=https://blog.csdn.net/chentuo2000/article/details/112131624">https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/112131624</a></p>
</li>
<li><p>《用乐鑫国内Gitee镜像搭建ESP32开发环境》<br><a href="https://link.zhihu.com/?target=https://blog.csdn.net/chentuo2000/article/details/113424934">https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/113424934</a></p>
</li>
<li><p>《ESP32环境搭建》（自己写的环境搭建）<br><a href="https://xuan9527.github.io/2024/02/19/ESP32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">https://xuan9527.github.io/2024/02/19/ESP32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</a></p>
</li>
</ol>
<h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><h4 id="拷贝-初始化例程"><a href="#拷贝-初始化例程" class="headerlink" title="拷贝 &amp;&amp; 初始化例程"></a>拷贝 &amp;&amp; 初始化例程</h4><p>将例子项目<code>hello_world</code>复制到<code>ESP-IDF</code>开发工具之外,更名为<code>components_demo</code>:</p>
<pre><code>cd ~/esp
cp -r ~/esp/esp-adf/esp-idf/examples/get-started/hello_world ./components_demo
</code></pre>
<p>清空<code>build</code>目录:</p>
<pre><code>cd ~/esp/components_demo
rm -r build/*
</code></pre>
<p>注意，每当添加了新组件就要删除<code>build</code>目录下的全部内容，或者执行下面这条命令：</p>
<pre><code>idf.py fullclean
</code></pre>
<p>清除以前的构建。</p>
<h4 id="添加组件letter-shell"><a href="#添加组件letter-shell" class="headerlink" title="添加组件letter_shell"></a>添加组件letter_shell</h4><pre><code>idf.py -C components create-component letter_shell
</code></pre>
<p>该命令会创建一个新组件,新组件将包含构建组件所需的一组空文件。我们的工作就是在这一组空文件中写上我们的代码。<br>如果熟悉了组件结构，也可以直接在项目中手工创建。</p>
<h4 id="项目树"><a href="#项目树" class="headerlink" title="项目树"></a>项目树</h4><p>构建好的项目结构如下:</p>
<p><img src="/../pictures/component_demo%E8%AE%BE%E5%A4%87%E6%A0%91.png" alt="component_demo设备树"></p>
<p>注意：组件目录<code>components</code>名字不能改，其下的组件名可以随意取。build目录是编译时生成的，编译的结果都放在其中。<code>dependencies.lock</code>是随原来的项目复制过来的不要改。<code>sdkconfig</code>文件可以用<code>idf.py menuconfig</code>命令修改。</p>
<br>

<h3 id="代码和说明"><a href="#代码和说明" class="headerlink" title="代码和说明"></a>代码和说明</h3><p>各文件的位置关系很重要，请对照前面的项目树看代码文件。</p>
<h4 id="项目的根CMakeLists-txt文件"><a href="#项目的根CMakeLists-txt文件" class="headerlink" title="项目的根CMakeLists.txt文件"></a>项目的根CMakeLists.txt文件</h4><pre><code># The following lines of boilerplate have to be in your project&#39;s
# CMakeLists in this exact order for cmake to work correctly
cmake_minimum_required(VERSION 3.16)

include($ENV&#123;IDF_PATH&#125;/tools/cmake/project.cmake)
project(components_demo)
</code></pre>
<p>只需要修改<code>project</code>中的项目名称。</p>
<h4 id="main目录"><a href="#main目录" class="headerlink" title="main目录"></a>main目录</h4><p><strong>CMakeLists.txt</strong></p>
<pre><code>idf_component_register(SRCS &quot;main.c&quot;
            INCLUDE_DIRS &quot;.&quot;
            PRIV_REQUIRES letter_shell
            REQUIRES nvs_flash)
</code></pre>
<p><strong>main.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shell_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *TAG = <span class="string">&quot;sample test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">esp_err_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize NVS.</span></span><br><span class="line">    ret = nvs_flash_init();</span><br><span class="line">    <span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) &#123;</span><br><span class="line">        ESP_ERROR_CHECK(nvs_flash_erase());</span><br><span class="line">        ret = nvs_flash_init();</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_ERROR_CHECK( ret );</span><br><span class="line"></span><br><span class="line">	esp_log_level_set(TAG, ESP_LOG_INFO);</span><br><span class="line">	ESP_LOGI(TAG,<span class="string">&quot;this is a test program&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	userShellInit();</span><br><span class="line"></span><br><span class="line">	logInfo(<span class="string">&quot;log info!&quot;</span>);</span><br><span class="line">	logDebug(<span class="string">&quot;log debug!&quot;</span>);</span><br><span class="line">	logWarning(<span class="string">&quot;log warning!&quot;</span>);</span><br><span class="line">	logError(<span class="string">&quot;log error!&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		logDebug(<span class="string">&quot;log loop!&quot;</span>);</span><br><span class="line">		vTaskDelay(pdMS_TO_TICKS(<span class="number">2000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头文件<code>nvs_flash.h</code>是对系统组件的引用，<code>shell_port.h</code>是对自定义组件的引用。</p>
<h4 id="letter-shell组件"><a href="#letter-shell组件" class="headerlink" title="letter_shell组件"></a>letter_shell组件</h4><p><strong>CMakeLists.txt</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">idf_component_register(</span><br><span class="line">	SRCS &quot;shell.c&quot;</span><br><span class="line">		&quot;shell_ext.c&quot;</span><br><span class="line">		&quot;log.c&quot;</span><br><span class="line">		&quot;shell_port.c&quot;</span><br><span class="line">	INCLUDE_DIRS &quot;include&quot;</span><br><span class="line">	LDFRAGMENTS &quot;shell.lf&quot;</span><br><span class="line">	REQUIRES driver</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><p>1、<strong>PRIV_REQUIRES</strong><br>该参数指定对其它自定义组件的依赖，即私有依赖项。</p>
<p><code>PRIV_REQUIRES led</code>表示指出在<code>smart_config</code>组件中要用到自定义的<code>led</code>组件。组件名字可以加引号，也可以不加。多个组件用空格分开。</p>
<p>2、 <strong>REQUIRES</strong><br>该参数指定对系统组件的依赖，即公共依赖项。</p>
<p><code>REQUIRES esp_driver_uart</code> 表示在<code>letter_shell</code>组件中要用到系统组件<code>esp_driver_uart</code>。</p>
<p>3、系统组件的确定</p>
<p>对于要依赖的系统组件不像私有依赖项那样一目了然，有时我们并不清楚所要的系统组件名称。比如我们不知道需要组件wpa_supplicant，这时我们可以先编译一次，看看错误信息：</p>
<p><img src="/../pictures/requires_error.png" alt="requires_error"></p>
<p>在<code>CMakeLists.txt</code>中添加依赖组件<code>REQUIRES esp_driver_uart</code>，编译通过。</p>
<h4 id="关于CMakeLists-txt文件"><a href="#关于CMakeLists-txt文件" class="headerlink" title="关于CMakeLists.txt文件"></a>关于CMakeLists.txt文件</h4><p>根和每个目录都有一个<code>CMakeLists.txt</code>文件，开始遇到的问题是不知道目录结构和怎样写<code>CMakeLists.txt</code>文件，要注意每一层目录中<code>CMakeLists.txt</code>文件的写法，本文的例子给出了一个简单的示范。对于复杂的项目还需要更多编写<code>CMakeLists.txt</code>文件的知识，请看简介中给出的官方文档。</p>
<br>

<h2 id="ESP32移植Letter-shell问题"><a href="#ESP32移植Letter-shell问题" class="headerlink" title="ESP32移植Letter_shell问题"></a>ESP32移植Letter_shell问题</h2><h3 id="添加shell组件及其log，编译出错"><a href="#添加shell组件及其log，编译出错" class="headerlink" title="添加shell组件及其log，编译出错"></a>添加shell组件及其log，编译出错</h3><h4 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因:"></a>可能原因:</h4><ol>
<li><p>宏使用不正确: 如果 <code>SHELL_FREE</code> 旨在实际释放与 <code>companions</code> 对象关联的内存或资源，则当前定义不正确。它应该调用内存管理函数或执行其他必要的清理任务。</p>
</li>
<li><p>编译器警告被视为错误: <code>-Werror=unused-value</code> 标志已启用，它将警告视为错误。即使宏使用本身可能不是关键问题，这也可能导致编译失败。</p>
</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><h5 id="修复-SHELL-FREE-定义"><a href="#修复-SHELL-FREE-定义" class="headerlink" title="修复 SHELL_FREE 定义:"></a>修复 SHELL_FREE 定义:</h5><ol>
<li>如果 <code>companions</code> 需要内存分配，请更新 <code>shell_cfg.h</code> 中的 SHELL_FREE 宏以调用适当的内存管理函数，例如 <code>free()</code>。</li>
<li>如果 <code>companions</code> 不需要内存管理，请从 <code>shell_companion.c</code> 中的第 57 行删除 <code>SHELL_FREE</code> 调用；或者将<code>shell_cfg.h</code> 中的第 36 行 <code>SHELL_USING_COMPANION</code> 的宏定义改为 0。</li>
</ol>
<h5 id="禁用-Werror-unused-value-如果适用"><a href="#禁用-Werror-unused-value-如果适用" class="headerlink" title="禁用 -Werror&#x3D;unused-value (如果适用):"></a>禁用 -Werror&#x3D;unused-value (如果适用):</h5><p>如果您希望将未使用的值警告视为警告而不是错误，您可以暂时在编译期间禁用 <code>-Werror=unused-value</code> 标志。但是，通常建议修复底层问题以避免潜在的内存泄漏或资源管理问题。</p>
<h5 id="其他提示"><a href="#其他提示" class="headerlink" title="其他提示:"></a>其他提示:</h5><ol>
<li>提供有关您的项目更多信息，例如具体的 ESP-IDF 版本、涉及的组件以及 <code>SHELL_FREE</code> 宏的用途。这将有助于了解根本原因并提供更定制的指导。</li>
<li>分享 <code>shell_cfg.h</code> 头文件和 <code>shell_companion.c</code> 文件的相关部分，以便分析代码结构和上下文。<br>考虑使用调试器逐步执行代码并检查 <code>companions</code> 在 <code>SHELL_FREE</code> 调用之前和之后的 值，以了解其使用情况和潜在的内存管理问题。</li>
<li>通过遵循这些步骤并提供更多信息，我可以帮助您有效地解决编译错误并确保您的 ESP-IDF 项目成功构建。</li>
</ol>
<h4 id="配置shell优先级"><a href="#配置shell优先级" class="headerlink" title="配置shell优先级"></a>配置shell优先级</h4><p>将shell的freertos优先级设置为 <code>tskIDLE_PRIORITY</code>，为<code>0</code>级，跟空闲函数优先级一样，所有其他优先级任务执行完后才会执行 <code>tskIDLE_PRIORITY</code>优先级任务。</p>
<h4 id="源代码例程"><a href="#源代码例程" class="headerlink" title="源代码例程"></a>源代码例程</h4><p><a href="https://github.com/XUAN9527/components_demo">ESP32移植letter_shell组件例程</a></p>
<br>

<h2 id="ESP32启动流程解析"><a href="#ESP32启动流程解析" class="headerlink" title="ESP32启动流程解析"></a>ESP32启动流程解析</h2><br>

<h2 id="ESP32-IDF组件下载安装路径"><a href="#ESP32-IDF组件下载安装路径" class="headerlink" title="ESP32-IDF组件下载安装路径"></a>ESP32-IDF组件下载安装路径</h2><ul>
<li><p>安装所需组件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/esp/esp-adf/esp-idf</span><br><span class="line">./install.sh esp32,esp32s3 # 可按需求安装</span><br></pre></td></tr></table></figure>
</li>
<li><p>若下载很慢，可按以下路径在<code>Windows</code>&#x2F;<code>Linux</code>下载:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/esp/esp-adf/esp-idf/tools</span><br><span class="line">vim tools.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tools&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;description&quot;: &quot;GDB for Xtensa&quot;,</span><br><span class="line">      &quot;export_paths&quot;: [</span><br><span class="line">        [</span><br><span class="line">          &quot;xtensa-esp-elf-gdb&quot;,</span><br><span class="line">          &quot;bin&quot;</span><br><span class="line">        ]</span><br><span class="line">      ],</span><br><span class="line">      &quot;export_vars&quot;: &#123;&#125;,</span><br><span class="line">      &quot;info_url&quot;: &quot;https://github.com/espressif/binutils-gdb&quot;,</span><br><span class="line">      &quot;install&quot;: &quot;always&quot;,</span><br><span class="line">      &quot;license&quot;: &quot;GPL-3.0-or-later&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;xtensa-esp-elf-gdb&quot;,</span><br><span class="line">      &quot;supported_targets&quot;: [</span><br><span class="line">        &quot;esp32&quot;,</span><br><span class="line">        &quot;esp32s2&quot;,</span><br><span class="line">        &quot;esp32s3&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;version_cmd&quot;: [</span><br><span class="line">        &quot;xtensa-esp-elf-gdb-no-python&quot;,</span><br><span class="line">        &quot;--version&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;version_regex&quot;: &quot;GNU gdb \\(esp-gdb\\) ([a-z0-9.-_]+)&quot;,</span><br><span class="line">      &quot;versions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;linux-amd64&quot;: &#123;</span><br><span class="line">            &quot;sha256&quot;: &quot;b5f7cc3e4b5a58db655754083ed9652e4953e71c3b4922fb624e7a034ec24a64&quot;,</span><br><span class="line">            &quot;size&quot;: 26947336,</span><br><span class="line">            &quot;url&quot;: &quot;https://github.com/espressif/binutils-gdb/releases/download/esp-gdb-v11.2_20220823/xtensa-esp-elf-gdb-11.2_20220823-x86_64-linux-gnu.tar.gz&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;linux-arm64&quot;: &#123;</span><br><span class="line">            &quot;sha256&quot;: &quot;816acfae38b6b443f4f1590395f68f079243539259d19c7772ae6416c6519444&quot;,</span><br><span class="line">            &quot;size&quot;: 27134508,</span><br><span class="line">            &quot;url&quot;: &quot;https://github.com/espressif/binutils-gdb/releases/download/esp-gdb-v11.2_20220823/xtensa-esp-elf-gdb-11.2_20220823-aarch64-linux-gnu.tar.gz&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;linux-armel&quot;: &#123;</span><br><span class="line">            &quot;sha256&quot;: &quot;4dd1bace0633196fddfdcef3cebcc4bbfce22f5a0d2d1e3d618f3d8a6cbfcacc&quot;,</span><br><span class="line">            &quot;size&quot;: 25205239,</span><br><span class="line">            &quot;url&quot;: &quot;https://github.com/espressif/binutils-gdb/releases/download/esp-gdb-v11.2_20220823/xtensa-esp-elf-gdb-11.2_20220823-arm-linux-gnueabi.tar.gz&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;linux-armhf&quot;: &#123;</span><br><span class="line">            &quot;sha256&quot;: &quot;53a142b9a508a8babe6b7edf3090bb49e3714380ba819b54052425fcf1ac6f9c&quot;,</span><br><span class="line">            &quot;size&quot;: 23491575,</span><br><span class="line">            &quot;url&quot;: &quot;https://github.com/espressif/binutils-gdb/releases/download/esp-gdb-v11.2_20220823/xtensa-esp-elf-gdb-11.2_20220823-arm-linux-gnueabihf.tar.gz&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ESP32解决方案</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32开发环境搭建</title>
    <url>/2024/02/19/ESP32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p><a href="https://espressif-docs.readthedocs-hosted.com/projects/esp-adf/zh-cn/latest/get-started/index.html#quick-start">ESP-ADF快速上手连接</a><br><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32/get-started/linux-macos-setup.html#get-started-linux-macos-first-steps">ESP-IDF快速上手连接</a></p>
<h3 id="获取ESP-ADF"><a href="#获取ESP-ADF" class="headerlink" title="获取ESP-ADF"></a>获取ESP-ADF</h3><p>打开Linux or macOS终端,新建搭建环境所需文件夹。</p>
<pre><code>mkdir ~/esp
cd ~/esp
</code></pre>
<p>编译 ESP-IDF 需要以下软件包。请根据使用的 Linux 发行版本，选择合适的安装：<br>Ubuntu 和 Debian:</p>
<pre><code>sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0
</code></pre>
<p>CentOS 7 &amp; 8:</p>
<pre><code>sudo yum -y update &amp;&amp; sudo yum install git wget flex bison gperf python3 python3-setuptools cmake ninja-build ccache dfu-util libusbx
</code></pre>
<p>Arch:</p>
<pre><code>sudo pacman -S --needed gcc git make flex bison gperf python cmake ninja ccache dfu-util libusb
</code></pre>
<p>克隆最新版ESP-ADF：</p>
<pre><code>git clone --recursive https://github.com/espressif/esp-adf.git
</code></pre>
<p>若克隆失败，尝试以下指令：</p>
<pre><code>git clone --recursive git@github.com:espressif/esp-adf.git
</code></pre>
<p>若子模块拉取失败，尝试手动逐个拉取子模块：</p>
<pre><code>cd ~/esp/esp-adf/components
git clone git@github.com:espressif/esp-adf-libs.git 
或者
git clone https://github.com/espressif/esp-adf-libs.git

cd ~/esp/esp-adf/components
git clone git@github.com:espressif/esp-sr.git
或者
git clone https://github.com/espressif/esp-sr.git

cd ~/esp/esp-adf
git clone git@github.com:espressif/esp-idf.git
或者
git clone https://github.com/espressif/esp-idf.git
</code></pre>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>按自己实际路径，可按自己喜好设置，也可不配置，手动敲指令也可。</p>
<p><code>vi ~/.bashrc</code><br>在后面加上以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启ESP32编译环境</span></span><br><span class="line"><span class="built_in">alias</span> get-idf=<span class="string">&#x27;. $HOME/esp/esp-adf/esp-idf/export.sh&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> get-adf=<span class="string">&#x27;. $HOME/esp/esp-adf/export.sh&#x27;</span></span><br><span class="line"><span class="comment">#打开本地文件夹（wsl）</span></span><br><span class="line"><span class="built_in">alias</span> open-file=<span class="string">&#x27;explorer.exe .&#x27;</span></span><br><span class="line"><span class="comment">#烧录到设备，并打开监视器，/dev/ttyS15为USB挂载端口，需测试后填写，115200为监视器波特率，与设备UART0波特率对应</span></span><br><span class="line"><span class="built_in">alias</span> esp-download=<span class="string">&#x27;idf.py -p /dev/ttyS15 -b 115200 flash monitor&#x27;</span></span><br><span class="line"><span class="built_in">export</span> PATH=/home/qx_song/esp/esp-adf/esp-idf/tools:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> IDF_PATH=/home/qx_song/esp/esp-adf/esp-idf</span><br><span class="line"><span class="built_in">export</span> ADF_PATH=/home/qx_song/esp/esp-adf</span><br></pre></td></tr></table></figure>
<p>保存退出 <code>:wq</code></p>
<h3 id="设置工具"><a href="#设置工具" class="headerlink" title="设置工具"></a>设置工具</h3><p>除了 ESP-IDF 本身，还需要为支持 ESP32 的项目安装 ESP-IDF 使用的各种工具，比如编译器、调试器、Python 包等。</p>
<pre><code>cd ~/esp/esp-adf/esp-idf
</code></pre>
<p>安装esp32，esp32s2工具，运行以下指令：（按需求安装）</p>
<pre><code>./install.sh esp32,esp32s2
</code></pre>
<p>若需要安装所有工具，运行以下指令：</p>
<pre><code>./install.sh all
</code></pre>
<p>以下为ESP-IDF编译所需环境，请在需要运行ESP-IDF的终端窗口运行以下命令：</p>
<pre><code>. $HOME/esp/esp-adf/esp-idf/export.sh   
</code></pre>
<p>或者使用快捷指令：</p>
<pre><code>get-idf
</code></pre>
<br>

<h2 id="ESP32工程示例"><a href="#ESP32工程示例" class="headerlink" title="ESP32工程示例"></a>ESP32工程示例</h2><h3 id="开始创建工程"><a href="#开始创建工程" class="headerlink" title="开始创建工程"></a>开始创建工程</h3><p>现在，可以准备开发 ESP32 应用程序了。<br>从 ESP-IDF 中 examples 目录下的 <code>get-started/hello_world</code> 工程开始，将 <code>get-started/hello_world</code> 工程复制至本地的 ~&#x2F;esp 目录下：</p>
<pre><code>cd ~/esp
get-idf
cp -r $IDF_PATH/examples/get-started/hello_world .
</code></pre>
<br>

<h3 id="配置工程"><a href="#配置工程" class="headerlink" title="配置工程"></a>配置工程</h3><pre><code>cd ~/esp/hello_world
idf.py set-target esp32
</code></pre>
<p>由于ESP32是单核，默认配置是双核模式，需要配置参数：</p>
<pre><code>idf.py menuconfig
Component config -&gt; FreeRTOS -&gt;  [*]Run FreeRTOS only on first core
</code></pre>
<p>保存退出</p>
<h3 id="编译工程"><a href="#编译工程" class="headerlink" title="编译工程"></a>编译工程</h3><pre><code>idf.py build
</code></pre>
<h3 id="烧录工程"><a href="#烧录工程" class="headerlink" title="烧录工程"></a>烧录工程</h3><pre><code>idf.py -p PORT flash
</code></pre>
<p>请将 PORT 替换为 ESP32 开发板的串口名称。如果 PORT 未经定义，<code>idf.py</code> 将尝试使用可用的串口自动连接。</p>
<h3 id="合并执行构建、烧录和监视过程："><a href="#合并执行构建、烧录和监视过程：" class="headerlink" title="合并执行构建、烧录和监视过程："></a>合并执行构建、烧录和监视过程：</h3><pre><code>idf.py -p PORT [-b BAUD] flash monitor
退出 monitor: Ctrl + ]
</code></pre>
<p>注：[-b BAUD] 和 monitor 配合使用，BAUD为程序中UART0的波特率	</p>
<pre><code>idf.py -p /dev/ttyS15 -b  115200  flash monitor	
idf.py -p [挂载端口]   -b [波特率] flash monitor
</code></pre>
<h3 id="擦除flash"><a href="#擦除flash" class="headerlink" title="擦除flash"></a>擦除flash</h3><pre><code>idf.py -p PORT erase-flash
</code></pre>
<p>若存在需要擦除的 OTA 数据，请运行以下命令：</p>
<pre><code>idf.py -p PORT erase-otadata
</code></pre>
<h3 id="挂载端口"><a href="#挂载端口" class="headerlink" title="挂载端口"></a>挂载端口</h3><h4 id="windows-子系统-wsl"><a href="#windows-子系统-wsl" class="headerlink" title="windows 子系统 wsl"></a>windows 子系统 wsl</h4><p>输入烧录指令：</p>
<pre><code>idf.py flash
</code></pre>
<p>观察终端设备是挂载在哪个端口上，有ERROR忽略，选择端口例如 <code>/dev/ttyS15</code>，程序中<code>UART0</code>的波特率115200，下次就可以直接输此端口就可以烧录啦。</p>
<pre><code>idf.py -p /dev/ttyS15 -b 115200 flash monitor	
</code></pre>
<p>如果 ESP-IDF 监视器在烧录后很快发生错误，或打印信息全是乱码（如下），很有可能是因为开发板采用了 26 MHz 晶振，而 ESP-IDF 默认支持大多数开发板使用的 40 MHz 晶振。</p>
<pre><code>x���ff�f�����`�~�~���f���x��f�f�����ff��`���f����`��~x������ff�f�����`�~�~�f����f����f`���x��f�f�����ff��`���f
</code></pre>
<p>此时，可以：<br>1、退出监视器。<br>2、返回 idf.py menuconfig。<br>3、进入 Component config –&gt; Hardware Settings –&gt; Main XTAL Config –&gt; Main XTAL frequency 进行配置，将 CONFIG_XTAL_FREQ_SEL 设置为 26 MHz。<br>4、重新编译和烧录应用程序。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>启动终端ESP32编译只需要进行以下步骤：</p>
<pre><code>. $HOME/esp/esp-adf/esp-idf/export.sh	//开启编译环境
idf.py set-target esp32			//首次搭建项目时配置
idf.py menuconfig   			//选择需要的配置
idf.py build
idf.py flash
</code></pre>
<p>快捷方式：</p>
<pre><code>get-idf
idf.py set-target esp32
idf.py menuconfig
idf.py build
esp-download
</code></pre>
<br>

<h2 id="通过SSH远程访问本地的USB设备"><a href="#通过SSH远程访问本地的USB设备" class="headerlink" title="通过SSH远程访问本地的USB设备"></a>通过SSH远程访问本地的USB设备</h2><h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><h4 id="本地机器配置（以Windows为例）"><a href="#本地机器配置（以Windows为例）" class="headerlink" title="本地机器配置（以Windows为例）"></a>本地机器配置（以Windows为例）</h4><ol>
<li>安装USB&#x2F;IP工具</li>
</ol>
<ul>
<li><p>下载并安装 <code>usbipd-win</code>（<code>Windows</code>的<code>USB/IP</code>服务端）：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">winget install <span class="literal">--interactive</span> dorssel.usbipd<span class="literal">-win</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>插入<code>ESP32</code>开发板，确认设备管理器中出现对应的串口（如 <code>COM3</code> 或 <code>/dev/ttyUSB0</code>）。</p>
</li>
</ul>
<ol start="2">
<li>绑定并共享<code>USB</code>设备</li>
</ol>
<ul>
<li><p>管理员权限打开<code>PowerShell</code>，查看<code>ESP32</code>的总线<code>ID</code>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">usbipd list</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出示例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">BUSID  VID:PID   DEVICE 							STATE</span><br><span class="line"><span class="number">3</span><span class="literal">-1</span>    <span class="number">10</span>c4:ea60  Silicon Labs CP210x USB to UART Bridge (COM17)                Not Shared</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定并共享设备：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">usbipd bind <span class="literal">--busid</span> <span class="number">3</span><span class="literal">-1</span>  <span class="comment"># 替换为实际总线ID</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>配置<code>Windows</code>防火墙</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">New-NetFirewallRule</span> <span class="literal">-DisplayName</span> <span class="string">&quot;USB/IP&quot;</span> <span class="literal">-Direction</span> Inbound <span class="literal">-Action</span> Allow <span class="literal">-Protocol</span> TCP <span class="literal">-LocalPort</span> <span class="number">3240</span> <span class="comment"># 关闭防火墙</span></span><br><span class="line">或者：</span><br><span class="line"><span class="built_in">Set-NetFirewallProfile</span> <span class="literal">-Profile</span> Domain,Public,Private <span class="literal">-Enabled</span> False <span class="comment"># 临时关闭防火墙测试</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确保<code>USB/IP</code>服务已启动</li>
</ol>
<ul>
<li>如果服务未启动，手动启动：<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">usbipd server	<span class="comment"># 需要保持powershell</span></span><br></pre></td></tr></table></figure></li>
<li>验证服务是否启动:<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">usbipd list</span><br></pre></td></tr></table></figure></li>
<li>如果输出设备列表（如<code>ESP32</code>），说明服务已成功启动。</li>
</ul>
<ol start="5">
<li>检查端口监听</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">netstat <span class="literal">-ano</span> | findstr :<span class="number">3240</span></span><br></pre></td></tr></table></figure>

<ul>
<li>正常应输出类似以下内容：<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">TCP    <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">3240</span>           <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">0</span>              LISTENING</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li>获取本机<code>ip</code></li>
</ol>
<ul>
<li><code>powershell</code>输入<code>ipconfig</code>指令获取本机<code>ip</code>:<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Ethernet adapter 以太网:</span><br><span class="line"></span><br><span class="line">   Connection<span class="literal">-specific</span> DNS Suffix  . : breo.vip</span><br><span class="line">   Link<span class="literal">-local</span> IPv6 Address . . . . . : fe80::a2cf:<span class="number">7</span>a4:df39:<span class="number">7032</span>%<span class="number">7</span></span><br><span class="line">   IPv4 Address. . . . . . . . . . . : <span class="number">192.168</span>.<span class="number">104.29</span> <span class="comment"># 获取此IP</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="远程Ubuntu服务器配置"><a href="#远程Ubuntu服务器配置" class="headerlink" title="远程Ubuntu服务器配置"></a>远程Ubuntu服务器配置</h4><ol>
<li>安装<code>USB/IP</code>客户端工具</li>
</ol>
<ul>
<li><p>安装USB&#x2F;IP客户端工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install linux-tools-generic hwdata</span><br><span class="line">sudo update-alternatives --install /usr/local/bin/usbip usbip /usr/lib/linux-tools/*-generic/usbip 20</span><br></pre></td></tr></table></figure>
</li>
<li><p>若不兼容，安装与内核<code>5.15.0-126</code>兼容的<code>usbipd</code>工具及性能调试工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install linux-tools-5.15.0-126-generic linux-cloud-tools-5.15.0-126-generic</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证安装：安装后检查 <code>usbipd</code> 是否存在:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which usbipd   # 输出路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>为避免未来内核升级后再次出现版本不兼容问题，安装通用工具包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install linux-tools-generic linux-cloud-tools-generic</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>附加远程<code>USB</code>设备</li>
</ol>
<ul>
<li>在<code>Ubuntu</code>服务器执行（需与本地网络互通）：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo modprobe usbip-core</span><br><span class="line">sudo modprobe vhci-hcd</span><br><span class="line">sudo usbip attach -r &lt;本地机器IP&gt; -b &lt;总线ID&gt; # 替换为实际IP和总线ID</span><br></pre></td></tr></table></figure></li>
<li>验证设备是否挂载成功：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /dev/tty*  # 应出现类似/dev/ttyUSB0的设备节点</span><br><span class="line">dmesg | tail  # 查看内核日志确认设备识别</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>配置设备权限<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG dialout $USER  # 将用户加入串口组,需注销重新登录</span><br><span class="line">sudo chmod a+rw /dev/ttyUSB0    # 临时权限（可选）</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="修改ubuntu环境变量"><a href="#修改ubuntu环境变量" class="headerlink" title="修改ubuntu环境变量"></a>修改ubuntu环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>添加以下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启ESP32编译环境</span></span><br><span class="line">alias get-idf=&#x27;. $HOME/esp/esp-adf/esp-idf/export.sh&#x27;</span><br><span class="line">alias get-adf=&#x27;. $HOME/esp/esp-adf/export.sh&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">烧录到设备，并打开监视器，/dev/ttyUSB0为USB挂载端口，需测试后填写，115200为监视器波特率，与设备UART0波特率对应</span></span><br><span class="line">alias esp-u0=&#x27;idf.py -p /dev/ttyUSB0 -b 115200 flash monitor&#x27;</span><br><span class="line">alias esp-u1=&#x27;idf.py -p /dev/ttyUSB1 -b 115200 flash monitor&#x27;</span><br><span class="line">alias esp-normal=&#x27;sudo usbip attach -r 192.168.104.29 -b 3-1&#x27;</span><br><span class="line">alias esp-s3=&#x27;sudo usbip attach -r 192.168.104.29 -b 1-3&#x27;</span><br><span class="line">export PATH=/home/ubuntu/esp/esp-adf/esp-idf/tools:$PATH</span><br><span class="line">export IDF_PATH=/home/ubuntu/esp/esp-adf/esp-idf</span><br><span class="line">export ADF_PATH=/home/ubuntu/esp/esp-adf</span><br></pre></td></tr></table></figure>

<ul>
<li>释放<code>USB</code>口:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@compilation:~/esp/spi_lcd_touch$ lsof /dev/ttyUSB0</span><br><span class="line">COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">python  85630 ubuntu    3uW  CHR  188,0      0t0  730 /dev/ttyUSB0</span><br><span class="line">ubuntu@compilation:~/esp/spi_lcd_touch$ sudo kill -9 85630 </span><br></pre></td></tr></table></figure>

<h4 id="烧录步骤跟上文-WSL-环境一样"><a href="#烧录步骤跟上文-WSL-环境一样" class="headerlink" title="烧录步骤跟上文 WSL 环境一样"></a>烧录步骤跟上文 WSL 环境一样</h4><h4 id="断开设备连接"><a href="#断开设备连接" class="headerlink" title="断开设备连接"></a>断开设备连接</h4><ol>
<li>本地释放设备（<code>Windows</code>端）</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">usbipd unbind <span class="literal">--busid</span> &lt;总线ID&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>卸载<code>USB</code>设备</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sudo usbip detach <span class="literal">--port</span>=<span class="number">00</span>  <span class="comment"># 查看端口号：sudo usbip port</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>环境搭建</category>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C调试记录</title>
    <url>/2024/03/01/I2C%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="I2C基本原理介绍"><a href="#I2C基本原理介绍" class="headerlink" title="I2C基本原理介绍"></a>I2C基本原理介绍</h2><h3 id="时序介绍"><a href="#时序介绍" class="headerlink" title="时序介绍"></a>时序介绍</h3><p>参考Vishay的i2c时序图：</p>
<p><img src="/../pictures/i2c%E6%97%B6%E5%BA%8F%E5%9B%BE1.png" alt="i2c时序图1"><br><img src="/../pictures/i2c%E6%97%B6%E5%BA%8F%E5%9B%BE2.png" alt="i2c时序图2"></p>
<h3 id="代码实现详解"><a href="#代码实现详解" class="headerlink" title="代码实现详解"></a>代码实现详解</h3><p><code>I2C</code>协议实现有硬件<code>I2C</code>和软件<code>I2C</code>之分，这里只讲解软件<code>I2C</code>实现的版本。一下列出主要结构体和初始化函数。</p>
<h4 id="I2C协议初始化"><a href="#I2C协议初始化" class="headerlink" title="I2C协议初始化"></a>I2C协议初始化</h4><p><code>I2C</code>协议的<code>scl</code>和<code>sda</code>配置为开漏输出,需要外部上拉（一般为<code>10K</code>电阻）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define i2c_pin_mode(pin,mode)		drv_pin_mode(pin,mode)</span></span><br><span class="line"><span class="comment">#define i2c_pin_write(pin,level) 	drv_pin_write(pin,level)</span></span><br><span class="line"><span class="comment">#define i2c_pin_read(pin) 		drv_pin_read(pin)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DRV_I2C_WR                      0x00</span></span><br><span class="line"><span class="comment">#define DRV_I2C_RD                      (1u &lt;&lt; 0)</span></span><br><span class="line"><span class="comment">#define DRV_I2C_ADDR_10BIT              (1u &lt;&lt; 2)  /* this is a ten bit chip address */</span></span><br><span class="line"><span class="comment">#define DRV_I2C_NO_START                (1u &lt;&lt; 4)</span></span><br><span class="line"><span class="comment">#define DRV_I2C_IGNORE_NACK             (1u &lt;&lt; 5)</span></span><br><span class="line"><span class="comment">#define DRV_I2C_NO_READ_ACK             (1u &lt;&lt; 6)  /* when I2C reading, we do not ACK */</span></span><br><span class="line"><span class="comment">#define DRV_I2C_NO_STOP                 (1u &lt;&lt; 7)</span></span><br><span class="line"></span><br><span class="line">typedef enum&#123;</span><br><span class="line">	EI2C_DEV_1 = 1,</span><br><span class="line">	EI2C_DEV_2,</span><br><span class="line">	EI2C_DEV_3</span><br><span class="line">&#125;EI2C_DEVICE;</span><br><span class="line"></span><br><span class="line">struct drv_soft_i2c_config</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t scl;</span><br><span class="line">	uint8_t sda;</span><br><span class="line">	uint8_t i2c_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct drv_i2c_msg</span><br><span class="line">&#123;</span><br><span class="line">    uint16_t addr;</span><br><span class="line">    uint16_t flags;</span><br><span class="line">    uint16_t len;</span><br><span class="line">	uint8_t reg_addr;</span><br><span class="line">    uint8_t  *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct drv_i2c_bit_ops</span><br><span class="line">&#123;</span><br><span class="line">    void *data;            /* private data <span class="keyword">for</span> lowlevel routines */</span><br><span class="line">    void (*set_sda)(void *data, int state);</span><br><span class="line">    void (*set_scl)(void *data, int state);</span><br><span class="line">    int (*get_sda)(void *data);</span><br><span class="line">    int (*get_scl)(void *data);</span><br><span class="line"></span><br><span class="line">    void (*udelay)(uint32_t us);</span><br><span class="line"></span><br><span class="line">    uint32_t delay_us;  /* scl and sda line delay */</span><br><span class="line">    uint32_t <span class="built_in">timeout</span>;   /* <span class="keyword">in</span> tick */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct drv_i2c_bus_device</span><br><span class="line">&#123;</span><br><span class="line">	struct drv_i2c_msg msg;</span><br><span class="line">	struct drv_i2c_bit_ops ops;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void drv_i2c_gpio_init(struct drv_soft_i2c_config *i2c)</span><br><span class="line">&#123;</span><br><span class="line">    struct drv_soft_i2c_config* cfg = i2c;</span><br><span class="line"></span><br><span class="line">    i2c_pin_mode(cfg-&gt;scl, I2C_PIN_MODE_OUTPUT_OD);	//PIN_MODE_OUTPUT</span><br><span class="line">    i2c_pin_mode(cfg-&gt;sda, I2C_PIN_MODE_OUTPUT_OD);</span><br><span class="line"></span><br><span class="line">    i2c_pin_write(cfg-&gt;scl, I2C_PIN_HIGH);</span><br><span class="line">    i2c_pin_write(cfg-&gt;sda, I2C_PIN_HIGH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int drv_hw_i2c_init(EI2C_DEVICE dev_e)</span><br><span class="line">&#123;</span><br><span class="line">	int size = sizeof(i2c_pin_config)/sizeof(struct drv_soft_i2c_config);</span><br><span class="line">	struct drv_i2c_bus_device *dev = get_i2c_device(dev_e);</span><br><span class="line">	uint8_t dev_num = (uint8_t)dev_e;</span><br><span class="line">	struct drv_soft_i2c_config *pin_cfg = NULL;</span><br><span class="line">	struct drv_i2c_bit_ops *ops = &amp;dev-&gt;ops;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;size;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i2c_pin_config[i].i2c_num == dev_num)</span><br><span class="line">		&#123;</span><br><span class="line">			pin_cfg = (struct drv_soft_i2c_config *)&amp;i2c_pin_config[i];</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pin_cfg == NULL)</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">    ops-&gt;data  = (void*)pin_cfg;</span><br><span class="line">    ops-&gt;set_sda  = n32_set_sda;</span><br><span class="line">    ops-&gt;set_scl  = n32_set_scl;</span><br><span class="line">    ops-&gt;get_sda  = n32_get_sda;</span><br><span class="line">    ops-&gt;get_scl  = n32_get_scl;</span><br><span class="line">    ops-&gt;udelay   = n32_udelay;</span><br><span class="line">    ops-&gt;delay_us = 1;</span><br><span class="line">    ops-&gt;<span class="built_in">timeout</span>  = 5;</span><br><span class="line">    </span><br><span class="line">    drv_i2c_gpio_init(pin_cfg);</span><br><span class="line">    drv_i2c_bus_unlock(pin_cfg);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int drv_i2c_bit_xfer(struct drv_i2c_bit_ops *bus,</span><br><span class="line">                 struct drv_i2c_msg msgs[],</span><br><span class="line">                 uint32_t num);</span><br><span class="line">struct drv_i2c_bus_device *get_i2c_device(EI2C_DEVICE dev_e);</span><br><span class="line">static uint64_t i2c_tick_get(void);</span><br><span class="line">int drv_hw_i2c_init(EI2C_DEVICE dev_e);</span><br><span class="line">int drv_i2c_send_data(EI2C_DEVICE dev_e,uint16_t addr,uint8_t reg_addr,uint8_t *buf,uint16_t len);</span><br><span class="line">int drv_i2c_recv_data(EI2C_DEVICE dev_e,uint16_t addr,uint8_t reg_addr,uint8_t *buf,uint16_t len);</span><br></pre></td></tr></table></figure>

<h2 id="实战开发问题分析"><a href="#实战开发问题分析" class="headerlink" title="实战开发问题分析"></a>实战开发问题分析</h2><p>实际开发过程中，同样的<code>I2C</code>驱动程序，在不同厂家芯片的使用上出现一些问题，导致部分厂家通信异常，导致数据接收不正确，以下进行分析对比，作证并解决问题。</p>
<h3 id="Vishay-和-亿光-接近传感器模块对比"><a href="#Vishay-和-亿光-接近传感器模块对比" class="headerlink" title="Vishay 和 亿光 接近传感器模块对比"></a>Vishay 和 亿光 接近传感器模块对比</h3><p><code>Vishay</code>使用<code>VCNL3682S</code>型号芯片，亿光使用<code>APM-16D24-U6E</code>型号芯片，<code>I2C</code>协议对比。</p>
<h5 id="Vishay-："><a href="#Vishay-：" class="headerlink" title="Vishay ："></a>Vishay ：</h5><p><img src="/../pictures/Vishay%E5%86%99i2c%E5%8D%8F%E8%AE%AE.png" alt="Vishay写i2c协议"><br><img src="/../pictures/Vishay%E8%AF%BBi2c%E5%8D%8F%E8%AE%AE.png" alt="Vishay读i2c协议"></p>
<h5 id="亿光："><a href="#亿光：" class="headerlink" title="亿光："></a>亿光：</h5><p><img src="/../pictures/%E4%BA%BF%E5%85%89i2c%E5%8D%8F%E8%AE%AE.png" alt="亿光i2c协议"></p>
<h6 id="对比波形"><a href="#对比波形" class="headerlink" title="对比波形"></a>对比波形</h6><p>对比协议来看基本上是一致的，用<code>JI2C</code>工具测的<code>i2c</code>波形也基本上一致，但是我自己写的软件<code>i2c</code>驱动，<code>Vishay</code>可以正常使用，亿光读取的数据就有问题，用逻辑分析仪抓一波波形分析一下。</p>
<p>发现每次读完都会多恢复一个<code>ack</code>，而协议上读完最后一个字节需要恢复<code>nack</code>。</p>
<h6 id="修改了以下代码"><a href="#修改了以下代码" class="headerlink" title="修改了以下代码"></a>修改了以下代码</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int i2c_send_ack_or_nack(struct drv_i2c_bit_ops *bus, int ack)</span><br><span class="line">&#123;</span><br><span class="line">    struct drv_i2c_bit_ops *ops = bus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ack)				// <span class="keyword">if</span>(ack &gt;= 0) 改成 <span class="keyword">if</span>(ack)</span><br><span class="line">        SET_SDA(ops, 0);</span><br><span class="line">    i2c_delay(ops);</span><br><span class="line">    <span class="keyword">if</span> (SCL_H(ops) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">//        logVerbose(<span class="string">&quot;ACK or NACK timeout.&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> -2;</span><br><span class="line">    &#125;</span><br><span class="line">    SCL_L(ops);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>static int i2c_send_ack_or_nack(struct drv_i2c_bit_ops *bus, int ack)&#123;&#125;</code><br>函数主要处理响应回复。</p>
<pre><code>if(ack &gt;= 0)表示每次都会回复ack/nack
if(ack)表示除最后一次数据不回复，其他每次都会回复ack/nack
</code></pre>
<br>
]]></content>
      <categories>
        <category>硬件调试</category>
      </categories>
      <tags>
        <tag>逻辑分析仪</tag>
        <tag>接近传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机开发问题汇总</title>
    <url>/2024/01/31/MCU%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="内核复位（kernel-reset）"><a href="#内核复位（kernel-reset）" class="headerlink" title="内核复位（kernel reset）"></a>内核复位（kernel reset）</h2><h3 id="常见通用问题"><a href="#常见通用问题" class="headerlink" title="常见通用问题"></a>常见通用问题</h3><ul>
<li><strong>内核复位代码，如ADC：</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kernel_reset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __DSB();</span><br><span class="line">    __disable_irq();							<span class="comment">//close irq</span></span><br><span class="line">	drv_adc_deinit(EADC_DEV1,EDMA_CH6);			<span class="comment">//disable adc data</span></span><br><span class="line">    SCB-&gt;AIRCR = ((<span class="number">0x5FA</span> &lt;&lt; SCB_AIRCR_VECTKEY_Pos)      |</span><br><span class="line">                  (SCB-&gt;AIRCR &amp; SCB_AIRCR_PRIGROUP_Msk) |</span><br><span class="line">                   SCB_AIRCR_VECTRESET_Msk);</span><br><span class="line">    __DSB();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>板级初始化前先要重置状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DMA_DeInit(dma_chx);		<span class="comment">//DMA开启循环接收后会持续接收字节</span></span><br><span class="line">ADC_DeInit(adc_handler);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ADC</code>驱动初始化&#x2F;反初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">drv_adc_init</span><span class="params">(EADC_DEVICE adc_dev,EDMA_CHANNEL dma_ch)</span></span><br><span class="line">&#123;</span><br><span class="line">	drv_adc_configuration(adc_dev);</span><br><span class="line">	drv_dma_configuration(adc_dev,dma_ch);</span><br><span class="line">	drv_adc_enable(adc_dev,DISABLE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">drv_adc_deinit</span><span class="params">(EADC_DEVICE adc_dev,EDMA_CHANNEL dma_ch)</span></span><br><span class="line">&#123;</span><br><span class="line">	ADC_Module *adc_handler = drv_get_adc_device(adc_dev)-&gt;ADC_Handler;</span><br><span class="line">	DMA_ChannelType * dma_chx = drv_get_dma_channel(dma_ch);</span><br><span class="line">	</span><br><span class="line">	drv_adc_enable(adc_dev,DISABLE);</span><br><span class="line">	DMA_EnableChannel(dma_chx,DISABLE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<h3 id="n32g452rc内核复位问题"><a href="#n32g452rc内核复位问题" class="headerlink" title="n32g452rc内核复位问题"></a>n32g452rc内核复位问题</h3><h4 id="bootloader跳转到app"><a href="#bootloader跳转到app" class="headerlink" title="bootloader跳转到app"></a>bootloader跳转到app</h4><ul>
<li>栈大小改变后跳转成功：将<code>ram</code>空间数据<code>uint16_t</code>改为<code>uint32_t</code>。</li>
<li>堆大小改变后跳转成功：将队列申请长度<code>20</code>改为<code>30</code>。</li>
<li>代码大小变化后跳转失败：<ul>
<li>代码段变长，能跑进<code>system_init</code>,跑飞待查。</li>
<li>代码段变短，不能跑进<code>system_init</code>,跑飞待查。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><code>n32g45x</code>系列栈大小和堆大小影响不大，只要代码段大小不变，跳转成功；若代码段长度变化，跳转失败。（芯片原因？）</li>
<li><code>n32l40x</code>系列不存在此类问题。</li>
</ul>
<br>

<h2 id="MCU复位后状态"><a href="#MCU复位后状态" class="headerlink" title="MCU复位后状态"></a>MCU复位后状态</h2><ul>
<li><p>复位期间和刚复位后，复用功能未开启,<code>I/O</code>端口被配置成模拟功能模式(<code>PCFGy[1:0] = 00b</code>, <code>PMODEy[1:0] = 00b</code>)。</p>
</li>
<li><p>但有以下几个例外的信号：<code>BOOT0</code>、 <code>NRST</code>、 <code>OSC_IN</code>、 <code>OSC_OUT</code> 默认无 <code>GPIO</code> 功能：</p>
<ul>
<li><code>BOOT0</code> 引脚默认输入下拉</li>
<li><code>NRST</code> 上拉输入输出</li>
</ul>
</li>
<li><p>复位后，调试系统相关的引脚默认状态为启动 <code>SWD-JTAG</code>， <code>JTAG</code> 引脚被置于输入上拉或下拉模式：</p>
<ul>
<li><code>PA15</code>：<code>JTDI</code> 置于输入上拉模式 </li>
<li><code>PA14</code>：<code>JTCK</code> 置于输入下拉模式 </li>
<li><code>PA13</code>：<code>JTMS</code> 置于输入上拉模式</li>
<li><code>PB4</code>：<code>NJTRST</code> 置于输入上拉模式</li>
<li><code>PB3</code>：<code>JTD0</code> 置于推挽输出无上下拉</li>
</ul>
</li>
<li><p><code>PD0</code> 和 <code>PD1</code></p>
<ul>
<li><code>PD0</code> 和 <code>PD1</code> 在 <code>80</code> 及以上引脚封装默认为模拟模式</li>
<li><code>PD0</code> 和 <code>PD1</code> 在 <code>80</code> 以下引脚封装复用到 OSC_IN&#x2F;OUT</li>
</ul>
</li>
<li><p><code>PC13</code>、 <code>PC14</code>、 <code>PC15</code>：</p>
<ul>
<li><code>PC13～15</code> 为备电域下的三个<code> IO</code>， 备份域初次上电默认为模拟模式；</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><code>PB2</code>&#x2F;<code>BOOT1</code>：<ul>
<li><code>PB2</code>&#x2F;<code>BOOT1</code> 默认处于下拉输入状态；</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><code>BOOT0</code> 默认输入下拉，参照下表， 若 <code>BOOT</code> 的引脚未连接，则默认选择 <code>Flash</code> 主存储区。</li>
</ul>
<p><img src="/../pictures/mcu%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E8%A1%A8.png" alt="mcu启动选项表"></p>
<br>

<p><strong>问题</strong>：<code>n32g452</code>系列芯片， <code>串口2</code>无法发送数据问题</p>
<ul>
<li>打印测试进入了<code>usart2</code>的串口发送函数，示波器测量，有尖峰异常波形。</li>
</ul>
<p><strong>解决</strong>：<code>串口2</code>引脚为<code>PB4</code>,默认为<code>JTAG</code>引脚，复用时应关闭<code>JTAG</code>功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用jlink引脚复用成GPIO时需要关闭jlink引脚功能，否则无法正常输出。</span></span><br><span class="line">GPIO_ConfigPinRemap(GPIO_RMP_SW_JTAG_SW_ENABLE, ENABLE);</span><br></pre></td></tr></table></figure>

<ul>
<li>时钟引脚使用问题(<code>n32l406</code>为例)，可能不需要复用，以实际为准。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*开启复用的外设时钟使能*/</span></span><br><span class="line"><span class="keyword">if</span>(pin == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">	RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_AFIO,ENABLE);</span><br><span class="line">	GPIO_ConfigPinRemap(GPIOD_PORT_SOURCE,GPIO_PIN_SOURCE14,GPIO_NO_AF);	<span class="comment">/*映射的使能*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pin == <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">	RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_AFIO,ENABLE);</span><br><span class="line">	GPIO_ConfigPinRemap(GPIOD_PORT_SOURCE,GPIO_PIN_SOURCE15,GPIO_NO_AF);	<span class="comment">/*映射的使能*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<h2 id="printf重定向"><a href="#printf重定向" class="headerlink" title="printf重定向"></a>printf重定向</h2><ul>
<li>MDK版本，勾选Use MicroLIB选项：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> is_lr_sent = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE* f)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (ch == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       is_lr_sent = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (!is_lr_sent)</span><br><span class="line">   	&#123;</span><br><span class="line">           USART_SendData(USART1, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">           <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET);</span><br><span class="line">   	&#125;</span><br><span class="line">   	is_lr_sent = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">   	is_lr_sent = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   USART_SendData(USART1, ch);</span><br><span class="line">   <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET);</span><br><span class="line">   <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>GCC版本</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _write(<span class="type">int</span> fd, <span class="type">char</span>* pBuffer, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        USART_SendData(USART1, pBuffer[i]);</span><br><span class="line">        <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="RT-THREAD调试问题"><a href="#RT-THREAD调试问题" class="headerlink" title="RT-THREAD调试问题"></a>RT-THREAD调试问题</h2><h3 id="LETTER-SHELL问题"><a href="#LETTER-SHELL问题" class="headerlink" title="LETTER SHELL问题"></a>LETTER SHELL问题</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SHELL_USING_LOCK设为 1，则需要初始化互斥锁，否则shell会死机。</span></span><br><span class="line"><span class="comment">// LOG_USING_LOCK设为 0，否则log会死机，问题不详。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHELL_USING_LOCK    1       </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_USING_LOCK      0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHELL_USING_LOCK</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">shellMutex</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">userShellLock</span><span class="params">(Shell *sh)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_mutex_take(&amp;shellMutex,RT_WAITING_FOREVER);		<span class="comment">// rt_tick_from_millisecond(100),RT_WAITING_FOREVER</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用户shell解锁</span></span><br><span class="line"><span class="comment"> * @param shell shell</span></span><br><span class="line"><span class="comment"> * @return int 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">userShellUnlock</span><span class="params">(Shell *sh)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_mutex_release(&amp;shellMutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LOG_USING_LOCK</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">logMutex</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">userLogLock</span><span class="params">(Log *<span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_mutex_take(&amp;logMutex, RT_WAITING_FOREVER);		<span class="comment">//rt_tick_from_millisecond(10)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">userLogUnlock</span><span class="params">(Log *<span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_mutex_release(&amp;logMutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">User_Shell_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">serial_configure</span> <span class="title">config</span> =</span> EC_SERIAL_CONFIG_DEFAULT;</span><br><span class="line">    config.baud_rate = BAUD_RATE_921600;</span><br><span class="line">    drv_usart_init(ESERIAL_1, ESERIAL_MODE_DMA_RX | ESERIAL_MODE_DMA_TX, &amp;config);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHELL_USING_LOCK</span></span><br><span class="line">	rt_mutex_init(&amp;shellMutex,<span class="string">&quot;shellMutex&quot;</span>,RT_IPC_FLAG_FIFO);</span><br><span class="line">	shell.unlock = userShellUnlock;</span><br><span class="line">	shell.lock = userShellLock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LOG_USING_LOCK</span></span><br><span class="line">	rt_mutex_init(&amp;logMutex,<span class="string">&quot;logMutex&quot;</span>,RT_IPC_FLAG_FIFO);</span><br><span class="line">	uartLog.unlock = userLogUnlock;</span><br><span class="line">	uartLog.lock = userLogLock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    shell.write = User_Shell_Write;</span><br><span class="line">	shell.read = User_Shell_Read;</span><br><span class="line">    shellInit(&amp;shell, shell_buffer, <span class="keyword">sizeof</span>(shell_buffer));</span><br><span class="line">	logRegister(&amp;uartLog, &amp;shell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="串口通信异常"><a href="#串口通信异常" class="headerlink" title="串口通信异常"></a>串口通信异常</h3><ul>
<li>打开UART7接收为<code>DMA IDLE</code>中断，申请一个超时定时器，发送&#x2F;接受各一个任务，发送&#x2F;接受两个队列,以下是错误信息：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">psr: 0x60000000</span><br><span class="line">r00: 0x00000000</span><br><span class="line">r01: 0x20007978</span><br><span class="line">r02: 0x20007978</span><br><span class="line">r03: 0x00000000</span><br><span class="line">r04: 0x00000000</span><br><span class="line">r05: 0x00000000</span><br><span class="line">r06: 0x00000000</span><br><span class="line">r07: 0x20000920</span><br><span class="line">r08: 0x20005908</span><br><span class="line">r09: 0x20000568</span><br><span class="line">r10: 0xdeadbeef</span><br><span class="line">r11: 0xdeadbeef</span><br><span class="line">r12: 0x00000000</span><br><span class="line"> lr: 0x0801156f</span><br><span class="line"> pc: 0x00000000</span><br><span class="line">hard fault on thread: timer</span><br><span class="line"></span><br><span class="line">E [00:00:07,324] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue) assertion failed at <span class="keyword">function</span>:rt_mq_send_wait, line number:2026 </span><br><span class="line"></span><br><span class="line">E [00:00:00,659] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type(&amp;timer-&gt;parent) == RT_Object_Class_Timer) assertion failed at <span class="keyword">function</span>:rt_timer_control, line number:474 </span><br><span class="line"></span><br><span class="line">E [00:00:39,282] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread) assertion failed at function:rt_thread_resume, line number:<span class="number">760</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>问题定位到指针变量<code>p_srx_mq[0]</code>和<code>&amp;p_srx_mq[0]</code>的区别，代码如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define COMM_MAX_NUM     3</span></span><br><span class="line">static uint8_t *p_srx_mq[COMM_MAX_NUM];</span><br><span class="line">static struct comm_serial_mq srx_mq_data[COMM_MAX_NUM];</span><br><span class="line">static struct rt_timer comm_rx_stimer[COMM_MAX_NUM];</span><br><span class="line"></span><br><span class="line">static void comm_serial_recieve_data_deinit(uint8_t num)</span><br><span class="line">&#123;</span><br><span class="line">	srx_mq_data[num].size = 0;</span><br><span class="line">	p_srx_mq[num] = srx_mq_data[num].data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int usart_key_rx_indicate(ESERIAL_DEV serial_dev, uint16_t size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p_srx_mq[0] - srx_mq_data[0].data + size &gt; sizeof(srx_mq_data[0].data))</span><br><span class="line">	&#123;</span><br><span class="line">		comm_serial_recieve_data_deinit(0);</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	rt_timer_start(&amp;comm_rx_stimer[0]);                   // 启动定时器</span><br><span class="line">	drv_fifo_data_get(serial_dev, (uint8_t *)p_srx_mq[0], size);</span><br><span class="line">	logPrintln(<span class="string">&quot;test = [%p][%p][%p]&quot;</span>,p_srx_mq[0],&amp;p_srx_mq[0],srx_mq_data[0].data);</span><br><span class="line">	p_srx_mq[0] += size;</span><br><span class="line">	srx_mq_data[0].size += size;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FlashDB问题（碰巧对上述问题未遇到问题的解决）"><a href="#FlashDB问题（碰巧对上述问题未遇到问题的解决）" class="headerlink" title="FlashDB问题（碰巧对上述问题未遇到问题的解决）"></a>FlashDB问题（碰巧对上述问题未遇到问题的解决）</h3><ul>
<li><p>上述问题<code>LETTER SHELL</code>问题中<code>SHELL_USING_LOCK</code>设为<code>1</code>，<code>LOG_USING_LOCK</code>需设为<code>0</code>,否则会卡死，经调试后下面会做出解释。</p>
</li>
<li><p>在初始化的时候，不管是<code>KVDB</code>还是<code>TSDB</code>，必须在烧完程序后，<code>reboot</code>一下才能初始化扇区成功，原因待查。</p>
</li>
<li><p>会出现以下打印后卡住：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">admin:/$ tsdb_test</span><br><span class="line">[D/FAL] (fal_flash_init:<span class="number">47</span>) Flash device |               n32_onchip | addr: <span class="number">0x08000000</span> | len: <span class="number">0x00080000</span> | blk_size: <span class="number">0x00000800</span> |initialized finish.</span><br><span class="line">[I/FAL] ==================== FAL partition table ====================</span><br><span class="line">[I/FAL] | name      | flash_dev  |   offset   |    length  |</span><br><span class="line">[I/FAL] -------------------------------------------------------------</span><br><span class="line">[I/FAL] | bl        | n32_onchip | <span class="number">0x00000000</span> | <span class="number">0x00002800</span> |</span><br><span class="line">[I/FAL] | app       | n32_onchip | <span class="number">0x00002800</span> | <span class="number">0x00032000</span> |</span><br><span class="line">[I/FAL] | download  | n32_onchip | <span class="number">0x00034800</span> | <span class="number">0x00032000</span> |</span><br><span class="line">[I/FAL] | upflag    | n32_onchip | <span class="number">0x00066800</span> | <span class="number">0x00000800</span> |</span><br><span class="line">[I/FAL] | dcd       | n32_onchip | <span class="number">0x00067000</span> | <span class="number">0x00000800</span> |</span><br><span class="line">[I/FAL] | mcuinfo   | n32_onchip | <span class="number">0x00067800</span> | <span class="number">0x00000800</span> |</span><br><span class="line">[I/FAL] | fdb_kvdb1 | n32_onchip | <span class="number">0x00068000</span> | <span class="number">0x00001000</span> |</span><br><span class="line">[I/FAL] | fdb_tsdb1 | n32_onchip | <span class="number">0x00069000</span> | <span class="number">0x00016800</span> |</span><br><span class="line">[I/FAL] =============================================================</span><br><span class="line">[I/FAL] RT-Thread Flash Abstraction Layer (V1<span class="number">.0</span><span class="number">.0</span>) initialize success.</span><br><span class="line">[FlashDB][tsl][<span class="built_in">log</span>][fdb_tsdb1] Sector (<span class="number">0x00000000</span>) header info is incorrect.</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跑飞卡死</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>烧录完<code>reboot</code>后，正常的打印：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">admin:/$ tsdb_test</span><br><span class="line">[D/FAL] (fal_flash_init:<span class="number">47</span>) Flash device |               n32_onchip | addr: <span class="number">0x08000000</span> | len: <span class="number">0x00080000</span> | blk_size: <span class="number">0x00000800</span> |initialized finish.</span><br><span class="line">[I/FAL] ==================== FAL partition table ====================</span><br><span class="line">[I/FAL] | name      | flash_dev  |   offset   |    length  |</span><br><span class="line">[I/FAL] -------------------------------------------------------------</span><br><span class="line">[I/FAL] | bl        | n32_onchip | <span class="number">0x00000000</span> | <span class="number">0x00002800</span> |</span><br><span class="line">[I/FAL] | app       | n32_onchip | <span class="number">0x00002800</span> | <span class="number">0x00032000</span> |</span><br><span class="line">[I/FAL] | download  | n32_onchip | <span class="number">0x00034800</span> | <span class="number">0x00032000</span> |</span><br><span class="line">[I/FAL] | upflag    | n32_onchip | <span class="number">0x00066800</span> | <span class="number">0x00000800</span> |</span><br><span class="line">[I/FAL] | dcd       | n32_onchip | <span class="number">0x00067000</span> | <span class="number">0x00000800</span> |</span><br><span class="line">[I/FAL] | mcuinfo   | n32_onchip | <span class="number">0x00067800</span> | <span class="number">0x00000800</span> |</span><br><span class="line">[I/FAL] | fdb_kvdb1 | n32_onchip | <span class="number">0x00068000</span> | <span class="number">0x00001000</span> |</span><br><span class="line">[I/FAL] | fdb_tsdb1 | n32_onchip | <span class="number">0x00069000</span> | <span class="number">0x00016800</span> |</span><br><span class="line">[I/FAL] =============================================================</span><br><span class="line">[I/FAL] RT-Thread Flash Abstraction Layer (V1<span class="number">.0</span><span class="number">.0</span>) initialize success.</span><br><span class="line">[FlashDB][tsl][<span class="built_in">log</span>][fdb_tsdb1] Sector (<span class="number">0x00000000</span>) header info is incorrect.</span><br><span class="line">[FlashDB][tsl][<span class="built_in">log</span>][fdb_tsdb1] All sector format finished.</span><br><span class="line">[FlashDB][tsl][<span class="built_in">log</span>][fdb_tsdb1] (components/flashdb/fdb_tsdb.c:<span class="number">980</span>) TSDB (<span class="built_in">log</span>) oldest sectors is <span class="number">0x00000000</span>, current using sector is <span class="number">0x00000000</span>.</span><br><span class="line">[FlashDB] FlashDB V2<span class="number">.1</span><span class="number">.1</span> is initialize success.</span><br><span class="line">[FlashDB] You can get the latest version on https:<span class="comment">//github.com/armink/FlashDB .</span></span><br><span class="line">[FlashDB][sample][tsdb] ==================== tsdb_sample ====================</span><br><span class="line">[FlashDB][sample][tsdb] append the new status.temp (<span class="number">36</span>) and status.humi (<span class="number">85</span>)</span><br><span class="line">[FlashDB][sample][tsdb] append the new status.temp (<span class="number">38</span>) and status.humi (<span class="number">90</span>)</span><br><span class="line">[FlashDB][sample][tsdb] [query_cb] queried a TSL: time: <span class="number">1</span>, temp: <span class="number">36</span>, humi: <span class="number">85</span></span><br><span class="line">[FlashDB][sample][tsdb] [query_cb] queried a TSL: time: <span class="number">2</span>, temp: <span class="number">38</span>, humi: <span class="number">90</span></span><br><span class="line">[FlashDB][sample][tsdb] [query_by_time_cb] queried a TSL: time: <span class="number">1</span>, temp: <span class="number">36</span>, humi: <span class="number">85</span></span><br><span class="line">[FlashDB][sample][tsdb] [query_by_time_cb] queried a TSL: time: <span class="number">2</span>, temp: <span class="number">38</span>, humi: <span class="number">90</span></span><br><span class="line">[FlashDB][sample][tsdb] query count is: <span class="number">2</span></span><br><span class="line">[FlashDB][sample][tsdb] <span class="built_in">set</span> the TSL (time <span class="number">1</span>) status from <span class="number">2</span> to <span class="number">3</span></span><br><span class="line">[FlashDB][sample][tsdb] <span class="built_in">set</span> the TSL (time <span class="number">2</span>) status from <span class="number">2</span> to <span class="number">3</span></span><br><span class="line">[FlashDB][sample][tsdb] ===========================================================</span><br></pre></td></tr></table></figure>
</li>
<li><p>原因：由于flash解锁是给互斥量加锁，之前写成一致了，写反了，导致进去一次之后卡死。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">flashMutex</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">af_flash_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> 	rt_mutex_init(&amp;flashMutex, <span class="string">&quot;flashMutex&quot;</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">af_flash_unlock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rt_mutex_take(&amp;flashMutex, RT_WAITING_FOREVER);	   <span class="comment">// 错误用例：rt_mutex_release(&amp;flashMutex);</span></span><br><span class="line">	FLASH_Unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">af_flash_lock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	FLASH_Lock();</span><br><span class="line">	rt_mutex_release(&amp;flashMutex);                      <span class="comment">// 错误用例：rt_mutex_take(&amp;flashMutex, RT_WAITING_FOREVER);	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="指针取址符-与取值-的区别"><a href="#指针取址符-与取值-的区别" class="headerlink" title="指针取址符&amp;与取值*的区别"></a>指针取址符&amp;与取值*的区别</h4><p><strong>1. 指针取址符(&amp;)</strong></p>
<pre><code>指针取址符 &amp; 用于获取一个变量的地址，并将该地址存储在一个指针变量中。
</code></pre>
<p><strong>具体来说:</strong></p>
<ul>
<li>&amp; 运算符位于变量名前面。</li>
<li>&amp; 运算符的返回值是一个指针，指向该变量的内存地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num; <span class="comment">// p 指向 num 的地址</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 取值符(*)</strong></p>
<pre><code>取值符 * 用于获取指针变量所指向的变量的值。
</code></pre>
<p><strong>具体来说:</strong></p>
<ul>
<li>运算符位于指针变量名前面。</li>
<li>运算符的返回值是该指针变量所指向变量的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num;</span><br><span class="line"><span class="type">int</span> value = *p;		<span class="comment">// 访问 num 的值</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>指针取址符 &amp; 用于获取变量的地址，并将该地址存储在一个指针变量中。</li>
<li>取值符 * 用于获取指针变量所指向的变量的值。</li>
</ul>
<p><strong>需要注意的是：</strong></p>
<ul>
<li>不能对不存在的变量进行取址。</li>
<li>**<code>不能对指针变量进行取址</code>**。</li>
<li>取址操作可能会产生空指针，需要进行空指针检查。</li>
</ul>
<h4 id="为什么不能对指针变量进行取址"><a href="#为什么不能对指针变量进行取址" class="headerlink" title="为什么不能对指针变量进行取址"></a>为什么不能对指针变量进行取址</h4><p><strong>1. 指针变量本身也是一个变量</strong></p>
<p>指针变量也是一个变量，它存储的是另一个变量的地址。与其他变量一样，**<code>指针变量也存在于内存中，并拥有自己的地址</code>**。</p>
<p><strong>2. 取址操作会产生无限循环</strong></p>
<p>**<code>如果对指针变量进行取址，那么就会得到该指针变量的地址</code>**。但是，该指针变量本身也是一个变量，所以其地址也是存储在另一个变量中的。如此循环往复，就会产生无限循环。</p>
<p><strong>3. 违背了指针的定义</strong></p>
<p>指针的定义是指向另一个变量的地址。如果对指针变量进行取址，那么就意味着指针指向了它自己的地址，这违背了指针的定义。</p>
<p><strong>4. 可能导致程序崩溃</strong></p>
<p>在大多数情况下，对指针变量进行取址会导致程序崩溃。这是因为程序会试图访问一个不存在的内存地址。</p>
<br>

<h3 id="结构体偏移操作"><a href="#结构体偏移操作" class="headerlink" title="结构体偏移操作"></a>结构体偏移操作</h3><ul>
<li><code>offsetof(TYPE, MEMBER)</code> 函数用法：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Offset of member MEMBER in a struct of type TYPE. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>))</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> device;</span><br><span class="line">    <span class="type">uint8_t</span> version;</span><br><span class="line">    <span class="type">uint16_t</span> packet_sum;        <span class="comment">// 大端模式</span></span><br><span class="line">    <span class="type">uint16_t</span> packet_index;      <span class="comment">// 大端模式</span></span><br><span class="line">    <span class="type">uint8_t</span> len;</span><br><span class="line">    <span class="type">uint8_t</span> cmd;</span><br><span class="line">    <span class="type">uint8_t</span> *data;</span><br><span class="line">    <span class="type">uint16_t</span> check_sum;         <span class="comment">// 大端模式</span></span><br><span class="line">&#125;ble_comm_protocol;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> send_len = offsetof(ble_comm_protocol, data);       <span class="comment">// send_len 长度为 8 bytes</span></span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<h2 id="TFT屏ST7735S调试问题"><a href="#TFT屏ST7735S调试问题" class="headerlink" title="TFT屏ST7735S调试问题"></a>TFT屏ST7735S调试问题</h2><h3 id="硬件-软件spi初始化"><a href="#硬件-软件spi初始化" class="headerlink" title="硬件&#x2F;软件spi初始化"></a>硬件&#x2F;软件spi初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HARDWARE_SPI_MODE 1	<span class="comment">//1：hardware；0：software</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_SCLK_Clr() GPIO_ResetBits(GPIOA, GPIO_PIN_5)	<span class="comment">//SCL=SCLK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_SCLK_Set() GPIO_SetBits(GPIOA, GPIO_PIN_5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_MOSI_Clr() GPIO_ResetBits(GPIOA, GPIO_PIN_7)		<span class="comment">//SDA=MOSI</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_MOSI_Set() GPIO_SetBits(GPIOA, GPIO_PIN_7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_RES_Clr()  GPIO_ResetBits(GPIOB, GPIO_PIN_0)		<span class="comment">//RES</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_RES_Set()  GPIO_SetBits(GPIOB, GPIO_PIN_0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_DC_Clr()   GPIO_ResetBits(GPIOB, GPIO_PIN_1)		<span class="comment">//DC</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_DC_Set()   GPIO_SetBits(GPIOB, GPIO_PIN_1)	     </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_CS_Clr()   GPIO_ResetBits(GPIOA, GPIO_PIN_4)		<span class="comment">//CS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_CS_Set()   GPIO_SetBits(GPIOA, GPIO_PIN_4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_BLK_Clr()											<span class="comment">//BLK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_BLK_Set()</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitType GPIO_InitStructure;</span><br><span class="line">	RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_GPIOA | RCC_APB2_PERIPH_GPIOB , ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HARDWARE_SPI_MODE</span></span><br><span class="line"></span><br><span class="line">    SPI_InitType SPI_InitStructure;</span><br><span class="line">    RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_SPI1 | RCC_APB2_PERIPH_AFIO, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct(&amp;GPIO_InitStructure);</span><br><span class="line">    GPIO_InitStructure.Pin        = GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7;</span><br><span class="line">    GPIO_InitStructure.GPIO_Alternate = GPIO_AF0_SPI1;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitPeripheral(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SPIy Config -------------------------------------------------------------*/</span></span><br><span class="line">    SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_TX;</span><br><span class="line">    SPI_InitStructure.SpiMode       = SPI_MODE_MASTER;</span><br><span class="line">    SPI_InitStructure.DataLen       = SPI_DATA_SIZE_8BITS;</span><br><span class="line">    SPI_InitStructure.CLKPOL        = SPI_CLKPOL_HIGH;</span><br><span class="line">    SPI_InitStructure.CLKPHA        = SPI_CLKPHA_FIRST_EDGE;</span><br><span class="line">    SPI_InitStructure.NSS           = SPI_NSS_HARD;</span><br><span class="line">    SPI_InitStructure.BaudRatePres  = SPI_BR_PRESCALER_2;</span><br><span class="line">    SPI_InitStructure.FirstBit      = SPI_FB_MSB;</span><br><span class="line">    SPI_InitStructure.CRCPoly       = <span class="number">7</span>;</span><br><span class="line">    SPI_Init(SPI1, &amp;SPI_InitStructure);</span><br><span class="line"></span><br><span class="line">    SPI_SSOutputEnable(SPI1, ENABLE);</span><br><span class="line">    SPI_EnableCalculateCrc(SPI1, DISABLE);</span><br><span class="line">    <span class="comment">/* Enable SPIy */</span></span><br><span class="line">    SPI_Enable(SPI1, ENABLE);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    GPIO_InitStruct(&amp;GPIO_InitStructure);</span><br><span class="line">    GPIO_InitStructure.Pin = GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitPeripheral(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    GPIO_SetBits(GPIOA, GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    GPIO_InitStruct(&amp;GPIO_InitStructure);</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1;</span><br><span class="line">    GPIO_InitPeripheral(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    GPIO_SetBits(GPIOB, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Writ_Bus</span><span class="params">(u8 dat)</span> </span><br><span class="line">&#123;	</span><br><span class="line">	LCD_CS_Clr();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HARDWARE_SPI_MODE</span></span><br><span class="line">	SPI_I2S_TransmitData(SPI1, dat);</span><br><span class="line">	<span class="keyword">while</span> (SPI_I2S_GetStatus(SPI1, SPI_I2S_TE_FLAG) == RESET); <span class="comment">//必须等到SPI数据发完，才能拉高CS片选，发下一次数据，否则数据会出错</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	u8 i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;			  </span><br><span class="line">		LCD_SCLK_Clr();</span><br><span class="line">		<span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		   LCD_MOSI_Set();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		   LCD_MOSI_Clr();</span><br><span class="line">		&#125;</span><br><span class="line">		LCD_SCLK_Set();</span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   LCD_CS_Set();	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_DATA8</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">	LCD_Writ_Bus(dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_DATA</span><span class="params">(u16 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">	LCD_Writ_Bus(dat&gt;&gt;<span class="number">8</span>);</span><br><span class="line">	LCD_Writ_Bus(dat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="Cortex-M系列内核字节对齐汇总"><a href="#Cortex-M系列内核字节对齐汇总" class="headerlink" title="Cortex-M系列内核字节对齐汇总"></a>Cortex-M系列内核字节对齐汇总</h2><ul>
<li><p>4字节对齐的含义就是变量地址对4求余数为0；8字节对齐就是地址对8求余等于0，依次类推，比如：如果让p去访问0x20000001， 0x20000002，0x20000003这都是不对齐访问。</p>
</li>
<li><p>对于<code>M3和M4</code>而言，可以直接访问非对齐地址（注意芯片要在这个地址有对应的内存空间), 因为<code>M3和M4</code>是支持的，而<code>M0/M0+/M1</code>是不支持的，不支持的内核芯片，只要非对齐访问就会触发硬件异常。</p>
</li>
</ul>
<p><strong>综上所述，我们只讨论Cortex-M3&#x2F;M4内核情况。</strong></p>
<h3 id="全局变量对齐问题"><a href="#全局变量对齐问题" class="headerlink" title="全局变量对齐问题"></a>全局变量对齐问题</h3><ul>
<li><code>uint8_t</code>定义变量地址要1字节对齐。</li>
<li><code>uint16_t</code>定义变量地址要2字节对齐。</li>
<li><code>uint32_t</code>定义变量地址要4字节对齐。</li>
<li><code>uint64_t</code>定义变量地址要8字节对齐。</li>
<li><code>指针变量</code>是4字节对齐。</li>
</ul>
<h3 id="结构体成员对齐问题"><a href="#结构体成员对齐问题" class="headerlink" title="结构体成员对齐问题"></a>结构体成员对齐问题</h3><h4 id="自然对界"><a href="#自然对界" class="headerlink" title="自然对界"></a>自然对界</h4><p><strong>例子1</strong>（分析结构各成员的默认字节对界条界条件和结构整体的默认字节对界条件）:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  <span class="type">char</span> x1; <span class="comment">// 成员x1为char型(其起始地址必须1字节对界)，其偏移地址为0 </span></span><br><span class="line">  <span class="type">char</span> x2; <span class="comment">// 成员x2为char型(其起始地址必须1字节对界，其偏移地址为1 </span></span><br><span class="line">  <span class="type">float</span> x3; <span class="comment">// 成员x3为float型(其起始地址必须4字节对界)，编译器在x2和x3之间填充了两个空字节，其偏移地址为4 </span></span><br><span class="line">  <span class="type">char</span> x4; <span class="comment">// 成员x4为char型(其起始地址必须1字节对界)，其偏移地址为8 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Test结构体中，最大的成员为<code>float</code> x3，因此结构体的自然对界条件为4字节对齐。则结构体长度就为12字节，内存布局为<code>1100 1111 1000</code>。</p>
<br>

<h4 id="指令对齐"><a href="#指令对齐" class="headerlink" title="指令对齐"></a>指令对齐</h4><p><strong>1. 伪指令#pragma pack</strong></p>
<p>改变缺省的对界条件(指定对界)</p>
<ul>
<li>使用伪指令<code>#pragma pack (n)</code>，编译器将按照n个字节对齐。</li>
<li>使用伪指令<code>#pragma pack ()</code>，取消自定义字节对齐方式。<ul>
<li>数据成员对齐规则：结构(<code>struct</code>)(或联合(<code>union</code>))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照<code>#pragma pack</code>指定的数值和这个数据成员自身长度中，比较小的那个进行。</li>
<li>结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照<code>#pragma pack</code>指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</li>
</ul>
</li>
</ul>
<p>结合推断：当<code>#pragma pack</code>的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。因此，当使用伪指令<code>#pragma pack (2)</code>时，Test结构体的大小为8，内存布局为<code>1111 1110</code>。</p>
<ul>
<li>需要注意一点，当结构体中包含一个子结构体时，子结构中的成员按照#pragma pack指定的数值和子结构最大数据成员长度中，比较小的那个进行进行对齐。例子如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">short</span> a;</span><br><span class="line">  <span class="type">long</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  s1 d;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
<p><code>sizeof(s2)</code>的结果为24。S1的内存布局为<code>1100 1111</code>，S2的内存布局为<code>1000 1100 1111 0000 1111 1111</code>。</p>
<p><strong>例子2</strong>(按照2个字节对齐时)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> aa1; <span class="comment">//2个字节对齐 1111</span></span><br><span class="line">  <span class="type">char</span> bb1;<span class="comment">//1个字节对齐 1</span></span><br><span class="line">  <span class="type">short</span> cc1;<span class="comment">//2个字节对齐 011</span></span><br><span class="line">  <span class="type">char</span> dd1; <span class="comment">//1个字节对齐 1</span></span><br><span class="line">&#125; testlength1;</span><br><span class="line"><span class="type">int</span> length1 = <span class="keyword">sizeof</span>(testlength1); <span class="comment">//2个字节对齐，占用字节11 11 10 11 10,length = 10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> bb2;<span class="comment">//1个字节对齐 1</span></span><br><span class="line">  <span class="type">int</span> aa2; <span class="comment">//2个字节对齐 01111</span></span><br><span class="line">  <span class="type">short</span> cc2;<span class="comment">//2个字节对齐 11</span></span><br><span class="line">  <span class="type">char</span> dd2; <span class="comment">//1个字节对齐 1</span></span><br><span class="line">&#125; testlength2;</span><br><span class="line"><span class="type">int</span> length2 = <span class="keyword">sizeof</span>(testlength2); <span class="comment">//2个字节对齐，占用字节10 11 11 11 10,length = 10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> bb3; <span class="comment">//1个字节对齐 1</span></span><br><span class="line">  <span class="type">char</span> dd3; <span class="comment">//1个字节对齐 1</span></span><br><span class="line">  <span class="type">int</span> aa3; <span class="comment">//2个字节对齐 11 11</span></span><br><span class="line">  <span class="type">short</span> cc23<span class="comment">//2个字节对齐 11</span></span><br><span class="line"> </span><br><span class="line">&#125; testlength3;</span><br><span class="line"><span class="type">int</span> length3 = <span class="keyword">sizeof</span>(testlength3); <span class="comment">//2个字节对齐，占用字节11 11 11 11,length = 8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> bb4; <span class="comment">//1个字节对齐 1</span></span><br><span class="line">  <span class="type">char</span> dd4; <span class="comment">//1个字节对齐 1</span></span><br><span class="line">  <span class="type">short</span> cc4;<span class="comment">//2个字节对齐 11</span></span><br><span class="line">  <span class="type">int</span> aa4; <span class="comment">//2个字节对齐 11 11</span></span><br><span class="line">&#125; testlength4;</span><br><span class="line"><span class="type">int</span> length4 = <span class="keyword">sizeof</span>(testlength4); <span class="comment">//2个字节对齐，占用字节11 11 11 11,length = 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;length1 = %d.\n&quot;</span>,length1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;length2 = %d.\n&quot;</span>,length2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;length3 = %d.\n&quot;</span>,length3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;length4 = %d.\n&quot;</span>,length4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. <strong>attribute</strong>((<strong>aligned</strong>(n)))</strong></p>
<p><code>__attribute__</code>是GCC里的编译参数，用法有很多种，感兴趣可以阅读一下gcc的相关文档。这里说一下<code>__attribute__</code>对变量和结构体对齐的影响。这里的影响大概分为两个方面，对齐和本身占用的字节数的大小，即sizeof（变量）的值。</p>
<ul>
<li><code>int a attribute((aligned(64))) = 10;</code></li>
</ul>
<p>这个修饰的影响主要是对齐，所谓对齐是存储为值的起始地址。变量a的地址&amp;a,本来是4字节对齐，变成了64字节对齐（有的环境对最大对齐数值有限制）。64字节对齐就是<code>&amp;a</code>的最后6位为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">4</span>; 		<span class="comment">//a 占用的字节数还是4个字节</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>typedef int myint attribute((aligned(64))) ;</code></li>
</ul>
<p>这样说明myint 声明的变量按照64字节对齐，大小是4字节，这样就会有一个问题，这个变量不能定义数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">myint myarray[<span class="number">2</span>]; 	<span class="comment">//这样定义编译器会报err</span></span><br></pre></td></tr></table></figure>
<p>报错的原因是数组的存储在内存中是连续的，而myint只有4字节确要64字节对齐，这样对齐和连续就不能同时保证，就会报错。</p>
<p><strong>例子1</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_tag</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">&#125; ST1;</span><br><span class="line">ST1 myst；</span><br></pre></td></tr></table></figure>

<p>在没有对齐的情况下：<code>sizeof(ST1) = sizeof(myst) = 8;</code><br>结构体对齐的原则可以总结为：</p>
<ul>
<li>结构体起始地址(&amp;myst)按最大变量字节数(sizeof(int))对齐；</li>
<li>结构体内每个变量按照自身字节数对齐；</li>
<li>结构体的大小<code>(sizeof(myst))</code>是最大变量字节数的整数倍（8&#x2F;4&#x3D;2）；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_tag</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">&#125;  __attribute__((__aligned__(<span class="number">64</span>))) ST1;</span><br><span class="line">ST1 myst；</span><br><span class="line"><span class="keyword">sizeof</span>(ST1) = <span class="keyword">sizeof</span>(myst) = <span class="number">64</span>; </span><br></pre></td></tr></table></figure>
<p>对比：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_tag</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">&#125;  ST1 __attribute__((__aligned__(<span class="number">64</span>)));</span><br><span class="line">ST1 myst；</span><br><span class="line"><span class="keyword">sizeof</span>(ST1) = <span class="keyword">sizeof</span>(myst) = <span class="number">8</span> ;</span><br></pre></td></tr></table></figure>

<p>这第二种情况可以理解为<code>__attribute__((aligned(64)))</code>作用于变量ST1 ，只影响对齐，不影响结构的大小。</p>
<p><strong>例子2</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>))</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> comm_version;</span><br><span class="line">    <span class="type">uint8_t</span> comm_lenth;</span><br><span class="line">    <span class="type">uint8_t</span> device_fw_verion[];</span><br><span class="line">&#125;ble_resp_device_info_desc;</span><br></pre></td></tr></table></figure>
<p><code>__attribute__((packed))</code>是GCC编译器提供的一个属性,<code>__attribute__((packed))</code>其中的成员变量不会进行对齐。</p>
<br>

<h2 id="HSV-模型"><a href="#HSV-模型" class="headerlink" title="HSV 模型"></a>HSV 模型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将HSV颜色转换为RGB颜色</span></span><br><span class="line"><span class="comment">* hue,色调:0-360; saturation,纯度:0-1; value,明度:0-1</span></span><br><span class="line"><span class="comment">* r,g,b,RGB颜色，此值范围为0-255，但外界传入时的变量须是int类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hsv_to_rgb</span><span class="params">(<span class="type">float</span> h, <span class="type">float</span> s, <span class="type">float</span> v, <span class="type">int</span> *r, <span class="type">int</span> *g, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">float</span> f, x, y, z;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   v *= <span class="number">255.0</span>;</span><br><span class="line">   <span class="keyword">if</span> (s == <span class="number">0.0</span>) &#123;</span><br><span class="line">      *r = *g = *b = (<span class="type">int</span>)v;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (h &lt; <span class="number">0</span>)</span><br><span class="line">      h += <span class="number">360</span>;</span><br><span class="line">      h = <span class="built_in">fmod</span>(h, <span class="number">360</span>) / <span class="number">60.0</span>;</span><br><span class="line">      i = (<span class="type">int</span>)h;</span><br><span class="line">      f = h - i;</span><br><span class="line">      x = v * (<span class="number">1.0</span> - s);</span><br><span class="line">      y = v * (<span class="number">1.0</span> - (s * f));</span><br><span class="line">      z = v * (<span class="number">1.0</span> - (s * (<span class="number">1.0</span> - f)));</span><br><span class="line">      <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>: *r = v; *g = z; *b = x; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>: *r = y; *g = v; *b = x; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>: *r = x; *g = v; *b = z; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>: *r = x; *g = y; *b = v; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>: *r = z; *g = x; *b = v; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">5</span>: *r = v; *g = x; *b = y; <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Demo如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">led_set_poll</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> red,green,blue;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> hue = <span class="number">0</span>;</span><br><span class="line">    hue = fmodf(hue + <span class="number">1.0</span>, <span class="number">360.0</span>);  <span class="comment">// 0-360 色调循环</span></span><br><span class="line">    hsv_to_rgb(hue, <span class="number">1.0</span>, <span class="number">1.0</span>, &amp;red, &amp;green, &amp;blue);</span><br><span class="line">    display_board_rgb_color_set(red, green, blue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><code>RT-Thread</code>和<code>FreeRTOS</code>都是流行的嵌入式实时操作系统（<code>RTOS</code>），它们提供了内存管理机制来处理任务、队列、信号量等对象的创建和删除。尽管两者在内存管理的某些方面有相似之处，但它们在实现和配置上存在一些关键的区别：</p>
<ul>
<li><p>内存管理策略：</p>
<ul>
<li><strong>RT-Thread</strong>：提供了动态内存堆管理和静态内存池管理两种方式。动态内存堆管理允许在运行时动态分配和释放内存，而内存池管理则分配固定大小的内存块，适用于分配大量大小相同的小内存块的场景。</li>
<li><strong>FreeRTOS</strong>：提供了多种内存管理方案，包括简单的静态内存分配（<code>heap_1</code>）和更复杂的动态内存分配策略（如<code>heap_2</code>、<code>heap_3</code>、<code>heap_4</code>和<code>heap_5</code>）。<code>FreeRTOS</code>的动态内存分配策略允许内存的分配和释放，同时也提供了内存碎片管理的方法。</li>
</ul>
</li>
<li><p>内存分配函数：</p>
<ul>
<li><strong>RT-Thread</strong>：使用自己的内存分配函数，如<code>rt_malloc</code>、<code>rt_free</code>、<code>rt_realloc</code>和<code>rt_calloc</code>，这些函数与<code>C</code>标准库中的<code>malloc</code>和<code>free</code>类似，但是专为<code>RT-Thread</code>设计。</li>
<li><strong>FreeRTOS</strong>：使用<code>pvPortMalloc</code>和<code>vPortFree</code>函数进行内存分配和释放。<code>FreeRTOS</code>还提供了<code>xPortGetFreeHeapSize</code>等函数来获取内存堆的状态。</li>
</ul>
</li>
<li><p>内存堆的实现：</p>
<ul>
<li><strong>RT-Thread</strong>：内存堆管理根据内存设备的不同，分为小内存块分配管理、大内存块的<code>slab</code>分配管理和多内存堆分配情况的管理。</li>
<li><strong>FreeRTOS</strong>：提供了多种内存堆实现，例如<code>heap_1</code>不允许释放内存，<code>heap_2</code>允许释放但不合并相邻空闲块，<code>heap_3</code>包装了标准库的<code>malloc</code>和<code>free</code>，<code>heap_4</code>合并相邻空闲块以减少碎片，<code>heap_5</code>则支持跨多个不相邻内存区域的堆。</li>
</ul>
</li>
<li><p>内存碎片管理：</p>
<ul>
<li><strong>RT-Thread</strong>：通过内存池管理来减少内存碎片，内存池预先分配一块内存，并在其中管理固定大小的内存块。</li>
<li><strong>FreeRTOS</strong>：<code>heap_4</code>和<code>heap_5</code>实现了内存碎片管理，通过合并相邻的空闲内存块来减少碎片。</li>
</ul>
</li>
<li><p>内存管理的配置：</p>
<ul>
<li><strong>RT-Thread</strong>：内存管理的配置通常在<code>rtconfig.h</code>中进行，可以选择使用不同的内存管理算法。</li>
<li><strong>FreeRTOS</strong>：内存管理的配置也在配置文件中进行，需要选择一个合适的堆管理实现文件，并在<code>FreeRTOSConfig.h</code>中进行相应的配置。</li>
</ul>
</li>
<li><p>内存管理的适用性：</p>
<ul>
<li><strong>RT-Thread</strong>：内存管理机制适用于各种大小的内存块，特别是通过内存池管理来优化小内存块的分配效率。</li>
<li><strong>FreeRTOS</strong>：提供了多种内存管理策略，适用于不同的应用场景和内存需求，从简单的静态分配到复杂的动态分配。</li>
</ul>
</li>
</ul>
<p>总的来说，<code>RT-Thread</code>和<code>FreeRTOS</code>都提供了灵活的内存管理机制来满足不同嵌入式应用的需求。选择哪种内存管理策略取决于具体的应用场景、内存需求和开发偏好。</p>
<h2 id="国民UART-DMA-TX问题"><a href="#国民UART-DMA-TX问题" class="headerlink" title="国民UART+DMA+TX问题"></a>国民UART+DMA+TX问题</h2><p>改之前：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ec32_uart_dma_tx_config</span><span class="params">(<span class="keyword">struct</span> ec_serial_device *serial, <span class="type">uint8_t</span> *buffer, <span class="type">uint16_t</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(serial-&gt;Txbuffer-&gt;tail + length &gt; serial-&gt;dma.setting_tx_len) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(DMA_GetFlagStatus(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type) == RESET)&#123;&#125;</span><br><span class="line">        DMA_ClearFlag(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE);</span><br><span class="line">    DMA_InitType DMA_InitStructure;</span><br><span class="line">	</span><br><span class="line">    <span class="type">uint16_t</span> dma_get_counts = DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch);</span><br><span class="line">    <span class="comment">/* if no data waiting send*/</span></span><br><span class="line">    <span class="keyword">if</span>(dma_get_counts == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	serial-&gt;Txbuffer-&gt;lenth = length &gt; serial-&gt;dma.setting_tx_len ? serial-&gt;dma.setting_tx_len : length;</span><br><span class="line">	<span class="built_in">memcpy</span>(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth);</span><br><span class="line">        DMA_InitStructure.MemAddr = (<span class="type">uint32_t</span>)serial-&gt;Txbuffer-&gt;data;</span><br><span class="line">        DMA_InitStructure.BufSize = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">        serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;	</span><br><span class="line">        <span class="built_in">memcpy</span>(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail, buffer, length);</span><br><span class="line">        DMA_InitStructure.MemAddr = (<span class="type">uint32_t</span>)(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail - dma_get_counts);</span><br><span class="line">        DMA_InitStructure.BufSize = length + dma_get_counts;</span><br><span class="line">        serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;tail + length;</span><br><span class="line">    &#125;</span><br><span class="line">... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题解决来自<code>jindu-chen</code>，修改后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ec32_uart_dma_tx_config</span><span class="params">(<span class="keyword">struct</span> ec_serial_device *serial, <span class="type">uint8_t</span> *buffer, <span class="type">uint16_t</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE);</span><br><span class="line">    DMA_InitType DMA_InitStructure;</span><br><span class="line">	</span><br><span class="line">    <span class="type">uint16_t</span> dma_get_counts = DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch);</span><br><span class="line">    <span class="comment">/* if no data waiting send*/</span></span><br><span class="line">    <span class="keyword">if</span>(dma_get_counts == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        serial-&gt;Txbuffer-&gt;lenth = length &gt; serial-&gt;dma.setting_tx_len ? serial-&gt;dma.setting_tx_len : length;</span><br><span class="line">        <span class="built_in">memcpy</span>(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth);</span><br><span class="line">        DMA_InitStructure.MemAddr = (<span class="type">uint32_t</span>)serial-&gt;Txbuffer-&gt;data;</span><br><span class="line">        DMA_InitStructure.BufSize = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">        serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;	</span><br><span class="line">        <span class="keyword">if</span>(serial-&gt;Txbuffer-&gt;tail + length &gt; serial-&gt;dma.setting_tx_len)</span><br><span class="line">        &#123;</span><br><span class="line">            DMA_EnableChannel(serial-&gt;dma.tx_ch, ENABLE);</span><br><span class="line">            <span class="keyword">while</span>(DMA_GetFlagStatus(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type) == RESET)&#123;&#125;</span><br><span class="line"></span><br><span class="line">            DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE);</span><br><span class="line">            <span class="built_in">memcpy</span>(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth);</span><br><span class="line">            DMA_InitStructure.MemAddr = (<span class="type">uint32_t</span>)serial-&gt;Txbuffer-&gt;data;</span><br><span class="line">            DMA_InitStructure.BufSize = length;</span><br><span class="line">            serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail, buffer, length);</span><br><span class="line">            DMA_InitStructure.MemAddr = (<span class="type">uint32_t</span>)(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail - dma_get_counts);</span><br><span class="line">            DMA_InitStructure.BufSize = length + dma_get_counts;</span><br><span class="line">            serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;tail + length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改前<code>tail</code>指针接近缓存区最大边界时，剩余空间不足时会进入以下函数, 一直卡在<code>while</code>中出不来, 需改到后面去：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(serial-&gt;Txbuffer-&gt;tail + length &gt; serial-&gt;dma.setting_tx_len) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(DMA_GetFlagStatus(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type) == RESET)&#123;&#125;</span><br><span class="line">    DMA_ClearFlag(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch) 需要实时获取</span><br></pre></td></tr></table></figure>
<p>即以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ec32_uart_dma_tx_config</span><span class="params">(<span class="keyword">struct</span> ec_serial_device *serial, <span class="type">uint8_t</span> *buffer, <span class="type">uint16_t</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE);</span><br><span class="line">    DMA_InitType DMA_InitStructure;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* if no data waiting send*/</span></span><br><span class="line">    <span class="keyword">if</span>(DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		serial-&gt;Txbuffer-&gt;lenth = length &gt; serial-&gt;dma.setting_tx_len ? serial-&gt;dma.setting_tx_len : length;</span><br><span class="line">		<span class="built_in">memcpy</span>(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth);</span><br><span class="line">        DMA_InitStructure.MemAddr = (<span class="type">uint32_t</span>)serial-&gt;Txbuffer-&gt;data;</span><br><span class="line">        DMA_InitStructure.BufSize = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">        serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;	</span><br><span class="line">        <span class="keyword">if</span>(serial-&gt;Txbuffer-&gt;tail + length &gt; serial-&gt;dma.setting_tx_len)</span><br><span class="line">        &#123;</span><br><span class="line">            DMA_EnableChannel(serial-&gt;dma.tx_ch, ENABLE);</span><br><span class="line">            <span class="keyword">while</span>(DMA_GetFlagStatus(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type) == RESET)&#123;&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//需在serial-&gt;Txbuffer-&gt;lenth赋值之前，否则DMA_InitStructure.BufSize会刷新，会继续发送未知数据。</span></span><br><span class="line">            DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//需在DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE)之后</span></span><br><span class="line">            serial-&gt;Txbuffer-&gt;lenth = length &gt; serial-&gt;dma.setting_tx_len ? serial-&gt;dma.setting_tx_len : length;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth);</span><br><span class="line">			DMA_InitStructure.MemAddr = (<span class="type">uint32_t</span>)serial-&gt;Txbuffer-&gt;data;</span><br><span class="line">			DMA_InitStructure.BufSize = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">			serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail, buffer, length);</span><br><span class="line">			DMA_InitStructure.MemAddr = (<span class="type">uint32_t</span>)(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail - DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch));</span><br><span class="line">			DMA_InitStructure.BufSize = length + DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch);</span><br><span class="line">			serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;tail + length;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后还是会在DMA发送数据满的时候，多出不知名的符号，再次修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ec32_uart_dma_tx_config</span><span class="params">(<span class="keyword">struct</span> ec_serial_device *serial, <span class="type">uint8_t</span> *buffer, <span class="type">uint16_t</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE);          <span class="comment">//去掉这一项，在需要关闭时再关闭DMA，否则会影响数组满时的数据。</span></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<p>修改后代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void ec32_uart_dma_tx_config(struct ec_serial_device *serial, uint8_t *buffer, uint16_t length)</span><br><span class="line">&#123;</span><br><span class="line">    DMA_InitType DMA_InitStructure;</span><br><span class="line">	</span><br><span class="line">    /* if no data waiting send*/</span><br><span class="line">    if(DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE);</span><br><span class="line">		serial-&gt;Txbuffer-&gt;lenth = length &gt; serial-&gt;dma.setting_tx_len ? serial-&gt;dma.setting_tx_len : length;</span><br><span class="line">		memcpy(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth);</span><br><span class="line">        DMA_InitStructure.MemAddr = (uint32_t)serial-&gt;Txbuffer-&gt;data;</span><br><span class="line">        DMA_InitStructure.BufSize = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">        serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if(serial-&gt;Txbuffer-&gt;tail + length &gt; serial-&gt;dma.setting_tx_len)</span><br><span class="line">        &#123;</span><br><span class="line">            while(DMA_GetFlagStatus(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type) == RESET)&#123;&#125;</span><br><span class="line">            DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE);</span><br><span class="line">            </span><br><span class="line">            serial-&gt;Txbuffer-&gt;lenth = length &gt; serial-&gt;dma.setting_tx_len ? serial-&gt;dma.setting_tx_len : length;</span><br><span class="line">            memcpy(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth);</span><br><span class="line">			DMA_InitStructure.MemAddr = (uint32_t)serial-&gt;Txbuffer-&gt;data;</span><br><span class="line">			DMA_InitStructure.BufSize = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">			serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE);</span><br><span class="line">			memcpy(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail, buffer, length);</span><br><span class="line">			DMA_InitStructure.MemAddr = (uint32_t)(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail - DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch));</span><br><span class="line">			DMA_InitStructure.BufSize = length + DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch);</span><br><span class="line">			serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;tail + length;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<br>

<h2 id="RT-THREAD下IAP升级问题"><a href="#RT-THREAD下IAP升级问题" class="headerlink" title="RT-THREAD下IAP升级问题"></a>RT-THREAD下IAP升级问题</h2><p>当前代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RT_THREAD_PRIORITY_MAX          32 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_THREAD_COMM_TASK_PRIORITY    10</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">iap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> proi = RT_THREAD_COMM_TASK_PRIORITY - <span class="number">1</span>;</span><br><span class="line">	<span class="type">rt_thread_t</span> th = rt_thread_find(<span class="string">&quot;tidle&quot;</span>);					<span class="comment">//fix it（2022.8.30）</span></span><br><span class="line">	rt_thread_control(th,RT_THREAD_CTRL_CHANGE_PRIORITY,&amp;proi);</span><br><span class="line">	SerialDownload();</span><br><span class="line">	proi = RT_THREAD_PRIORITY_MAX - <span class="number">1</span>;</span><br><span class="line">	rt_thread_control(th,RT_THREAD_CTRL_CHANGE_PRIORITY,&amp;proi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>思路是进入<code>IAP</code>升级后提高当前优先级，避免其他任务打断，传输数据接收异常，导致升级失败。</li>
<li>后面测试发现如果升级途中被外部字符输入打断，会一直在<code>YMODEM</code>里面出不来，开了看门口也没用（<code>YMODEM</code>接收程序里有看门狗）。</li>
<li>解决方法：<br>目前添加<code>rt_schedule();</code>暂时解决问题，测试中会偶发，最近测试没有发现，待进一步测试。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">rt_thread_t</span> th = rt_thread_find(<span class="string">&quot;tidle&quot;</span>);					<span class="comment">//fix it（2022.8.30）</span></span><br><span class="line">   <span class="type">int</span> original_priority = th-&gt;current_priority;</span><br><span class="line">   <span class="type">int</span> new_priority = RT_THREAD_COMM_TASK_PRIORITY - <span class="number">1</span>;</span><br><span class="line"><span class="type">rt_err_t</span> ret = rt_thread_control(th,RT_THREAD_CTRL_CHANGE_PRIORITY,&amp;new_priority);</span><br><span class="line">   <span class="comment">// rt_schedule();</span></span><br><span class="line"></span><br><span class="line">SerialDownload();</span><br><span class="line"></span><br><span class="line">ret = rt_thread_control(th,RT_THREAD_CTRL_CHANGE_PRIORITY,&amp;original_priority);</span><br><span class="line">   rt_schedule();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="J-LINK添加芯片"><a href="#J-LINK添加芯片" class="headerlink" title="J-LINK添加芯片"></a>J-LINK添加芯片</h2><p><code>J-LINK</code>时常会添加没用过的芯片，有以下步骤可以适配J-LINK的UI界面版和指令板，以<code>GD</code>的<code>GD32E235CBT6</code>举例：</p>
<ul>
<li>添加<code>GD32E23x.FLM</code>文件到<code>JLink\Devices\GigaDevice</code></li>
<li>在最后面, <code>&lt;/DataBase&gt;</code>之前追加<code>JLinkDevices.xml</code>文件的内容：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Device</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ChipInfo</span> <span class="attr">Vendor</span>=<span class="string">&quot;GigaDevice&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;GD32E235CB&quot;</span> <span class="attr">Core</span>=<span class="string">&quot;JLINK_CORE_CORTEX_M23&quot;</span>  <span class="attr">WorkRAMAddr</span>=<span class="string">&quot;0x20000000&quot;</span> <span class="attr">WorkRAMSize</span>=<span class="string">&quot;0x00004000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FlashBankInfo</span> <span class="attr">Name</span>=<span class="string">&quot;Flash Bank1&quot;</span> <span class="attr">BaseAddr</span>=<span class="string">&quot;0x08000000&quot;</span> <span class="attr">MaxSize</span>=<span class="string">&quot;0x00020000&quot;</span> <span class="attr">Loader</span>=<span class="string">&quot;Devices\GigaDevice\GD32E23x.FLM&quot;</span> <span class="attr">LoaderType</span>=<span class="string">&quot;FLASH_ALGO_TYPE_OPEN&quot;</span> <span class="attr">AlwaysPresent</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Device</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>注意, <code>Name=&quot;GD32E235CB&quot;</code> 中的<code>GD32E235CB</code> 需要跟脚本指令 <code>JLink -device N32G452RC</code>保持一致。</li>
</ul>
<h2 id="利用正弦曲线模拟呼吸灯"><a href="#利用正弦曲线模拟呼吸灯" class="headerlink" title="利用正弦曲线模拟呼吸灯"></a>利用正弦曲线模拟呼吸灯</h2><ul>
<li>直接上示例：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLED_WHITE_NUM_MAX 		11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLED_RGB_TYPE 			3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLED_LIGHT_PERCENT 		0.3f								<span class="comment">//light percent</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLED_VALUE_MAX 			(uint8_t)(255 * RLED_LIGHT_PERCENT)	<span class="comment">//max 255</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHARGE_BREATH_TICKS		3000.0								<span class="comment">//3s</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> M_PI</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> M_PI 3.14159265358979323846</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> twoPi = <span class="number">2.0f</span> * M_PI; <span class="comment">// 2 * π</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">led_rgb_breath_function</span><span class="params">(<span class="type">uint8_t</span> *rgb, <span class="type">float</span> tick)</span>		<span class="comment">//tick-&gt;(0~1) 为一个周期</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[RLED_RGB_TYPE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;RLED_RGB_TYPE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp[i] = (rgb[i] * (<span class="number">1.0f</span> + <span class="built_in">cos</span>(M_PI + twoPi * tick)) / <span class="number">2.0f</span>);</span><br><span class="line">		board_led_rgb_set(i, temp[i]);          <span class="comment">//具体输出RGB的PWM函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RLED_RUN_MODE <span class="title function_">rled_ring_charge_function</span><span class="params">(<span class="type">event_param_t</span> ep)</span></span><br><span class="line">&#123;</span><br><span class="line">	RLED_RUN_MODE ret = RLED_NONE;</span><br><span class="line">		</span><br><span class="line">	<span class="type">static</span> <span class="type">float</span> ticks = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint8_t</span> rgb_temp[] = RGB_LED_COLOR_WHITE;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;RLED_RGB_TYPE; i++)</span><br><span class="line">		rgb_temp[i] = (<span class="type">uint8_t</span>)(rgb_temp[i] * RLED_LIGHT_PERCENT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ep.first_in)&#123;</span><br><span class="line">		led_white_all_play(<span class="number">0</span>);</span><br><span class="line">		ticks = <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		ticks = ticks + LED_MAIN_UPGRATE_TIMES * LED_SINGLE_CHR_IN_CNTS / CHARGE_BREATH_TICKS;  <span class="comment">// ticks递增</span></span><br><span class="line">		led_rgb_breath_function(rgb_temp, ticks);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ret = ep.mode;</span><br><span class="line">	<span class="keyword">if</span>(ep.ret_priv)</span><br><span class="line">		ret = ep.mode;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h2 id="RTC低功耗唤醒问题"><a href="#RTC低功耗唤醒问题" class="headerlink" title="RTC低功耗唤醒问题"></a>RTC低功耗唤醒问题</h2><h3 id="RTC设置日期时间问题"><a href="#RTC设置日期时间问题" class="headerlink" title="RTC设置日期时间问题"></a>RTC设置日期时间问题</h3><ul>
<li><p>遇到问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">drv_low_power_rtc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rtc_date_time_default_value();</span><br><span class="line">	rtc_alarm_default_value();</span><br><span class="line">    rtc_system_clk_config();</span><br><span class="line">	<span class="keyword">if</span>(USER_WRITE_BKP_DAT1_DATA != BKP_ReadBkpData(BKP_DAT1))</span><br><span class="line">    &#123;</span><br><span class="line">		logDebug(<span class="string">&quot;RTC not yet configured.... &quot;</span>);</span><br><span class="line">		rtc_clk_source_config(RTC_CLK_SRC_TYPE_LSI, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">		rtc_date_params_set(&amp;RTC_DateDefault);</span><br><span class="line">		rtc_time_params_set(&amp;RTC_TimeDefault);</span><br><span class="line">		BKP_WriteBkpData(BKP_DAT1, USER_WRITE_BKP_DAT1_DATA);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		logDebug(<span class="string">&quot;RTC is haven configured.... &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	wakeup_exti_trigger_init();</span><br><span class="line">    wakeup_exti_config_it(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rtc_clk_source_config(...)</code>执行完后，设置日期<code>rtc_date_params_set(...)</code>，设置会失败显示<code>The current date (WeekDay-Date-Month-Year) is &lt; 00-01-01-00 &gt;</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">D [<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>,<span class="number">000</span>] (driver/drv_lp_rtc.c) drv_low_power_rtc_init [<span class="number">380</span>]: RTC not yet configured.... </span><br><span class="line">D [<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>,<span class="number">000</span>] (driver/drv_lp_rtc.c) rtc_clk_source_config [<span class="number">331</span>]: RTC_ClkSrc Is Set LSI!</span><br><span class="line">D [<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>,<span class="number">001</span>] (driver/drv_lp_rtc.c) rtc_date_params_set [<span class="number">166</span>]: &gt;&gt; RTC Set Date success. &lt;&lt;</span><br><span class="line">D [<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>,<span class="number">001</span>] (driver/drv_lp_rtc.c) rtc_date_param_show [<span class="number">125</span>]: The current <span class="title function_">date</span> <span class="params">(WeekDay-Date-Month-Year)</span> is &lt; 00-01-01-00 &gt;</span><br><span class="line">D [00:00:00,001] <span class="params">(driver/drv_lp_rtc.c)</span> rtc_time_params_set [186]: &gt;&gt; RTC Set Time success. &lt;&lt;</span><br><span class="line">D [00:00:00,001] <span class="params">(driver/drv_lp_rtc.c)</span> rtc_time_param_show [137]: The current <span class="title function_">time</span> <span class="params">(Hour-Minute-Second)</span> is &lt; 12:00:01 &gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原因分析，在函数<code>ErrorStatus RTC_Init(RTC_InitType* RTC_InitStruct)&#123;...&#125;</code>中有以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delay for the RTC prescale effect */</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">0x2FF</span>;i++);</span><br></pre></td></tr></table></figure></li>
<li><p>当跑原厂<code>demo</code>的时候不会出现设置失败，经排查发现<code>demo</code>是的优化等级是<code>O0</code>，而本代码是<code>Os</code>，优化等级<code>Os</code>会将空循环<code>for(i=0;i&lt;0x2FF;i++);</code>导致RTC初始化后，等待寄存器同步过程被优化掉不去执行，导致下一步设置<code>RTC</code>参数失败。</p>
</li>
<li><p>解决方案：</p>
<ul>
<li>1、将函数<code>for(i=0;i&lt;0x2FF;i++);</code>中<code>i</code>的变量类型改为<code>volatile</code>，将会直接读取寄存器，不会被内存优化。</li>
<li>2、将函数<code>for(i=0;i&lt;0x2FF;i++);</code>替换为<code>for(i=0;i&lt;0x2FF;i++)&#123;__asm(&quot;nop&quot;);&#125;</code>，将会直接执行指令，不会被内存优化。</li>
</ul>
</li>
</ul>
<h3 id="RTC唤醒偶尔失败（rt-thread操作系统）"><a href="#RTC唤醒偶尔失败（rt-thread操作系统）" class="headerlink" title="RTC唤醒偶尔失败（rt-thread操作系统）"></a>RTC唤醒偶尔失败（rt-thread操作系统）</h3><p>调试发现<code>按键唤醒</code>和<code>闹钟唤醒</code>均可, <code>RTC自动唤醒</code>有问题。</p>
<h4 id="唤醒例程"><a href="#唤醒例程" class="headerlink" title="唤醒例程"></a>唤醒例程</h4><ul>
<li><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_WAKEUP_EN  			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IWDG_MAX_TIMEOUT_SECS	25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IWDG_MAX_USER_SECS	21</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">board_rtc_alarm_second_set</span><span class="params">(<span class="type">uint32_t</span> secs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> second = IWDG_MAX_USER_SECS;</span><br><span class="line">	<span class="keyword">if</span>(secs &lt; IWDG_MAX_USER_SECS)</span><br><span class="line">		second = secs;</span><br><span class="line">	rtc_alarm_second_set(second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂起所有线程的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">suspend_all_threads</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object_information</span> *<span class="title">information</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取线程对象信息 */</span></span><br><span class="line">    information = rt_object_get_information(RT_Object_Class_Thread);</span><br><span class="line">    RT_ASSERT(information != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进入临界区 */</span></span><br><span class="line">    rt_enter_critical();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空tick值，关闭systick中断</span></span><br><span class="line">	SysTick-&gt;VAL = <span class="number">0x00</span>;</span><br><span class="line">	SysTick-&gt;CTRL = <span class="number">0x00</span>;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历线程对象列表 */</span></span><br><span class="line">    <span class="keyword">for</span> (node = information-&gt;object_list.next; node != &amp;(information-&gt;object_list); node = node-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        thread = rt_list_entry(node, <span class="keyword">struct</span> rt_thread, <span class="built_in">list</span>);</span><br><span class="line">        <span class="comment">/* 确保不是挂起当前正在运行的线程 */</span></span><br><span class="line">        <span class="keyword">if</span> (thread != rt_thread_self())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 挂起线程 */</span></span><br><span class="line">            rt_thread_suspend(thread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 退出临界区 */</span></span><br><span class="line">    rt_exit_critical();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">board_pwr_enter_stop2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	suspend_all_threads();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> RTC_WAKEUP_EN</span></span><br><span class="line">	rtc_auto_wakeup_init(<span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		serial_only_print_string(<span class="string">&quot;Start low power mode!\r\n\r\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !RTC_WAKEUP_EN</span></span><br><span class="line">		board_rtc_alarm_second_set(<span class="number">20</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		PWR_EnterSTOP2Mode(PWR_STOPENTRY_WFI);</span><br><span class="line">		system_clock_config_stop2();</span><br><span class="line">		system_print_config_stop2();</span><br><span class="line">		serial_only_print_string(<span class="string">&quot;Exit low power mode!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">bool</span> botton_sw = GPIO_ReadInputDataBit(GPIOA, GPIO_PIN_0);</span><br><span class="line">		<span class="type">bool</span> dc_ch = !GPIO_ReadInputDataBit(GPIOA, GPIO_PIN_5);</span><br><span class="line">		<span class="keyword">if</span>(botton_sw) 		<span class="comment">//  || dc_ch</span></span><br><span class="line">		&#123;</span><br><span class="line">			serial_only_print_string(<span class="string">&quot;botton press!\r\n&quot;</span>);</span><br><span class="line">			reboot();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>RTC auto wakeup</code>成功, 需注意唤醒时钟问题:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">drv_low_power_rtc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rtc_date_time_default_value();</span><br><span class="line">	rtc_alarm_default_value();</span><br><span class="line">    rtc_system_clk_config();</span><br><span class="line">    rtc_auto_wakeup_init();</span><br><span class="line">	<span class="keyword">if</span>(USER_WRITE_BKP_DAT1_DATA != BKP_ReadBkpData(BKP_DAT1))</span><br><span class="line">    &#123;</span><br><span class="line">		logDebug(<span class="string">&quot;RTC not yet configured.... &quot;</span>);</span><br><span class="line">		rtc_clk_source_config(RTC_CLK_SRC_TYPE_LSI, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">        RTC_ConfigWakeUpClock(RTC_WKUPCLK_CK_SPRE_16BITS);          <span class="comment">// 注意：只能设置一次，否则会有异常，不能自动唤醒导致卡死</span></span><br><span class="line">		rtc_date_params_set(&amp;RTC_DateDefault);</span><br><span class="line">		rtc_time_params_set(&amp;RTC_TimeDefault);</span><br><span class="line">		BKP_WriteBkpData(BKP_DAT1, USER_WRITE_BKP_DAT1_DATA);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		logDebug(<span class="string">&quot;RTC is haven configured.... &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	wakeup_exti_trigger_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_auto_wakeup_set</span><span class="params">(<span class="type">uint8_t</span> seconds)</span></span><br><span class="line">&#123;</span><br><span class="line">    RTC_SetWakeUpCounter(seconds);</span><br><span class="line">    EXTI20_RTCWKUP_Configuration(<span class="literal">true</span>);</span><br><span class="line">    RTC_ConfigInt(RTC_INT_WUT, ENABLE);</span><br><span class="line">    RTC_EnableWakeUp(ENABLE);</span><br><span class="line">    exti20_alarm_config_it(<span class="literal">true</span>);</span><br><span class="line">    rtc_wakeup_all_config_it(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="gcc优化等级和标准库问题"><a href="#gcc优化等级和标准库问题" class="headerlink" title="gcc优化等级和标准库问题"></a>gcc优化等级和标准库问题</h3><ul>
<li><code>O0</code>级优化低功耗会跑飞，<code>Os</code>级优化低功耗就是正常的，原因待查，下一步<strong>先查打印函数</strong>, <strong>不是打印函数原因</strong>，已验证。</li>
<li><code>arm-none-eabi-gcc</code>的<code>nano</code>系统：添加<code>--specs=nano.specs</code> 打印不了<code>float</code>和<code>64位</code>整数，但是程序缩小<code>20K</code>左右; 但是标准库跑不了低功耗，原因为<strong>串口打印函数问题</strong>, 待分析。</li>
</ul>
<br>

<h2 id="自写printf函数"><a href="#自写printf函数" class="headerlink" title="自写printf函数"></a>自写printf函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lp_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];  			<span class="comment">// 定义一个足够大的缓冲区</span></span><br><span class="line">    <span class="type">int</span> len, size;</span><br><span class="line"></span><br><span class="line">    va_start(args, format);  	<span class="comment">// 初始化args</span></span><br><span class="line">    len = vsnprintf(buffer, <span class="keyword">sizeof</span>(buffer), format, args);  <span class="comment">// 格式化字符串到buffer</span></span><br><span class="line">    va_end(args);  				<span class="comment">// 清理args</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">uint8_t</span> *p_buff = (<span class="type">uint8_t</span> *)buffer;</span><br><span class="line">	size = len;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 硬件适配层</span></span><br><span class="line">	USART_ClrFlag(USART1, USART_FLAG_TXC);</span><br><span class="line">	<span class="keyword">while</span>(len --)</span><br><span class="line">	&#123;</span><br><span class="line">		USART_SendData(USART1, *p_buff);</span><br><span class="line">        <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXC) == RESET);</span><br><span class="line">		p_buff ++;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> size;  <span class="comment">// 返回发送的字符数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>问题点：使用<code>arm-none-eabi-gcc</code>环境在<code>makefile</code>中使用<code>--specs=nano.specs</code>选项，使用的是<code>newlib-nano</code>库，<code>lp_printf</code>进入低功耗后初始化打印正常；使用的是标准库<code>newlib</code>库，<code>lp_printf</code>进入低功耗后初始化打印异常。调试发现在使用<code>vsnprintf</code>函数时会跑飞。</li>
<li>改进方法：将<code>vsnprintf</code>函数替换成<code>rt_vsnprintf</code>函数。</li>
<li>分析原因：<ul>
<li>可能问题点：在进入低功耗模式时，系统会关闭一些外设和资源以节省能量。当退出低功耗模式时，需要正确地恢复这些资源。如果 <code>newlib</code> 中的某些功能在资源恢复过程中存在问题，可能会导致程序异常。</li>
<li><code>newlib-nano</code> 由于实现简单，可能在资源恢复方面更加稳定，不会受到低功耗模式的影响。</li>
</ul>
</li>
<li>解决方法：（感觉无用）<ul>
<li>检查资源管理：确保在进入和退出低功耗模式时，所有资源都被正确管理。特别是对于标准库中使用的资源，如内存分配器等，确保它们在低功耗模式下能够正常工作。</li>
<li>使用线程安全的实现：如果在多线程环境中使用标准库，确保所有函数都是线程安全的，以避免在低功耗模式下出现并发问题。</li>
</ul>
</li>
</ul>
<br>

<h2 id="rt-thread-互斥量问题"><a href="#rt-thread-互斥量问题" class="headerlink" title="rt-thread 互斥量问题"></a>rt-thread 互斥量问题</h2><p><strong>问题点：</strong></p>
<ul>
<li>低优先级任务在打印时，高优先级任务也有打印，导致打印函数重入互斥量自锁。</li>
</ul>
<p><strong>解决方法：</strong></p>
<ul>
<li><strong>使用递归互斥量</strong>：在<code>FreeRTOS</code>中，可以使用<code>xSemaphoreCreateRecursiveMutex</code>来创建递归互斥量，并使用<code>xSemaphoreTakeRecursive</code>和<code>xSemaphoreGiveRecursive</code>来获取和释放互斥量, <code>rtthread</code>系统待验证。</li>
<li><strong>优先级继承</strong>：当低优先级任务持有互斥量时，如果高优先级任务试图获取同一个互斥量，可以通过优先级继承机制来避免死锁。这样，低优先级任务的优先级会临时提升，以减少高优先级任务的等待时间。</li>
<li><strong>设计合理的资源访问顺序</strong>：确保系统中的所有任务以相同的顺序获取互斥量，这可以避免循环等待，从而减少死锁的可能性。</li>
</ul>
<br>

<p><strong>项目中的解决方案及代码</strong>：</p>
<ul>
<li><code>shell</code>是空闲任务，线程优先级最低。</li>
<li><code>brains_electric_data_send(&amp;send_data, sizeof(send_data));</code>函数会传递队列，接收队列任务优先级要比<code>shell</code>线程优先级高。</li>
<li>在这里进入打印时<code>不设上锁等待时间</code>，会直接重入。</li>
<li><strong>影响</strong>：有部分打印会被覆盖，不显示。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> LOG_USING_LOCK</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">logMutex</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">userLogLock</span><span class="params">(Log *<span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//互斥量在低优先级使用的时候，切到高优先级任务会导致死锁，不能用RT_WAITING_FOREVER</span></span><br><span class="line">    rt_mutex_take(&amp;logMutex, rt_tick_from_millisecond(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">userLogUnlock</span><span class="params">(Log *<span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_mutex_release(&amp;logMutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在shell中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">brains_electric_transmit_en</span><span class="params">(<span class="type">bool</span> en)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> send_data = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(en)</span><br><span class="line">	&#123;</span><br><span class="line">		brains_electric_onoff = <span class="literal">true</span>;</span><br><span class="line">		send_data = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">		brains_electric_data_send(&amp;send_data, <span class="keyword">sizeof</span>(send_data));</span><br><span class="line">		<span class="comment">// logVerbose(&quot;brains_electric_serial_tx -&gt; [%c]&quot;, send_data);</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		rt_timer_stop(&amp;brains_timer_stimer);</span><br><span class="line">		rt_timer_stop(&amp;brains_wait_stimer);</span><br><span class="line">		send_data = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">		brains_electric_data_send(&amp;send_data, <span class="keyword">sizeof</span>(send_data));</span><br><span class="line">		<span class="comment">// logVerbose(&quot;brains_electric_serial_tx -&gt; [%c]&quot;, send_data);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC)|SHELL_CMD_DISABLE_RETURN, brains_electric_transmit_en, brains_electric_transmit_en,brains_electric_transmit_en);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="arm-none-eabi-gcc打印不了浮点和64位数据问题分析"><a href="#arm-none-eabi-gcc打印不了浮点和64位数据问题分析" class="headerlink" title="arm-none-eabi-gcc打印不了浮点和64位数据问题分析"></a>arm-none-eabi-gcc打印不了浮点和64位数据问题分析</h2><p><strong>问题点</strong>：</p>
<ul>
<li><code>arm-none-eabi-gcc</code>环境打印不了浮点和64位数据，测试发现在<code>makefile</code>中使用<code>--specs=nano.specs</code>选项，使用的是<code>nano</code>库而非标准库。</li>
</ul>
<p><strong>解决方法</strong>：</p>
<ul>
<li>尝试添加<code>LDFLAGS += -lc -lrdimon -u _printf_float</code>，程序会跑飞。</li>
<li>将<code>--specs=nano.specs</code>去掉，默认使用标准库就可以打印浮点和64位数据了。</li>
</ul>
<h2 id="letter-shell调试问题"><a href="#letter-shell调试问题" class="headerlink" title="letter shell调试问题"></a>letter shell调试问题</h2><ul>
<li>使用<code>letter shell</code>调试时间戳转换函数时遇到问题，设置时间对不上，代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将UTC的Unix时间戳转换为RTC时间和日期</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rtc_utc_timestamp_set</span><span class="params">(<span class="type">time_t</span> timestamp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tm</span> =</span> gmtime(&amp;timestamp);</span><br><span class="line">    RTC_DateType RTC_Date;</span><br><span class="line">    RTC_TimeType RTC_Time;</span><br><span class="line"></span><br><span class="line">    RTC_Date.Year = tm-&gt;tm_year - <span class="number">100</span>;    <span class="comment">// 年份从1900开始计算</span></span><br><span class="line">    RTC_Date.Month = tm-&gt;tm_mon + <span class="number">1</span>;      <span class="comment">// 月份从0开始计算</span></span><br><span class="line">    RTC_Date.Date = tm-&gt;tm_mday;</span><br><span class="line">    RTC_Date.WeekDay = (tm-&gt;tm_wday == <span class="number">0</span>) ? <span class="number">7</span> : tm-&gt;tm_wday;   <span class="comment">// 星期几，tm结构体是0-6，0是星期天; stm32的RTC返回的是1-7</span></span><br><span class="line">    RTC_Time.Hours = tm-&gt;tm_hour;</span><br><span class="line">    RTC_Time.Minutes = tm-&gt;tm_min;</span><br><span class="line">    RTC_Time.Seconds = tm-&gt;tm_sec;</span><br><span class="line">    RTC_Time.H12 = RTC_AM_H12;</span><br><span class="line"></span><br><span class="line">    rtc_date_params_set(&amp;RTC_Date);</span><br><span class="line">    rtc_time_params_set(&amp;RTC_Time);</span><br><span class="line">&#125;</span><br><span class="line">SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC)|SHELL_CMD_DISABLE_RETURN, utc_timestamp_set, rtc_utc_timestamp_set, rtc_utc_timestamp_set);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将UTC的Unix时间戳转换为本地RTC时间和日期</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_local_timestamp_set</span><span class="params">(<span class="type">time_t</span> timestamp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> utc_timestamp = timestamp + <span class="number">8</span> * <span class="number">3600</span>;    <span class="comment">// 本地时间比UTC时间快8小时，UTC时间要加上8小时</span></span><br><span class="line">    rtc_utc_timestamp_set(utc_timestamp);</span><br><span class="line">&#125;</span><br><span class="line">SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC)|SHELL_CMD_DISABLE_RETURN, local_timestamp_set, rtc_local_timestamp_set, rtc_local_timestamp_set);</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li>查阅<code>letter shell</code>相关资料发现，参数只支持<code>char(字符)</code>，<code>char(数字)</code>，<code>short(数字)</code>，<code>int(数字)</code>，<code>char *(字符串)</code>，<code>pointer</code>这几个数据类型，并不支持<code>time_t</code>，所以敲<code>shell</code>指令入参的时候，会把数据强制转为<code>int</code>类型，而在使用<code>gmtime(&amp;timestamp)</code>转换的时候，<code>timestamp</code>是需要为<code>time_t</code>类型的，所以做出如下修改：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将UTC的Unix时间戳转换为RTC时间和日期</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rtc_utc_timestamp_set</span><span class="params">(<span class="type">int</span> timestamp)</span>       <span class="comment">// 改为int类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> utc_timestamp = (<span class="type">time_t</span>)timestamp;          <span class="comment">// 强制转换为time_t类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tm</span> =</span> gmtime(&amp;utc_timestamp);</span><br><span class="line">    RTC_DateType RTC_Date;</span><br><span class="line">    RTC_TimeType RTC_Time;</span><br><span class="line"></span><br><span class="line">    RTC_Date.Year = tm-&gt;tm_year - <span class="number">100</span>;    <span class="comment">// 年份从1900开始计算</span></span><br><span class="line">    RTC_Date.Month = tm-&gt;tm_mon + <span class="number">1</span>;      <span class="comment">// 月份从0开始计算</span></span><br><span class="line">    RTC_Date.Date = tm-&gt;tm_mday;</span><br><span class="line">    RTC_Date.WeekDay = (tm-&gt;tm_wday == <span class="number">0</span>) ? <span class="number">7</span> : tm-&gt;tm_wday;   <span class="comment">// 星期几，tm结构体是0-6，0是星期天; stm32的RTC返回的是1-7</span></span><br><span class="line">    RTC_Time.Hours = tm-&gt;tm_hour;</span><br><span class="line">    RTC_Time.Minutes = tm-&gt;tm_min;</span><br><span class="line">    RTC_Time.Seconds = tm-&gt;tm_sec;</span><br><span class="line">    RTC_Time.H12 = RTC_AM_H12;</span><br><span class="line"></span><br><span class="line">    rtc_date_params_set(&amp;RTC_Date);</span><br><span class="line">    rtc_time_params_set(&amp;RTC_Time);</span><br><span class="line">&#125;</span><br><span class="line">SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC)|SHELL_CMD_DISABLE_RETURN, utc_timestamp_set, rtc_utc_timestamp_set, rtc_utc_timestamp_set);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将UTC的Unix时间戳转换为本地RTC时间和日期</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_local_timestamp_set</span><span class="params">(<span class="type">time_t</span> timestamp)</span>      <span class="comment">// 无需改为int类型能通过?</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> utc_timestamp = timestamp + <span class="number">8</span> * <span class="number">3600</span>;    <span class="comment">// 本地时间比UTC时间快8小时，UTC时间要加上8小时</span></span><br><span class="line">    rtc_utc_timestamp_set(utc_timestamp);           <span class="comment">// 调用UTC时间戳转换为RTC时间和日期的函数</span></span><br><span class="line">&#125;</span><br><span class="line">SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC)|SHELL_CMD_DISABLE_RETURN, local_timestamp_set, rtc_local_timestamp_set, rtc_local_timestamp_set);</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h2 id="串口相关问题"><a href="#串口相关问题" class="headerlink" title="串口相关问题"></a>串口相关问题</h2><h3 id="不带数据线USB的D-和D-短接"><a href="#不带数据线USB的D-和D-短接" class="headerlink" title="不带数据线USB的D+和D-短接"></a>不带数据线USB的D+和D-短接</h3><ul>
<li>添加<code>shell.c</code>文件中的判断，可能会出现恢复后<code>shell</code>交互键入数据延后：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHELL_SHUTDOWN_CNTS		50</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> shell_shutdown = <span class="number">0</span>;			<span class="comment">//TX RX短接处理</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> shell_shutdown_cnts = <span class="number">0</span>;					<span class="comment">//TX RX短接处理cnts次数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shellExec</span><span class="params">(Shell *shell)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (shell-&gt;status.isChecked)</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (command != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            shellRunCommand(shell, command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            shell_shutdown_cnts ++;											<span class="comment">//shell_shutdown bug 解决</span></span><br><span class="line">            <span class="keyword">if</span>(shell_shutdown_cnts &gt; SHELL_SHUTDOWN_CNTS)</span><br><span class="line">                shell_shutdown = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            shellWriteString(shell, shellText[SHELL_TEXT_CMD_NOT_FOUND]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        shellCheckPassword(shell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shellInsertByte</span><span class="params">(Shell *shell, <span class="type">char</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 判断输入数据是否过长 */</span></span><br><span class="line">    <span class="keyword">if</span> (shell-&gt;parser.length &gt;= shell-&gt;parser.bufferSize - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		shell_shutdown_cnts ++;											    <span class="comment">//超长次数过多触发shell不接受标志</span></span><br><span class="line">		<span class="keyword">if</span>(shell_shutdown_cnts &gt; SHELL_SHUTDOWN_CNTS)</span><br><span class="line">			shell_shutdown = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">        shellWriteString(shell, shellText[SHELL_TEXT_CMD_TOO_LONG]);</span><br><span class="line">        shellWritePrompt(shell, <span class="number">1</span>);</span><br><span class="line">        shellWriteString(shell, shell-&gt;parser.buffer);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shellWriteCommandHelp</span><span class="params">(Shell *shell, <span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    ShellCommand *command = shellSeekCommand(shell,</span><br><span class="line">                                             cmd,</span><br><span class="line">                                             shell-&gt;commandList.base,</span><br><span class="line">                                             <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (command)</span><br><span class="line">    &#123;</span><br><span class="line">        shellWriteString(shell, shellText[SHELL_TEXT_HELP_HEADER]);</span><br><span class="line">        shellWriteString(shell, shellGetCommandName(command));</span><br><span class="line">        shellWriteString(shell, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        shellWriteString(shell, shellGetCommandDesc(command));</span><br><span class="line">        shellWriteString(shell, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">		shell_shutdown_cnts ++;											<span class="comment">//shell_shutdown bug 解决</span></span><br><span class="line">		<span class="keyword">if</span>(shell_shutdown_cnts &gt; SHELL_SHUTDOWN_CNTS)</span><br><span class="line">			shell_shutdown = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">        shellWriteString(shell, shellText[SHELL_TEXT_CMD_NOT_FOUND]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief shell 任务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param param 参数(shell对象)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shellTask</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    Shell *shell = (Shell *)param;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHELL_TASK_WHILE == 1</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(shell_shutdown)									<span class="comment">//shell_shutdown true 退出, 可外部调用shell_shutdown置为false重新启用</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">if</span> (shell-&gt;read &amp;&amp; shell-&gt;read(&amp;data, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            shellHandler(shell, data);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHELL_TASK_WHILE == 1</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="串口回环后shell交互键入数据延后解决"><a href="#串口回环后shell交互键入数据延后解决" class="headerlink" title="串口回环后shell交互键入数据延后解决"></a>串口回环后shell交互键入数据延后解决</h3><ul>
<li><p>使用<code>letter shell</code>的解决方法：(<strong>依然会复现, 已定位是环形缓冲区的问题</strong>)</p>
</li>
<li><p>修改<code>shell.c</code>文件中的部分函数，清空缓存区长度：(未解决)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shell.c 文件 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shellInsertByte</span><span class="params">(Shell *shell, <span class="type">char</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 判断输入数据是否过长 */</span></span><br><span class="line">    <span class="keyword">if</span> (shell-&gt;parser.length &gt;= shell-&gt;parser.bufferSize - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        shellWriteString(shell, shellText[SHELL_TEXT_CMD_TOO_LONG]);    <span class="comment">//可以注释掉，也以免一直打印？</span></span><br><span class="line">        shellWritePrompt(shell, <span class="number">1</span>);</span><br><span class="line">        shell-&gt;parser.buffer[shell-&gt;parser.length] = <span class="number">0</span>;                 <span class="comment">// + 增加清空缓存区长度</span></span><br><span class="line">        <span class="comment">// shellWriteString(shell, shell-&gt;parser.buffer);               //不打印显示超长数据</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shellWriteCommandHelp</span><span class="params">(Shell *shell, <span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    ShellCommand *command = shellSeekCommand(shell,</span><br><span class="line">                                             cmd,</span><br><span class="line">                                             shell-&gt;commandList.base,</span><br><span class="line">                                             <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (command)</span><br><span class="line">    &#123;</span><br><span class="line">        shellWriteString(shell, shellText[SHELL_TEXT_HELP_HEADER]);</span><br><span class="line">        shellWriteString(shell, shellGetCommandName(command));</span><br><span class="line">        shellWriteString(shell, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        shellWriteString(shell, shellGetCommandDesc(command));</span><br><span class="line">        shellWriteString(shell, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        shellWriteString(shell, shellText[SHELL_TEXT_CMD_NOT_FOUND]);</span><br><span class="line">        shell-&gt;parser.buffer[shell-&gt;parser.length] = <span class="number">0</span>;                 <span class="comment">// + 缓存字符串清零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="letter-shell初始化优化"><a href="#letter-shell初始化优化" class="headerlink" title="letter shell初始化优化"></a>letter shell初始化优化</h3><ul>
<li><code>letter shell</code>新增初始化设置打印等级参数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">User_Shell_Init</span><span class="params">(<span class="type">uint8_t</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">serial_configure</span> <span class="title">config</span> =</span> EC_SERIAL_CONFIG_DEFAULT;</span><br><span class="line">    config.baud_rate = BAUD_RATE_921600;</span><br><span class="line">    drv_usart_init(ESERIAL_1, ESERIAL_MODE_DMA_RX | ESERIAL_MODE_DMA_TX, &amp;config);</span><br><span class="line"></span><br><span class="line">    shell.write = User_Shell_Write;</span><br><span class="line">	shell.read = User_Shell_Read;</span><br><span class="line">    shellInit(&amp;shell, shell_buffer, <span class="keyword">sizeof</span>(shell_buffer));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(level &gt; LOG_ALL)</span><br><span class="line">    &#123;</span><br><span class="line">        uartLog.level = LOG_ALL;</span><br><span class="line">    &#125;</span><br><span class="line">	logRegister(&amp;uartLog, &amp;shell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="串口升级后清屏指令问题"><a href="#串口升级后清屏指令问题" class="headerlink" title="串口升级后清屏指令问题"></a>串口升级后清屏指令问题</h3><ul>
<li>串口升级后清屏指令打不全导致字符重叠，<code>letter shell</code>优化代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *shellText[] =</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    [SHELL_TEXT_CLEAR_CONSOLE] = </span><br><span class="line">        <span class="string">&quot;\033[2J\033[1H&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改为：</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *shellText[] =</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    [SHELL_TEXT_CLEAR_CONSOLE] = </span><br><span class="line">        <span class="string">&quot;\r\n\033[2J\033[1H&quot;</span>,                   <span class="comment">// 添加\r\n字符保证终端不会粘连识别</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h2 id="secure-CRT问题"><a href="#secure-CRT问题" class="headerlink" title="secure CRT问题"></a>secure CRT问题</h2><ul>
<li>在线升级后打印出不完整清屏指令，显示残留<code>2J</code>，不会清屏。</li>
<li>测试两块板，一块有这个问题，另一块没有问题</li>
</ul>
<h2 id="n32l406的ADC跑飞"><a href="#n32l406的ADC跑飞" class="headerlink" title="n32l406的ADC跑飞"></a>n32l406的ADC跑飞</h2><ul>
<li>问题：<code>n32l406</code>的<code>ADC</code>跑飞，代码复用以前可以跑的。</li>
<li>解决：低级错误，<code>ADC</code>的<code>IO</code>口初始化<code>PORT</code>和<code>PIN</code>写反，<code>CmBacktrace</code>排查出问题。</li>
</ul>
<h2 id="n32l406的不定时跑飞"><a href="#n32l406的不定时跑飞" class="headerlink" title="n32l406的不定时跑飞"></a>n32l406的不定时跑飞</h2><ul>
<li>以下是跑飞后<code>cmbacktrace</code>追踪的<code>pc</code>指针及追踪函数。</li>
<li>可能是串口<code>RX</code>干扰问题：(问题定位软件问题或者硬件问题)。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xuan@DESKTOP-A52B6V9:~/work/n5/code/app$ addr2line -e app.elf -a -f <span class="number">080160</span>c2 <span class="number">08013f</span>cc <span class="number">080140f</span>c <span class="number">080141</span>d2 <span class="number">08014252</span> <span class="number">0800</span>a4b6 <span class="number">08009092</span> <span class="number">0x080160c2</span> fault_test_by_div0 /home/xuan/work/n5/code/app/components/cm_backtrace/fault_test.c:<span class="number">38</span> <span class="number">0x08013fcc</span> shellRunCommand /home/xuan/work/n5/code/app/components/letter_shell/shell.c:<span class="number">1264</span> <span class="number">0x080140fc</span> shellEnter /home/xuan/work/n5/code/app/components/letter_shell/shell.c:<span class="number">1704</span> <span class="number">0x080141d2</span> shellHandler /home/xuan/work/n5/code/app/components/letter_shell/shell.c:<span class="number">1831</span> <span class="number">0x08014252</span> shellTask /home/xuan/work/n5/code/app/components/letter_shell/shell.c:<span class="number">1905</span> <span class="number">0x0800a4b6</span> main /home/xuan/work/n5/code/app/application/main.c:<span class="number">37</span> <span class="number">0x08009092</span> LoopFillZerobss /home/xuan/work/n5/code/app/CMSIS/device/startup/startup_n32l40x_gcc.s:<span class="number">113</span></span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xuan@DESKTOP-A52B6V9:~/work/n5/code/app$ addr2line -e app.elf -a -f <span class="number">6f</span>6d656c <span class="number">080131</span>aa <span class="number">08010</span>a62 <span class="number">080131</span>aa <span class="number">080140</span>c0 <span class="number">080141f</span>0 <span class="number">080142</span>c6 <span class="number">0801434</span>c <span class="number">0800</span>a4b6 <span class="number">08009092</span></span><br><span class="line"><span class="number">0x6f6d656c</span></span><br><span class="line">??</span><br><span class="line">??:<span class="number">0</span></span><br><span class="line"><span class="number">0x080131aa</span></span><br><span class="line">logHexDump</span><br><span class="line">/home/xuan/work/n5/code/app/components/letter_shell/<span class="built_in">log</span>.c:<span class="number">243</span></span><br><span class="line"><span class="number">0x08010a62</span></span><br><span class="line">board_battery_ntc_get_temp_thres_down_work</span><br><span class="line">/home/xuan/work/n5/code/app/user/user_board.c:<span class="number">678</span></span><br><span class="line"><span class="number">0x080131aa</span></span><br><span class="line">logHexDump</span><br><span class="line">/home/xuan/work/n5/code/app/components/letter_shell/<span class="built_in">log</span>.c:<span class="number">243</span></span><br><span class="line"><span class="number">0x080140c0</span></span><br><span class="line">shellRunCommand</span><br><span class="line">/home/xuan/work/n5/code/app/components/letter_shell/shell.c:<span class="number">1264</span></span><br><span class="line"><span class="number">0x080141f0</span></span><br><span class="line">shellEnter</span><br><span class="line">/home/xuan/work/n5/code/app/components/letter_shell/shell.c:<span class="number">1704</span></span><br><span class="line"><span class="number">0x080142c6</span></span><br><span class="line">shellHandler</span><br><span class="line">/home/xuan/work/n5/code/app/components/letter_shell/shell.c:<span class="number">1831</span></span><br><span class="line"><span class="number">0x0801434c</span></span><br><span class="line">shellTask</span><br><span class="line">/home/xuan/work/n5/code/app/components/letter_shell/shell.c:<span class="number">1905</span></span><br><span class="line"><span class="number">0x0800a4b6</span></span><br><span class="line">main</span><br><span class="line">/home/xuan/work/n5/code/app/application/main.c:<span class="number">37</span></span><br><span class="line"><span class="number">0x08009092</span></span><br><span class="line">LoopFillZerobss</span><br><span class="line">/home/xuan/work/n5/code/app/CMSIS/device/startup/startup_n32l40x_gcc.s:<span class="number">113</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改方法一：软件修改<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ec32_msp_usart_init</span><span class="params">(<span class="type">void</span> *Instance)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitType GPIO_InitStructure;</span><br><span class="line">    USART_Module *USARTx = (USART_Module *)Instance;</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct(&amp;GPIO_InitStructure);</span><br><span class="line">	EC_APBxClkCmd_AFIO(EC_PERIPHClk_AFIO,ENABLE);                  <span class="comment">//时钟复用</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BSP_USING_UART1</span></span><br><span class="line">    <span class="keyword">if</span>(USART1 == USARTx)</span><br><span class="line">    &#123;</span><br><span class="line">        RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_USART1,ENABLE);</span><br><span class="line">        RCC_EnableAPB2PeriphClk(EC_USART1_RCC_GPIOx,ENABLE);</span><br><span class="line"></span><br><span class="line">        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">        GPIO_InitStructure.GPIO_Alternate =  EC_USART1_Tx_GPIO_AF;</span><br><span class="line">        GPIO_InitStructure.Pin = EC_USART1_TxPin;</span><br><span class="line">        GPIO_InitPeripheral(EC_USART1_GPIO, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">        GPIO_InitStructure.GPIO_Alternate =  EC_USART1_Rx_GPIO_AF;</span><br><span class="line">        GPIO_InitStructure.Pin = EC_USART1_RxPin;</span><br><span class="line">        GPIO_InitStructure.GPIO_Pull = GPIO_Pull_Up;                       <span class="comment">// 添加RX上拉</span></span><br><span class="line">        GPIO_InitPeripheral(EC_USART1_GPIO, &amp;GPIO_InitStructure);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>MCU</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown小贴士</title>
    <url>/2024/02/19/Markdown%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
    <content><![CDATA[<h3 id="Markdown-的基本语法"><a href="#Markdown-的基本语法" class="headerlink" title="Markdown 的基本语法"></a>Markdown 的基本语法</h3><p>Markdown 的语法非常简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。以下是一些常用的 Markdown 标记符号：</p>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题	
</code></pre>
<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><pre><code>普通文本
**加粗文本**
*斜体文本*
**~删除线文本~**
</code></pre>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><pre><code>* 无序列表
1. 有序列表
    * 嵌套列表
</code></pre>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><pre><code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h4 id="文本中代码高亮"><a href="#文本中代码高亮" class="headerlink" title="文本中代码高亮"></a>文本中代码高亮</h4><pre><code>使用`printf(&quot;Hello, world!\n&quot;);`函数进行打印
</code></pre>
<p>效果：使用<code>printf(&quot;Hello, world!\n&quot;);</code>函数进行打印</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><strong>链接文本</strong>: <a href="https://www.example.com/">https://www.example.com</a></p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><pre><code>网络地址: ![这是一张示例图片](https://www.example.com/example.png)
本地文件路径：![这是一张示例图片](../pictures/这是一张示例图片.png)
图片链接跳转: ![这是一张示例图片](example.png) &#123;link=https://www.example.com/&#125;
图片标题: ![这是一张示例图片](example.png) &#123;title=这是一张示例图片&#125;
图片居中: ![这是一张示例图片](example.png) &#123;align=center&#125;

示例：
![这是一张示例图片](example.png)
![这是一张 200x100 像素的图片](example.png) &#123;width=200 height=100&#125;
![这是一张居中的图片](example.png) &#123;align=center&#125;
![点击图片跳转到 https://www.example.com/](example.png) &#123;link=https://www.example.com/&#125;
![这是一张示例图片](example.png) &#123;title=这是一张示例图片&#125;
</code></pre>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><table>
<thead>
<tr>
<th>头部1</th>
<th>头部2</th>
<th>头部3</th>
</tr>
</thead>
<tbody><tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
<tr>
<td>内容4</td>
<td>内容5</td>
<td>内容6</td>
</tr>
</tbody></table>
<h3 id="Markdown-的应用"><a href="#Markdown-的应用" class="headerlink" title="Markdown 的应用"></a>Markdown 的应用</h3><pre><code>博客文章
技术文档
README 文件
演示文稿
电子书
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>Markdown 是一种易于学习和使用的标记语言，非常适合编写各种文档。如果您还没有使用过 Markdown，建议您尝试一下。
</code></pre>
<p>以下是 Markdown 官方教学网站：<br><a href="https://markdown.com.cn/basic-syntax/headings.html">Markdown 官方网站</a></p>
]]></content>
      <categories>
        <category>文本编辑工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>CmBacktrace移植</title>
    <url>/2024/04/19/CmBacktrace%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<h2 id="CmBacktrace简介"><a href="#CmBacktrace简介" class="headerlink" title="CmBacktrace简介"></a>CmBacktrace简介</h2><ul>
<li>支持断言（assert）和故障（Hard Fault）</li>
<li>故障原因自动诊断</li>
<li>输出错误现场的 函数调用栈</li>
<li>适配 Cortex-M0&#x2F;M3&#x2F;M4&#x2F;M7 MCU；</li>
<li>支持 IAR、KEIL、GCC 编译器；</li>
</ul>
<h2 id="移植步骤"><a href="#移植步骤" class="headerlink" title="移植步骤"></a>移植步骤</h2><p><strong>1. 下载源码</strong></p>
<p><strong>官方源码地址</strong> : <a href="https://github.com/armink/CmBacktrace">https://github.com/armink/CmBacktrace</a><br><strong>示例项目地址</strong> : <a href="https://github.com/XUAN9527/cmbacktrace-demo">https://github.com/XUAN9527/cmbacktrace-demo</a></p>
<p><strong>2. copy源码文件</strong></p>
<p><img src="/../pictures/cmbacktrace%E7%9B%AE%E5%BD%95.png" alt="cmbacktrace目录"></p>
<ul>
<li>添加头文件<code>cm_backtrace.h</code> <code>cmb_cfg.h</code> <code>cmb_def.h</code></li>
<li>添加源文件<code>cm_backtrace.c</code></li>
<li>添加demos文件 <code>demos/non_os/stm32f10x/app/src/fault_test.c</code></li>
</ul>
<p><strong>2.1 添加修改makefile：</strong></p>
<p><strong>方法一</strong>、修改添加<code>fault_handler/gcc/cmb_fault.S</code>为<code>fault_handler/gcc/cmb_fault.s</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ASM_SOURCES =  \</span><br><span class="line">CMSIS/device/startup/startup_n32l40x_gcc.s \</span><br><span class="line">components/cm_backtrace/fault_handler/gcc/cmb_fault.s # 添加这一行</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>、将<code>cmb_fault.S</code>将入<code>makefile</code>编译选项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ASM_SOURCES = CMSIS/device/startup/startup_n32l40x_gcc.s</span><br><span class="line">ASM_SOURCES2 = components/cm_backtrace/fault_handler/gcc/cmb_fault.S	# 此行为新增</span><br><span class="line"></span><br><span class="line"># C源文件、汇编源文件的目标文件路径</span><br><span class="line">C_OBJECTS = $(addprefix $(OUTPUT_DIR)/, $(C_SOURCES:.c=.o))</span><br><span class="line">ASM_OBJECTS = $(addprefix $(OUTPUT_DIR)/, $(ASM_SOURCES:.s=.o)) \</span><br><span class="line">	      $(addprefix $(OUTPUT_DIR)/, $(ASM_SOURCES2:.S=.o))	# 此行为新增</span><br><span class="line"></span><br><span class="line">$(OUTPUT_DIR)/%.o: %.s					</span><br><span class="line">	mkdir -p $(dir $@)</span><br><span class="line">	$(CC) $(INCLUDE) $(CFLAGS) -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(OUTPUT_DIR)/%.o: %.S         # 新增 %.S </span><br><span class="line">	mkdir -p $(dir $@)</span><br><span class="line">	$(CC) $(INCLUDE) $(CFLAGS) -c $&lt; -o $@</span><br></pre></td></tr></table></figure>

<br>

<p><strong>2.2 添加printf重定向：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _write(<span class="type">int</span> fd, <span class="type">char</span>* pBuffer, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> drv_serial_dma_write(ESERIAL_1, pBuffer, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.3 修改文件：</strong></p>
<ul>
<li><p><code>cmb_cfg.h</code>文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CMB_CFG_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CMB_CFG_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* print line, must config by user */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cmb_println(...)  printf(__VA_ARGS__);printf(<span class="string">&quot;\r\n&quot;</span>) <span class="comment">/* e.g., printf(__VA_ARGS__);printf(&quot;\r\n&quot;)  or  SEGGER_RTT_printf(0, __VA_ARGS__);SEGGER_RTT_WriteString(0, &quot;\r\n&quot;)  */</span></span></span><br><span class="line"><span class="comment">/* enable bare metal(no OS) platform */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_USING_BARE_METAL_PLATFORM</span></span><br><span class="line"><span class="comment">/* enable OS platform */</span></span><br><span class="line"><span class="comment">/* #define CMB_USING_OS_PLATFORM */</span></span><br><span class="line"><span class="comment">/* OS platform type, must config when CMB_USING_OS_PLATFORM is enable */</span></span><br><span class="line"><span class="comment">/* #define CMB_OS_PLATFORM_TYPE           CMB_OS_PLATFORM_RTT or CMB_OS_PLATFORM_UCOSII or CMB_OS_PLATFORM_UCOSIII or CMB_OS_PLATFORM_FREERTOS or CMB_OS_PLATFORM_RTX5 */</span></span><br><span class="line"><span class="comment">/* cpu platform type, must config by user */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_CPU_PLATFORM_TYPE   CMB_CPU_ARM_CORTEX_M4       <span class="comment">/* CMB_CPU_ARM_CORTEX_M0 or CMB_CPU_ARM_CORTEX_M3 or CMB_CPU_ARM_CORTEX_M4 or CMB_CPU_ARM_CORTEX_M7 */</span></span></span><br><span class="line"><span class="comment">/* enable dump stack information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_USING_DUMP_STACK_INFO</span></span><br><span class="line"><span class="comment">/* language of print information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_PRINT_LANGUAGE    CMB_PRINT_LANGUAGE_ENGLISH        <span class="comment">/* CMB_PRINT_LANGUAGE_ENGLISH(default) or CMB_PRINT_LANGUAGE_CHINESE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _CMB_CFG_H_ */</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>n32l40x_flash.ld</code>链接文件</p>
<ul>
<li><code>text</code>段开始之前添加 <code>_stext = .;</code> 下面为例程：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Define output sections */</span></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The startup code goes first into FLASH */</span></span><br><span class="line">  .isr_vector :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    KEEP(*(.isr_vector)) <span class="comment">/* Startup code */</span></span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  _stext = .;				<span class="meta"># text段开始之前添加</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The program code and other data goes into FLASH */</span></span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    *(.text)           <span class="comment">/* .text sections (code) */</span></span><br><span class="line">    *(.text*)          <span class="comment">/* .text* sections (code) */</span></span><br><span class="line">    *(.glue_7)         <span class="comment">/* glue arm to thumb code */</span></span><br><span class="line">    *(.glue_7t)        <span class="comment">/* glue thumb to arm code */</span></span><br><span class="line">    *(.eh_frame)</span><br><span class="line"></span><br><span class="line">    KEEP (*(.init))</span><br><span class="line">    KEEP (*(.fini))</span><br></pre></td></tr></table></figure>

<ul>
<li><code>bss</code>段开始之前添加 <code>_sstack = .;</code> 下面为例程：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.bss :</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* This is used by the startup in order to initialize the .bss secion */</span></span><br><span class="line">  _sbss = .;         <span class="comment">/* define a global symbol at bss start */</span></span><br><span class="line">  __bss_start__ = _sbss;</span><br><span class="line">  *(.bss)</span><br><span class="line">  *(.bss*)</span><br><span class="line">  *(COMMON)</span><br><span class="line"></span><br><span class="line">  . = ALIGN(<span class="number">4</span>);</span><br><span class="line">  _ebss = .;         <span class="comment">/* define a global symbol at bss end */</span></span><br><span class="line">  __bss_end__ = _ebss;</span><br><span class="line">&#125; &gt;RAM</span><br><span class="line"></span><br><span class="line">_sstack = .;				<span class="meta"># stack段开始之前添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* User_heap_stack section, used to check that there is enough RAM left */</span></span><br><span class="line">._user_heap_stack :</span><br><span class="line">&#123;</span><br><span class="line">  . = ALIGN(<span class="number">4</span>);</span><br><span class="line">  PROVIDE ( end = . );</span><br><span class="line">  PROVIDE ( _end = . );</span><br><span class="line">  . = . + _Min_Heap_Size;</span><br><span class="line">  . = . + _Min_Stack_Size;</span><br><span class="line">  _estack = .;        <span class="comment">/* end of RAM */</span></span><br><span class="line">  . = ALIGN(<span class="number">4</span>);</span><br><span class="line">&#125; &gt;RAM</span><br></pre></td></tr></table></figure>

<p><strong>2.4 main函数例程：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cm_backtrace.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HARDWARE_VERSION               <span class="string">&quot;V1.0.0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOFTWARE_VERSION               <span class="string">&quot;V0.1.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fault_test_by_unalign</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fault_test_by_div0</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	main_system_init();</span><br><span class="line">	cm_backtrace_init(<span class="string">&quot;CmBacktrace&quot;</span>, HARDWARE_VERSION, SOFTWARE_VERSION);     <span class="comment">// 在开启时钟，打印和看门狗之后就需要初始化</span></span><br><span class="line">	</span><br><span class="line">	fault_test_by_unalign();</span><br><span class="line">	fault_test_by_div0();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译出错后代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Firmware name: CmBacktrace, hardware version: V1<span class="number">.0</span><span class="number">.0</span>, software version: V0<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">Fault on interrupt or bare <span class="title function_">metal</span><span class="params">(no OS)</span> environment</span><br><span class="line">===== Thread <span class="built_in">stack</span> information =====</span><br><span class="line">  addr: <span class="number">20004</span>ec8    data: <span class="number">5</span>a6d79ca</span><br><span class="line">  addr: <span class="number">20004</span>ecc    data: f758b4b7</span><br><span class="line">  addr: <span class="number">20004</span>ed0    data: <span class="number">94</span>cfc3fd</span><br><span class="line">  addr: <span class="number">20004</span>ed4    data: a8ccaa51</span><br><span class="line">  addr: <span class="number">20004</span>ed8    data: <span class="number">61049</span>ca6</span><br><span class="line">  addr: <span class="number">20004</span>edc    data: e4e1b169</span><br><span class="line">  addr: <span class="number">20004</span>ee0    data: b48e100d</span><br><span class="line">  addr: <span class="number">20004</span>ee4    data: c44eb7ea</span><br><span class="line">  addr: <span class="number">20004</span>ee8    data: <span class="number">23</span>d4e51e</span><br><span class="line">  addr: <span class="number">20004</span>eec    data: <span class="number">8527b</span>7c0</span><br><span class="line">  addr: <span class="number">20004</span>ef0    data: fd9d41f7</span><br><span class="line">  addr: <span class="number">20004</span>ef4    data: f539e421</span><br><span class="line">  addr: <span class="number">20004</span>ef8    data: <span class="number">4</span>ad52963</span><br><span class="line">  addr: <span class="number">20004</span>efc    data: <span class="number">4587b</span>423</span><br><span class="line">  addr: <span class="number">20004f</span>00    data: e000ed00</span><br><span class="line">  addr: <span class="number">20004f</span>04    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>08    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>0c    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>10    data: <span class="number">200022</span>cc</span><br><span class="line">  addr: <span class="number">20004f</span>14    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>18    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>1c    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>20    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>24    data: <span class="number">08009093</span></span><br><span class="line">====================================</span><br><span class="line">=================== Registers information ====================</span><br><span class="line">  R0 : <span class="number">20002</span>ee9  R1 : <span class="number">20002e4</span>c  R2 : e000ed14  R3 : <span class="number">2000253</span>c</span><br><span class="line">  R12: <span class="number">0000000</span>a  LR : <span class="number">0800</span>a3b3  PC : <span class="number">080154</span>c2  PSR: <span class="number">61000000</span></span><br><span class="line">==============================================================</span><br><span class="line">Usage fault is caused by attempts to execute an undefined instruction</span><br><span class="line">Show more call <span class="built_in">stack</span> info by run: addr2line -e CmBacktrace.elf -a -f <span class="number">080154</span>c2 <span class="number">0800</span>a3b3 <span class="number">08009092</span></span><br></pre></td></tr></table></figure>

<p><strong>转换为定位代码工具：</strong></p>
<ul>
<li><code>linux</code>环境下输入：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr2line -e app.elf -a -f <span class="number">080154</span>c2 <span class="number">0800</span>a3b2 <span class="number">08009092</span></span><br></pre></td></tr></table></figure>

<p>解释：<code>app.elf</code> 为你的工程编译文件。</p>
<p><strong>数据分析结果：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xuan@DESKTOP-A52B6V9:~/work/n5-mini-s-plus/code/app/build$ addr2line -e app.elf -a -f <span class="number">080154</span>c2 <span class="number">0800</span>a3b2 <span class="number">08009092</span></span><br><span class="line"><span class="number">0x080154c2</span></span><br><span class="line">fault_test_by_unalign</span><br><span class="line">/home/xuan/work/n5-mini-s-plus/code/app/components/cm_backtrace/fault_test.c:<span class="number">18</span></span><br><span class="line"><span class="number">0x0800a3b2</span></span><br><span class="line">main</span><br><span class="line">/home/xuan/work/n5-mini-s-plus/code/app/application/main.c:<span class="number">30</span></span><br><span class="line"><span class="number">0x08009092</span></span><br><span class="line">LoopFillZerobss</span><br><span class="line">/home/xuan/work/n5-mini-s-plus/code/app/CMSIS/device/startup/startup_n32l40x_gcc.s:<span class="number">113</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>错误追踪</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cortex-M</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下开发单片机</title>
    <url>/2024/03/28/Linux%E4%B8%8B%E5%BC%80%E5%8F%91%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="Ubuntu-Wsl环境搭建"><a href="#Ubuntu-Wsl环境搭建" class="headerlink" title="Ubuntu Wsl环境搭建"></a>Ubuntu Wsl环境搭建</h2><h3 id="Windows10系统安装子系统Wsl"><a href="#Windows10系统安装子系统Wsl" class="headerlink" title="Windows10系统安装子系统Wsl"></a>Windows10系统安装子系统Wsl</h3><p><strong>1. 通过 Microsoft Store 安装</strong></p>
<ul>
<li>打开 Microsoft Store。</li>
<li>搜索 “适用于 Linux 的 Windows 子系统”。</li>
<li>选择 “Ubuntu” 或您喜欢的其他 Linux 发行版。</li>
<li>点击 “获取”。</li>
<li>安装完成后，点击 “启动”。</li>
</ul>
<p><strong>2. 通过命令行</strong></p>
<ul>
<li><p>打开 PowerShell 或 命令提示符 以管理员身份运行。</p>
</li>
<li><p>输入以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启您的计算机。</p>
</li>
<li><p>安装完成后，您可以通过以下命令启动 WSL：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ul>
<li>WSL 需要 Windows 10 版本 1709 或更高版本。</li>
<li>您可以通过以下命令检查您的 Windows 版本：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">winver</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果您使用的是 Windows 10 家庭版，您需要启用 “<strong>适用于 Linux 的 Windows 子系统</strong>” 功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">控制面板-&gt;程序和功能-&gt;启用或关闭 Windows 功能-&gt;适用于 Linux 的 Windows 子系统-&gt;确定</span><br></pre></td></tr></table></figure>
</li>
<li><p>您可以通过以下命令启用 “<strong>适用于 Linux 的 Windows 子系统</strong>” 功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启您的计算机后，您就可以通过上述方法安装 WSL 了。</p>
</li>
</ul>
<p>安装 Windows Terminal</p>
<h3 id="编译环境配置"><a href="#编译环境配置" class="headerlink" title="编译环境配置"></a>编译环境配置</h3><ul>
<li><p><code>gcc-arm-none-eabi</code>工具链安装</p>
<ul>
<li>手动安装：<a href="https://developer.arm.com/downloads/-/gnu-rm">官方链接地址</a> 下载所需版本；  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install bzip2</span><br><span class="line">sudo tar -xvf ~/n32_gcc/software_package/gcc-arm-none-eabi-9-2019-q4-major-x86_64-linux.tar.bz2 -C ~/n32_gcc</span><br></pre></td></tr></table></figure></li>
<li>自动安装：<code>sudo apt-get install gcc-arm-none-eabi</code></li>
<li>打开 <code>~/.bashrc</code></li>
<li>添加<code>export PATH=$PATH:~/n32_gcc/gcc-arm-none-eabi-9-2019-q4-major/bin</code></li>
<li>添加<code>alias open-file=&#39;explorer.exe .&#39;</code></li>
<li>使能用户环境变量<code>source ~/.bashrc</code></li>
</ul>
</li>
<li><p>Make</p>
<ul>
<li><code>sudo apt-get install make</code></li>
</ul>
</li>
</ul>
<h3 id="Winodows-Gcc-Make-环境搭建"><a href="#Winodows-Gcc-Make-环境搭建" class="headerlink" title="Winodows Gcc + Make 环境搭建"></a>Winodows Gcc + Make 环境搭建</h3><ul>
<li>安装software_package目录下的<code>gcc-arm-none-eabi-9-2019-q4-major-win32-sha2.exe</code>和<code>make-3.81.exe</code></li>
<li>分别将其安装目录下的 <code>./bin</code>添加到系统环境变量，重启生效</li>
<li>复制裸机工程至Windows下，修改部分Makefile的linux指令以适配Windows即可</li>
</ul>
<h3 id="裸机工程编译"><a href="#裸机工程编译" class="headerlink" title="裸机工程编译"></a>裸机工程编译</h3><ul>
<li>cd n32g452_gcc</li>
<li>make</li>
</ul>
<br>

<h2 id="环境配置及工具链"><a href="#环境配置及工具链" class="headerlink" title="环境配置及工具链"></a>环境配置及工具链</h2><h3 id="打开新终端-bashrc不会自动刷新"><a href="#打开新终端-bashrc不会自动刷新" class="headerlink" title="打开新终端 ~&#x2F;.bashrc不会自动刷新"></a>打开新终端 ~&#x2F;.bashrc不会自动刷新</h3><p>解决linux每次打开新终端都要重新<code>source ~/.bashrc</code>问题<br>执行以下代码：</p>
<pre><code>vi ~/.bash_profile
</code></pre>
<p>有可能此文件是空白新建的，无所谓。然后在此文件末尾加入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ];then</span><br><span class="line">source ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>然后<code>:wq</code>保存即可。<br>此时打开新终端可以自动执行<code>source ~/.bashrc</code></p>
<br>

<h3 id="arm-none-eabi-gcc工具链问题"><a href="#arm-none-eabi-gcc工具链问题" class="headerlink" title="arm-none-eabi-gcc工具链问题"></a>arm-none-eabi-gcc工具链问题</h3><ul>
<li>arm-none-eabi-gcc工具链需加入用户变量：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">export PATH=/home/xuan/OpenHarmony/install-software/gcc-arm-none-eabi<span class="number">-9</span><span class="number">-2019</span>-q4-major/bin:$PATH</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：需确认路径，否则找不到用户路径会搜索系统自带编译链 <code>/usr/lib/gcc/arm-none-eabi/10.3.1</code></p>
<br>

<h2 id="Linux下编写Python合并脚本"><a href="#Linux下编写Python合并脚本" class="headerlink" title="Linux下编写Python合并脚本"></a>Linux下编写Python合并脚本</h2><h3 id="合并-bootloader-app-mix"><a href="#合并-bootloader-app-mix" class="headerlink" title="合并 bootloader + app  &#x3D; mix"></a>合并 bootloader + app  &#x3D; mix</h3><p><strong>1. 安装 PyInstaller</strong></p>
<pre><code>pip install pyinstaller
</code></pre>
<br>

<p><strong>2. 编写Python合并程序</strong></p>
<p><a href="https://github.com/XUAN9527/script">代码链接</a></p>
<br>

<p><strong>3. 打包 Python 程序</strong></p>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-F</code>：生成单一可执行文件。</li>
<li><code>-D</code>：生成包含所有依赖项的目录。</li>
<li><code>-n</code>：指定可执行文件名。</li>
<li><code>--distpath</code>：指定可执行文件输出目录。</li>
<li><code>--noconfirm</code>：覆盖输出文件时无需确认。</li>
</ul>
<p><strong>以下是一些常用的高级选项：</strong></p>
<ul>
<li><code>--hidden-import</code>：指定要隐藏导入的模块。</li>
<li><code>--exclude-module</code>：指定要排除的模块。</li>
<li><code>--onefile</code>：将所有文件打包成一个可执行文件。</li>
<li><code>--runtime</code>：指定 Python 运行时版本。</li>
</ul>
<p><strong>执行规则:</strong></p>
<pre><code>cd new_file,copy file.py and file.ico
pyinstaller -F -w (-i icofile) 文件名.py
</code></pre>
<p><strong>example:</strong></p>
<pre><code>pyinstaller -F file.py
pyinstaller -F -w -i file.ico file.py
</code></pre>
<br>

<p><strong>4. 运行可执行文件</strong></p>
<pre><code>./dist/file
</code></pre>
<br>

<p><strong>5. 例程</strong></p>
<p><a href="https://github.com/XUAN9527/script">代码链接</a></p>
<br>

<p><strong>6. 实际应用场景</strong></p>
<ul>
<li>单独使用：Linux环境下单独执行使用。</li>
<li>集成在<code>makefile</code>中，使用<code>make</code>编译自动生成文件：<ul>
<li>将<code>papp_up</code>和<code>mix_10K</code>打包至<code>tools</code>文件夹，放在<code>makefile</code>同一目录下。</li>
<li>需要<code>bootloder.bin</code>在<code>../bootloader</code>目录下。</li>
<li>修改makefile生成规则。</li>
<li><code>$(BUILD_DIR)</code>为编译文件目录，跟进自身makefile修改。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.PHONY : clean all</span><br><span class="line"></span><br><span class="line">all: $(TARGET).bin $(TARGET).<span class="built_in">list</span> $(TARGET).hex</span><br><span class="line">	$(SZ) $(TARGET).elf</span><br><span class="line">	@make copy</span><br><span class="line">	@make mix</span><br><span class="line"></span><br><span class="line">.PHONY: copy</span><br><span class="line"></span><br><span class="line">copy: $(TARGET).bin</span><br><span class="line">	cp $(TARGET).bin app.bin</span><br><span class="line">	cp ../bootloader/bootloader.bin bootloader.bin</span><br><span class="line"><span class="meta">#	cp $(TARGET).hex app.hex</span></span><br><span class="line"></span><br><span class="line">mix:</span><br><span class="line">	./tools/papp_up</span><br><span class="line">	./tools/mix_10K</span><br><span class="line">	$(OC) -I binary -O ihex --change-addresses <span class="number">0x8000000</span> mix.bin mix.hex</span><br><span class="line">	rm bootloader.bin</span><br><span class="line">	rm app.bin</span><br><span class="line">	rm mix.bin</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -rf $(BUILD_DIR)</span><br><span class="line">	rm papp.bin</span><br><span class="line">	rm mix.hex</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<br>



]]></content>
      <categories>
        <category>嵌入式</category>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>杂项笔记</title>
    <url>/2024/01/31/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="J-Link-J-Flash"><a href="#J-Link-J-Flash" class="headerlink" title="J-Link&#x2F;J-Flash"></a>J-Link&#x2F;J-Flash</h2><p><strong>J-Flash批处理脚本配置烧录：</strong>当然，前提是要添加J-Link的可执行程序路径到<code>$PATH</code>环境变量中</p>
<ul>
<li><code>program.bat</code>脚本代码如下，参考修改即可：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo start...</span><br><span class="line"></span><br><span class="line">JLink -device N32L406CB -if swd -speed 4000 -CommanderScript &quot;C:\Users\Breo\Desktop\Wireless moxibustion\Software\program.jlink&quot;</span><br></pre></td></tr></table></figure></li>
<li><code>program.jlink</code>文件代码如下，其中目标设备、文件路径、烧录地址等根据需要配置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connect</span><br><span class="line">device N32L406CB</span><br><span class="line">si SWD</span><br><span class="line">speed 4000</span><br><span class="line">h		// halt-停止</span><br><span class="line">r		// 复位，可以考虑去掉</span><br><span class="line">erase		// 或 erase 0x8002800，去掉也行，但可能会出现error fail address 0x00000000错误提示</span><br><span class="line"></span><br><span class="line">loadfile app.bin 0x8002800      // loadfile app.hex 或 loadfile app.bin 0x8000000</span><br><span class="line">verifybin app.bin 0x8002800</span><br><span class="line">r</span><br><span class="line">go		// r go表示reset and run</span><br><span class="line">q		// 退出J-Link命令行工具</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Ubuntu-无法更新问题"><a href="#Ubuntu-无法更新问题" class="headerlink" title="Ubuntu 无法更新问题"></a>Ubuntu 无法更新问题</h2><p>Ubuntu 无法使用<code>apt update</code></p>
<h3 id="更改软件源"><a href="#更改软件源" class="headerlink" title="更改软件源"></a>更改软件源</h3><p>编辑 <code>/etc/apt/sources.list</code> 文件，将以下内容添加到文件末尾</p>
<pre><code>deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse

deb https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse

deb https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
</code></pre>
<h3 id="清除-apt-缓存"><a href="#清除-apt-缓存" class="headerlink" title="清除 apt 缓存"></a>清除 apt 缓存</h3><pre><code>sudo apt clean
sudo apt autoclean
</code></pre>
<h3 id="尝试更新系统"><a href="#尝试更新系统" class="headerlink" title="尝试更新系统"></a>尝试更新系统</h3><pre><code>sudo apt update
</code></pre>
<p>显示 <code>ModuleNotFoundError: No module named &#39;apt_pkg&#39;</code>，重新安装 “<code>apt_pkg</code>“ 模块：</p>
<pre><code>sudo apt install --reinstall python3-apt
</code></pre>
<p>显示 ERROR：</p>
<pre><code>E: Could not read response to hello message from hook [ ! -f /usr/bin/snap ] || /usr/bin/snap advise-snap --from-apt 2&gt;/dev/null || true: Success
</code></pre>
<p>如果问题仍然存在，尝试修复 Python 包：</p>
<pre><code>sudo apt install --fix-broken
</code></pre>
<p>然后就更新系统了：</p>
<pre><code>sudo apt update
sudo apt upgrade
</code></pre>
<p>执行<code>sudo apt upgrade</code>后显示ERROR：</p>
<pre><code>Errors were encountered while processing:
/tmp/apt-dpkg-install-cQBLJW/626-linux-iot-tools-common_5.4.0-1030.31_all.deb
E: Sub-process /usr/bin/dpkg returned an error code (1)
</code></pre>
<p>最后一步，修复损坏的软件包配置：</p>
<pre><code>sudo dpkg --configure -a
sudo apt upgrade
</code></pre>
<h2 id="Breo蓝牙启动异常"><a href="#Breo蓝牙启动异常" class="headerlink" title="Breo蓝牙启动异常"></a>Breo蓝牙启动异常</h2><h3 id="Breo蓝牙初始化"><a href="#Breo蓝牙初始化" class="headerlink" title="Breo蓝牙初始化"></a>Breo蓝牙初始化</h3><p>蓝牙初始化没完成，透传未开启，app就连接蓝牙了。<br>设置透传参数，开启透传的的状态中增加连接蓝牙接受指令。</p>
<h3 id="心跳包回复超时"><a href="#心跳包回复超时" class="headerlink" title="心跳包回复超时"></a>心跳包回复超时</h3><p>现在是接收&#x2F;刷新设备数据200ms超时，延迟太长还可以缩短。</p>
<h2 id="SPI级联led灯调试小助手"><a href="#SPI级联led灯调试小助手" class="headerlink" title="SPI级联led灯调试小助手"></a>SPI级联led灯调试小助手</h2><p>产品名称：1209RGB幻彩雾状<br>产品型号：XTQ-016B.RGB-2307125-20</p>
<h3 id="SPI级联led灯问题汇总"><a href="#SPI级联led灯问题汇总" class="headerlink" title="SPI级联led灯问题汇总"></a>SPI级联led灯问题汇总</h3><h4 id="充电闪灯问题"><a href="#充电闪灯问题" class="headerlink" title="充电闪灯问题"></a>充电闪灯问题</h4><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>充电中拔掉电源，立即再次插入，会闪一下灯；若等两秒再插入则不会出现，初步判断是此款芯片有锁存功能，会保存到寄存器中，未完全掉电再次插入则会继续执行上次的寄存器数据。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>充电中拔掉电源，程序不要立即断电，持续两秒反初始化spi灯珠，即给spi寄存器写全灭数据。</p>
<h4 id="呼吸灯闪烁问题"><a href="#呼吸灯闪烁问题" class="headerlink" title="呼吸灯闪烁问题"></a>呼吸灯闪烁问题</h4><h5 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h5><p>程序中呼吸灯会跑偶尔闪烁，影响显示效果。分析发现，代码中有电机的FG检测，此检测开启了输入捕获功能，会持续中断触发，虽然spi灯的驱动是dma发送，但是也是由CPU来调度的，并不能与中断并行。spi呼吸灯效果需要持续发送数据，且时序要求很高，中断会抢占spi的dma发送，打断spi传输数据，导致数据传输出错，造成闪灯效果。</p>
<h5 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h5><p>1、提高芯片主频，n32l403KB最高主频为64MHz，如果主频提高效果会好一些。<br>2、spi呼吸灯效果持续发送数据，不能与中断频繁的代码一起使用。</p>
<h2 id="某项目充电保护仍充电"><a href="#某项目充电保护仍充电" class="headerlink" title="某项目充电保护仍充电"></a>某项目充电保护仍充电</h2><p>修改代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;-1, 1, PIN_CHARGE_CC_DETECT, PIN_MODE_INPUT&#125;,	//input/output switch</span><br><span class="line"></span><br><span class="line">static void board_charge_cc_set(bool en)</span><br><span class="line">&#123;	</span><br><span class="line">	struct pin_status_desc *pin = pin_handle(PIN_CHARGE_CC_DETECT);</span><br><span class="line">	<span class="keyword">if</span>(en)</span><br><span class="line">	&#123;</span><br><span class="line">		pin-&gt;<span class="built_in">type</span> = PIN_MODE_INPUT;</span><br><span class="line">		drv_pin_mode(pin-&gt;pin_id,pin-&gt;<span class="built_in">type</span>);</span><br><span class="line">		pin-&gt;lvl_rt = -1;			//重置lvl_rt，以防止output出问题</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		pin-&gt;<span class="built_in">type</span> = PIN_MODE_OUTPUT;</span><br><span class="line">		drv_pin_mode(pin-&gt;pin_id,pin-&gt;<span class="built_in">type</span>);</span><br><span class="line">		pin_set_func(pin, PIN_HIGH);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Git小贴士"><a href="#Git小贴士" class="headerlink" title="Git小贴士"></a>Git小贴士</h2><h3 id="执行-git-pull-会覆盖本地的修改吗？"><a href="#执行-git-pull-会覆盖本地的修改吗？" class="headerlink" title="执行 git pull 会覆盖本地的修改吗？"></a>执行 git pull 会覆盖本地的修改吗？</h3><p>没有冲突的情况下，远端会直接更新至本地上，但不会改变本地未提交的变动；如果本地修改已提交，则会执行一个远端分支和本地分支的合并</p>
<h3 id="git-fetch-和-git-pull-的区别与联系"><a href="#git-fetch-和-git-pull-的区别与联系" class="headerlink" title="git fetch 和 git pull 的区别与联系"></a>git fetch 和 git pull 的区别与联系</h3><p><code>git fetch</code>用于从远程仓库获取最新的提交，保存到本地的远程跟踪分支中（<code>FETCH_HEAD</code>），可以通过查看此分支了解远程仓库的更新情况</p>
<ul>
<li><code>git diff FETCH_HEAD</code>比较查看该分支和当前工作分支的内容</li>
</ul>
<br>

<p><code>git pull</code>会自动获取远程仓库的更新，并且合并到当前分支上，相当于<code>git fetch</code> + <code>git merge FETCH_HEAD</code></p>
<ul>
<li>将远程仓库中指定分支的最新提交 ID 保存到本地的 <code>FETCH_HEAD</code> 分支中</li>
<li>将 <code>FETCH_HEAD</code> 分支合并到当前工作分支中</li>
</ul>
<h3 id="基础非典型操作"><a href="#基础非典型操作" class="headerlink" title="基础非典型操作"></a>基础非典型操作</h3><h3 id="本地git配置"><a href="#本地git配置" class="headerlink" title="本地git配置"></a>本地git配置</h3><br>

<p><strong>配置本地与远端的SSH密钥连接流程：</strong></p>
<ul>
<li>本地生成SSH公钥和私钥(如果没有的话，另，linux下公钥通常存放于<code>~/.ssh/*.pub</code>)<ul>
<li><code>ssh-keygen -t rsa -b 4096 -C xxx@xxx.com</code></li>
</ul>
</li>
<li>复制公钥，添加至远端平台的SSH设置上<br></li>
</ul>
<p><strong>查看本地配置：</strong></p>
<ul>
<li><code>git config --list</code>查看当前项目的所有配置</li>
<li><code>git config --global --list</code>查看全局配置<br></li>
</ul>
<p><strong>修改用户名(全局&#x2F;当前项目)</strong></p>
<p>此用户名即提交日志上所展示的用户名称</p>
<ul>
<li>修改全局用户名：<code>git config --global user.name &quot;xxx&quot;</code>，影响用户的所有仓库</li>
<li>修改当前路径项目的用户名：<code>git config user.name &quot;xxx&quot;</code></li>
<li>查看全局用户名：<code>git config user.name</code><br></li>
</ul>
<p><strong>初始化本地工程并与远端已有仓库的main分支关联：</strong></p>
<ul>
<li>进入工程根目录，<code>git init</code>初始化本地仓库</li>
<li>添加远程仓库：<code>git remote add origin &lt;远程仓库地址&gt;</code></li>
<li><code>git branch -M main</code>将当前分支重命名为<code>main</code>，M即<code>--move --force</code>的缩写。（可以分别输入<code>git add --all</code>，<code>git commit -m &quot;first commit&quot;</code>完成对本地分支的首次提交）</li>
<li>使用<code>git pull origin main</code>，将远程仓库的main分支拉取到本地，或者<code>git push -u origin main -f</code>将本地的xxx分支强制推送到远端main分支，其中-u是<code>--set-upstream</code>的缩写，后续会保持这个跟踪关系</li>
</ul>
<br>

<h2 id="可变参数函数详解"><a href="#可变参数函数详解" class="headerlink" title="可变参数函数详解"></a>可变参数函数详解</h2><p>C语言中的可变参数函数允许您定义函数，其参数个数是不确定的，可以根据具体需求接受可变数量的参数。这在处理不定数量参数的情况下非常有用，比如<code>printf</code>和<code>scanf</code>等函数。让我为您详细解释一下可变参数函数的原理和实现。</p>
<p><strong>1. 原理与实现：</strong></p>
<ul>
<li><p>可变参数函数的参数列表是从右往左压入堆栈的。假设堆栈中有以下参数：不可变参数1、不可变参数2、…、不可变参数n、可变参数1、可变参数2、…、可变参数n。</p>
</li>
<li><p>为了获取可变参数，我们需要知道每个可变参数的地址。这是通过前一个不可变参数的地址和类型来实现的。</p>
</li>
<li><p>ANSI标准提供了三个宏来实现这个过程：</p>
<ul>
<li><p><code>va_start(va_list arg_ptr, prev_param)</code>: 初始化可变参数列表，将arg_ptr指向第一个可变参数。</p>
</li>
<li><p><code>va_arg(va_list arg_ptr, type)</code>: 获取当前参数的值，类型由前面的不可变参数传递。例如，printf中的格式化字符串或者可变参数列表的参数类型和第几个不可变参数的相同。</p>
</li>
<li><p><code>va_end(va_list arg_ptr)</code>: 释放资源，结束可变参数列表的访问。</p>
</li>
</ul>
</li>
<li><p>这些宏的实现细节由编译器和标准库提供，我们只需调用它们即可。</p>
</li>
</ul>
<p><strong>2. 可变参数函数：</strong></p>
<ul>
<li>可变参数函数允许在函数定义中接受不定数量的参数。</li>
<li>C语言提供了 <code>stdarg.h</code> 头文件来支持可变参数函数的实现。</li>
<li>下面是一个示例代码，展示了如何实现一个可变参数函数 sum，它接受一个整数参数 count，表示接下来的可变参数的数量：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> count, ...)</span> &#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">        total += num;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = sum(<span class="number">4</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个示例中，我们定义了一个可变参数函数 sum，它计算传入的整数参数的总和。</li>
</ul>
<br>

<p><strong>3. 可变参数宏：</strong></p>
<ul>
<li>可变参数宏允许在宏调用中接受可变数量的参数。</li>
<li>在C语言中，可变参数宏使用 <code>__VA_ARGS__</code> 表示可变参数的部分。</li>
<li>下面是一个示例代码，展示了如何定义一个可变参数宏 <code>PRINT_VALUES</code>，它使用 printf 函数来打印可变数量的值:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_VALUES(...) do &#123; \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;Values: &quot;</span>); \</span></span><br><span class="line"><span class="meta">    printf(__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;\n&quot;</span>); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    PRINT_VALUES(<span class="string">&quot;%d %s %f&quot;</span>, <span class="number">10</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个示例中，我们定义了一个可变参数宏 <code>PRINT_VALUES</code>，它使用 <code>printf</code> 函数来打印多个值。</li>
</ul>
<br>

<p><strong>4. 实现自己的 printf 函数：</strong></p>
<ul>
<li><code>printf</code> 函数接受一个格式字符串作为第一个参数，后面是可变数量的参数，用于替换格式字符串中的格式占位符。</li>
<li>以下是一个简化版的示例代码，展示了一个实现类似于 <code>printf</code> 函数的功能的函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span> &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line">    <span class="keyword">while</span> (*format != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*format == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">            format++; <span class="comment">// 移动到占位符的下一个字符</span></span><br><span class="line">            <span class="keyword">if</span> (*format == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> value = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">double</span> value = va_arg(args, <span class="type">double</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">char</span>* value = va_arg(args, <span class="type">char</span>*);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> value = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Unsupported format specifier: %c&quot;</span>, *format);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *format);</span><br><span class="line">        &#125;</span><br><span class="line">        format++; <span class="comment">// 移动到下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">	<span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">	<span class="type">char</span> str[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	my_printf(<span class="string">&quot;Integer: %d\n&quot;</span>, num);</span><br><span class="line">	my_printf(<span class="string">&quot;Float: %f\n&quot;</span>, pi);</span><br><span class="line">	my_printf(<span class="string">&quot;Float: %s\n&quot;</span>, str);</span><br><span class="line">	my_printf(<span class="string">&quot;Float: %c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><p>参考文档：<a href="https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">汇编语言入门教程</a></p>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序example.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add_a_and_b</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> add_a_and_b(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gcc 将这个程序转成汇编语言。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc -S example.c</span><br></pre></td></tr></table></figure>
<p>example.s经过简化以后，大概是下面的样子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_add_a_and_b:</span><br><span class="line">   push   %ebx</span><br><span class="line">   mov    %eax, [%esp+8] </span><br><span class="line">   mov    %ebx, [%esp+12]</span><br><span class="line">   add    %eax, %ebx </span><br><span class="line">   pop    %ebx </span><br><span class="line">   ret  </span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line">   push   3</span><br><span class="line">   push   2</span><br><span class="line">   call   _add_a_and_b </span><br><span class="line">   add    %esp, 8</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>
<p>可以看到，原程序的两个函数add_a_and_b和main，对应两个标签_add_a_and_b和_main。每个标签里面是该函数所转成的 CPU 运行流程。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux小贴士</title>
    <url>/2024/05/06/Linux%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
    <content><![CDATA[<h2 id="tree指令小贴士"><a href="#tree指令小贴士" class="headerlink" title="tree指令小贴士"></a>tree指令小贴士</h2><p><strong>1. 基本用法：</strong> 显示当前目录下的文件和目录结构。</p>
<pre><code>tree
</code></pre>
<p><strong>2. 限制目录深度：</strong> 使用 <code>-L</code> 选项后跟数字来限制目录显示的深度。</p>
<pre><code>tree -L 2
</code></pre>
<p>这将显示当前目录及其下最多两级子目录。</p>
<p><strong>3. 显示隐藏文件：</strong> 默认情况下，隐藏文件（以点 . 开头的文件或目录）不会被显示。要显示这些隐藏文件，可以使用 <code>-a</code> 选项。</p>
<pre><code>tree -a
</code></pre>
<p><strong>4. 递归显示所有文件：</strong> 使用 <code>-R</code> 选项递归显示所有文件。</p>
<pre><code>tree -R
</code></pre>
<p><strong>5. 指定目录：</strong> 显示指定目录的树状结构。</p>
<pre><code>tree /path/to/directory
</code></pre>
<p><strong>6. 使用文件系统类型：</strong> 显示目录结构时，包括文件系统类型。</p>
<pre><code>tree -F
</code></pre>
<p><code>-F</code> 选项会在每个目录名后添加一个斜杠 <code>/</code>。</p>
<p><strong>7. 排序：</strong> 默认情况下，<code>tree</code> 会按字母顺序排序。使用 <code>-f</code> 选项可以按照文件修改时间排序。</p>
<pre><code>tree -f
</code></pre>
<p><strong>8. 显示文件大小：</strong> 使用 <code>-h</code> 选项以更易读的格式显示文件大小。</p>
<pre><code>tree -h
</code></pre>
<p><strong>9. 显示目录和文件的权限：</strong> 使用 <code>-u</code> 选项显示文件所有者，<code>-g</code> 选项显示文件组。</p>
<pre><code>tree -ug
</code></pre>
<p><strong>10. 使用颜色：</strong> <code>tree</code> 命令使用颜色来区分不同类型的文件和目录。使用 <code>--no-colour</code> 可以关闭颜色显示。</p>
<pre><code>tree --no-colour
</code></pre>
<p><strong>11. 输出到文件：</strong><br>将树状结构输出到一个文件中。</p>
<pre><code>tree &gt; tree.txt
</code></pre>
<p><strong>12. 执行命令：</strong><br>对每个文件或目录执行命令，例如，获取每个文件的详细信息。</p>
<pre><code>tree -exec ls -l &#123;&#125; \;
</code></pre>
<p><strong>13. 帮助和手册：</strong><br>查看 tree 命令的帮助信息。</p>
<pre><code>tree --help
man tree
</code></pre>
<p><strong>14. 安装 tree 命令（如果尚未安装）通常可以通过你的Linux发行版的包管理器来完成。</strong><br>例如，在Ubuntu上，你可以使用以下命令安装：</p>
<pre><code>sudo apt-get update
sudo apt-get install tree
</code></pre>
<p>使用 <code>tree</code> 可以帮助你更直观地查看目录结构，特别是在处理复杂的文件系统时。</p>
<br>

<h2 id="git小贴士"><a href="#git小贴士" class="headerlink" title="git小贴士"></a>git小贴士</h2><p><img src="/../pictures/git%E6%8C%87%E4%BB%A4.jpg" alt="git指令"></p>
<br>

<p><img src="/../pictures/vim%E6%8C%87%E4%BB%A4.jpg" alt="vim指令"></p>
<br>

<h2 id="Python问题"><a href="#Python问题" class="headerlink" title="Python问题"></a>Python问题</h2><ul>
<li><code>python</code> 指向 <code>python3</code></li>
<li><code>Ubuntu</code> 系统中默认的 <code>python</code> 可能指向 <code>Python 2</code>，但 <code>Python 2</code> 已经停止使用。可以使用以下命令将 <code>python</code> 指向 <code>Python 3</code>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-is-python3</span><br></pre></td></tr></table></figure>

<br>

<h2 id="OpenHarmony学习笔记"><a href="#OpenHarmony学习笔记" class="headerlink" title="OpenHarmony学习笔记"></a>OpenHarmony学习笔记</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol>
<li><p>安装所需的组件和配置<code>git</code>身份信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git-lfs curl python3-pip ccache</span><br><span class="line"></span><br><span class="line">git config --global user.name <span class="string">&quot;YourName&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;YourEmail@example.com&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取代码步骤</p>
</li>
</ol>
<ul>
<li><p>安装<code>repo</code>工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/bin</span><br><span class="line">curl https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 &gt; ~/bin/repo</span><br><span class="line"><span class="built_in">chmod</span> a+x ~/bin/repo</span><br><span class="line"><span class="built_in">export</span> PATH=~/bin:<span class="variable">$PATH</span>  <span class="comment"># 永久生效需写入~/.bashrc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(推荐SSH协议)</span><br><span class="line">repo init -u git@gitee.com:openharmony/manifest.git -b OpenHarmony-5.0.2-Release --no-repo-verify</span><br><span class="line">或者：</span><br><span class="line">(HTTPS协议)</span><br><span class="line">repo init -u https://gitee.com/openharmony/manifest.git -b OpenHarmony-5.0.2-Release --no-repo-verify</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步全量代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo <span class="built_in">sync</span> -c -j8  <span class="comment"># -c仅同步当前分支，-j8启用8线程加速</span></span><br><span class="line">repo forall -c <span class="string">&#x27;git lfs pull&#x27;</span>  <span class="comment"># 拉取大文件（如图片/预编译库）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>常见问题处理</li>
</ol>
<ul>
<li><p>权限错误,若出现<code>Permission denied</code>，检查<code>SSH</code>公钥是否已正确绑定<code>Gitee</code>账户，并修复目录权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> .repo/</span><br><span class="line">ex: sudo <span class="built_in">chown</span> -R ubuntu:ubuntu /home/ubuntu/openharmony/.repo</span><br></pre></td></tr></table></figure></li>
<li><p>如果问题仍存在,可能是父目录权限问题，检查并修复整个<code>openharmony</code>目录的权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R ubuntu:ubuntu /home/ubuntu/openharmony</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 755 /home/ubuntu/openharmony</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络中断导致同步失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo <span class="built_in">sync</span> -c -j4 --fail-fast  <span class="comment"># 失败时自动重试</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>依赖缺失</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build/prebuilts_download.sh  <span class="comment"># 自动下载依赖:cite[3]:cite[6]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>验证代码完整性</li>
</ol>
<ul>
<li><p>目录结构检查</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -la .repo/manifests/  <span class="comment"># 应包含default.xml及版本分支文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>版本标签匹配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> .repo/manifests.git</span><br><span class="line">git tag | grep OpenHarmony-5.0.2  <span class="comment"># 确认分支存在:cite[7]</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>小贴士</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake学习笔记</title>
    <url>/2024/05/08/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="CMake学习教程"><a href="#CMake学习教程" class="headerlink" title="CMake学习教程"></a>CMake学习教程</h2><ul>
<li>[参考资料1] : <a href="https://subingwen.cn/cmake/CMake-primer">https://subingwen.cn/cmake/CMake-primer</a></li>
<li>[参考资料2] : <a href="https://subingwen.cn/cmake/CMake-advanced/">https://subingwen.cn/cmake/CMake-advanced/</a></li>
<li>[参考资料3] : <a href="https://zhuanlan.zhihu.com/p/534439206">https://zhuanlan.zhihu.com/p/534439206</a></li>
</ul>
<br>

<h2 id="编写一个简单的CMakeLists-txt文件"><a href="#编写一个简单的CMakeLists-txt文件" class="headerlink" title="编写一个简单的CMakeLists.txt文件"></a>编写一个简单的CMakeLists.txt文件</h2><h3 id="1-示例文件的目录结构如下："><a href="#1-示例文件的目录结构如下：" class="headerlink" title="1. 示例文件的目录结构如下："></a>1. 示例文件的目录结构如下：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-添加-CMakeLists-txt-文件"><a href="#2-添加-CMakeLists-txt-文件" class="headerlink" title="2. 添加 CMakeLists.txt 文件"></a>2. 添加 CMakeLists.txt 文件</h3><p>在上述源文件所在目录下添加一个新文件 CMakeLists.txt，文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.0</span>)</span><br><span class="line">project(CALC)</span><br><span class="line">add_executable(app add.c div.c main.c mult.c sub.c)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>cmake_minimum_required</code>：指定使用的 cmake 的最低版本。</p>
<ul>
<li>可选，非必须，如果不加可能会有警告。</li>
</ul>
</li>
<li><p><code>project</code>：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。</p>
</li>
<li><p><code>add_executable</code>：定义工程会生成一个可执行程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add_executable(可执行程序名 源文件名称)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里的可执行程序名和<code>project</code>中的项目名没有任何关系</p>
</li>
<li><p>源文件名可以是一个也可以是多个，如有多个可用空格或<code>;</code>间隔</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 样式<span class="number">1</span></span><br><span class="line">add_executable(app add.c div.c main.c mult.c sub.c)</span><br><span class="line"># 样式<span class="number">2</span></span><br><span class="line">add_executable(app add.c;div.c;main.c;mult.c;sub.c)</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="3-执行CMake命令"><a href="#3-执行CMake命令" class="headerlink" title="3. 执行CMake命令"></a>3. 执行CMake命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake 命令原型</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake CMakeLists.txt 文件所在路径</span></span><br></pre></td></tr></table></figure>
<p>执行示例 (当前<code>CMakeLists.txt</code>路径) ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake .</span></span><br></pre></td></tr></table></figure>
<p>当执行<code>cmake</code>命令之后，<code>CMakeLists.txt</code> 中的命令就会被执行，所以一定要注意给<code>cmake</code>命令指定路径的时候一定不能出错。</p>
<p>执行命令之后，看一下源文件所在目录中是否多了一些文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── CMakeCache.txt         # new add file</span><br><span class="line">├── CMakeFiles             # new add dir</span><br><span class="line">├── cmake_install.cmake    # new add file</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── Makefile               # new add file</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>

<p>我们可以看到在对应的目录下生成了一个<code>makefile</code>文件，此时再执行<code>make</code>命令，就可以对项目进行构建得到所需的可执行程序了。</p>
<br>

<h3 id="4-头文件及指定宏"><a href="#4-头文件及指定宏" class="headerlink" title="4. 头文件及指定宏"></a>4. 头文件及指定宏</h3><ul>
<li><code>CMakeLists.txt</code> 示例代码文件：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(HOME /home/robin/Linux/calc)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin/)</span><br><span class="line"><span class="meta prompt_">include_directories($</span><span class="language-bash">&#123;PROJECT_SOURCE_DIR&#125;/include)</span></span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)</span><br><span class="line">add_executable(app  $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h4 id="4-1-通过参数-std-c-11指定出要使用c-11标准编译程序-对应宏DCMAKE-CXX-STANDARD"><a href="#4-1-通过参数-std-c-11指定出要使用c-11标准编译程序-对应宏DCMAKE-CXX-STANDARD" class="headerlink" title="4.1 通过参数-std=c++11指定出要使用c++11标准编译程序,对应宏DCMAKE_CXX_STANDARD:"></a>4.1 通过参数<code>-std=c++11</code>指定出要使用c++11标准编译程序,对应宏<code>DCMAKE_CXX_STANDARD</code>:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 增加-std=c++<span class="number">11</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加-std=c++11</span></span><br><span class="line">cmake (CMakeLists.txt文件路径) -DCMAKE_CXX_STANDARD=11</span><br></pre></td></tr></table></figure>

<br>

<h4 id="4-2-指定输出的路径-EXECUTABLE-OUTPUT-PATH-："><a href="#4-2-指定输出的路径-EXECUTABLE-OUTPUT-PATH-：" class="headerlink" title="4.2 指定输出的路径(EXECUTABLE_OUTPUT_PATH)："></a>4.2 指定输出的路径(EXECUTABLE_OUTPUT_PATH)：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set(HOME /home/robin/Linux/Sort)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin)</span><br></pre></td></tr></table></figure>
<p>如果这个路径中的子目录不存在，会自动生成，无需自己手动创建。</p>
<br>

<h4 id="4-3-头文件的路径-include-directories"><a href="#4-3-头文件的路径-include-directories" class="headerlink" title="4.3 头文件的路径(include_directories)"></a>4.3 头文件的路径(include_directories)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include_directories(headpath)</span><br></pre></td></tr></table></figure>
<p>其中，第六行指定就是头文件的路径，PROJECT_SOURCE_DIR宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。</p>
<br>

<h4 id="4-4-搜索文件-aux-source-directory"><a href="#4-4-搜索文件-aux-source-directory" class="headerlink" title="4.4 搜索文件(aux_source_directory)"></a>4.4 搜索文件(aux_source_directory)</h4><ul>
<li><p><code>aux_source_directory(&lt; dir &gt; &lt; variable &gt;)</code> 示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</code>示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CMAKE_CURRENT_SOURCE_DIR</code> 宏表示当前访问的 <code>CMakeLists.txt</code> 文件所在的路径</p>
</li>
</ul>
<br>

<h3 id="5-制作动态库或静态库"><a href="#5-制作动态库或静态库" class="headerlink" title="5. 制作动态库或静态库"></a>5. 制作动态库或静态库</h3><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p>
<h4 id="5-1-静态库："><a href="#5-1-静态库：" class="headerlink" title="5.1 静态库："></a>5.1 静态库：</h4><h5 id="5-1-1-cmake生成规则："><a href="#5-1-1-cmake生成规则：" class="headerlink" title="5.1.1 cmake生成规则："></a>5.1.1 cmake生成规则：</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名称 STATIC 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br></pre></td></tr></table></figure>

<ul>
<li>在Linux中，静态库名字分为三部分：<code>lib + 库名字 + .a</code>，示例：<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>
这样最终就会生成对应的静态库文件 <code>libcalc.a</code></li>
</ul>
<br>

<h5 id="5-1-2-gcc生成规则："><a href="#5-1-2-gcc生成规则：" class="headerlink" title="5.1.2 gcc生成规则："></a>5.1.2 gcc生成规则：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c add.c div.c mult.c sub.c -I ./include/</span><br></pre></td></tr></table></figure>

<ul>
<li>生成 <code>.o</code> 编译文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录中的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── add.o            # 目标文件</span><br><span class="line">├── div.c</span><br><span class="line">├── div.o            # 目标文件</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">├── mult.o           # 目标文件</span><br><span class="line">├── sub.c</span><br><span class="line">└── sub.o            # 目标文件</span><br></pre></td></tr></table></figure>
<ul>
<li>将生成的目标文件通过 ar工具打包生成静态库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将生成的目标文件 .o 打包成静态库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar rcs libcalc.a add.o div.o mult.o sub.o    <span class="comment">#在同一个目录中可以写成 *.o</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录中的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── add.o</span><br><span class="line">├── div.c</span><br><span class="line">├── div.o</span><br><span class="line">├── include</span><br><span class="line">│   └── `head.h  ===&gt; 和静态库一并发布</span><br><span class="line">├── `libcalc.a   ===&gt; 生成的静态库</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">├── mult.o</span><br><span class="line">├── sub.c</span><br><span class="line">└── sub.o</span><br></pre></td></tr></table></figure>

<ul>
<li>将生成的的静态库 libcalc.a和库对应的头文件head.h一并发布给使用者就可以了。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 发布静态库</span></span><br><span class="line">	1. head.h    =&gt; 函数声明</span><br><span class="line">	2. libcalc.a =&gt; 函数定义(二进制格式)</span><br></pre></td></tr></table></figure>
<br>

<h5 id="5-1-3-gcc静态库的使用"><a href="#5-1-3-gcc静态库的使用" class="headerlink" title="5.1.3 gcc静态库的使用:"></a>5.1.3 gcc静态库的使用:</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先拿到了发布的静态库</span></span><br><span class="line">	`head.h` 和 `libcalc.a`</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将静态库, 头文件, 测试程序放到一个目录中准备进行测试</span></span><br><span class="line">.</span><br><span class="line">├── head.h          # 函数声明</span><br><span class="line">├── libcalc.a       # 函数定义（二进制格式）</span><br><span class="line">└── main.c          # 函数测试</span><br></pre></td></tr></table></figure>

<ul>
<li>编译测试程序, 得到可执行文件。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译的时候指定库信息</span></span><br><span class="line"> 	-I: 指定头文件所在的目录(相对或者绝对路径)</span><br><span class="line">	-L: 指定库所在的目录(相对或者绝对路径)</span><br><span class="line">	-l: 指定库的名字, 掐头(lib)去尾(.a) ==&gt; calc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-L -l, 参数和参数值之间可以有空格, 也可以没有  -L./ -lcalc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -o app -I./ -L./ -lcalc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录信息, 发现可执行程序已经生成了</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── app   		# 生成的可执行程序</span><br><span class="line">├── head.h</span><br><span class="line">├── libcalc.a</span><br><span class="line">└── main.c</span><br></pre></td></tr></table></figure>

<br>

<h4 id="5-2-动态库："><a href="#5-2-动态库：" class="headerlink" title="5.2 动态库："></a>5.2 动态库：</h4><h5 id="5-2-1-cmake生成规则："><a href="#5-2-1-cmake生成规则：" class="headerlink" title="5.2.1 cmake生成规则："></a>5.2.1 cmake生成规则：</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名称 SHARED 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...)</span><br></pre></td></tr></table></figure>

<ul>
<li>在Linux中，动态库名字分为三部分：<code>lib + 库名字 + .so</code> ，示例：<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>
这样最终就会生成对应的动态库文件 <code>libcalc.so</code></li>
</ul>
<br>

<h5 id="5-1-2-gcc生成规则：-1"><a href="#5-1-2-gcc生成规则：-1" class="headerlink" title="5.1.2 gcc生成规则："></a>5.1.2 gcc生成规则：</h5><ul>
<li>生成动态链接库是直接使用<code>gcc</code>命令并且需要添加<code>-fPIC(-fpic)</code> 以及<code>-shared</code> 参数。<ul>
<li><code>-fPIC</code> 或 <code>-fpic</code> 参数的作用是使得 <code>gcc</code> 生成的代码是与位置无关的，也就是使用相对位置。</li>
<li><code>-shared</code>参数的作用是告诉编译器生成一个动态链接库。</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 将.c汇编得到.o, 需要额外的参数 -fpic/-fPIC</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c -fpic add.c div.c mult.c sub.c -I ./include/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成 <code>.o</code> 编译文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录文件信息, 检查是否生成了目标文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── add.o                # 生成的目标文件</span><br><span class="line">├── div.c</span><br><span class="line">├── div.o                # 生成的目标文件</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">├── mult.o               # 生成的目标文件</span><br><span class="line">├── sub.c</span><br><span class="line">└── sub.o                # 生成的目标文件</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>gcc</code>将得到的目标文件打包生成动态库, 需要使用参数 <code>-shared</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 将得到 .o 打包成动态库, 使用gcc , 参数 -shared</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -shared add.o div.o mult.o sub.o -o libcalc.so</span>  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查目录中是否生成了动态库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── add.o</span><br><span class="line">├── div.c</span><br><span class="line">├── div.o</span><br><span class="line">├── include</span><br><span class="line">│   └── `head.h   ===&gt; 和动态库一起发布</span><br><span class="line">├── `libcalc.so   ===&gt; 生成的动态库</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">├── mult.o</span><br><span class="line">├── sub.c</span><br><span class="line">└── sub.o</span><br></pre></td></tr></table></figure>

<ul>
<li>将生成的的动态库 libcalc.so和库对应的头文件head.h一并发布给使用者就可以了。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发布库文件和头文件</span></span><br><span class="line">	1. head.h</span><br><span class="line">	2. libcalc.so</span><br></pre></td></tr></table></figure>

<h5 id="5-1-3-gcc静态库的使用-1"><a href="#5-1-3-gcc静态库的使用-1" class="headerlink" title="5.1.3 gcc静态库的使用:"></a>5.1.3 gcc静态库的使用:</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 拿到发布的动态库</span></span><br><span class="line">	`head.h   libcalc.so</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 基于头文件编写测试程序, 测试动态库中提供的接口是否可用</span></span><br><span class="line">	`main.c`</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例目录:</span></span><br><span class="line">.</span><br><span class="line">├── head.h          ==&gt; 函数声明</span><br><span class="line">├── libcalc.so      ==&gt; 函数定义</span><br><span class="line">└── main.c          ==&gt; 函数测试</span><br></pre></td></tr></table></figure>

<ul>
<li>编译测试程序, 得到可执行文件。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在编译的时候指定动态库相关的信息: 头文件路径-I 库的路径 -L, 库的名字 -l</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -o app -I./ -L./ -lcalc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否生成了可执行程序</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── app 			# 生成的可执行程序</span><br><span class="line">├── head.h</span><br><span class="line">├── libcalc.so</span><br><span class="line">└── main.c</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行生成的可执行程序, 错误提示 ==&gt; 可执行程序执行的时候找不到动态库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./app</span> </span><br><span class="line">./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p><strong>修改解决动态库链接编译问题</strong></p>
<p>方案 1: 将库路径添加到环境变量<code>LD_LIBRARY_PATH</code>中</p>
<ol>
<li>找到相关的配置文件</li>
</ol>
<ul>
<li>用户级别: ~&#x2F;.bashrc —&gt; 设置对当前用户有效</li>
<li>系统级别: &#x2F;etc&#x2F;profile —&gt; 设置对所有用户有效</li>
</ul>
<ol start="2">
<li>使用 vim 打开配置文件, 在文件最后添加这样一句话</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自己把路径写进去就行了</span></span><br><span class="line">export LD_LIBRARY_PATH =$LD_LIBRARY_PATH :动态库的绝对路径</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>让修改的配置文件生效</li>
</ol>
<ul>
<li>修改了用户级别的配置文件, 关闭当前终端, 打开一个新的终端配置就生效了</li>
<li>修改了系统级别的配置文件, 注销或关闭系统, 再开机配置就生效了</li>
<li>不想执行上边的操作, 可以执行一个命令让配置重新被加载</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改的是哪一个就执行对应的那个命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">source</span> 可以简写为一个 . , 作用是让文件内容被重新加载</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> ~/.bashrc          (. ~/.bashrc)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> /etc/profile       (. /etc/profile)</span></span><br></pre></td></tr></table></figure>

<p>方案 2: 更新 &#x2F;etc&#x2F;ld.so.cache 文件</p>
<ol>
<li><p>找到动态库所在的绝对路径（不包括库的名字）比如：&#x2F;home&#x2F;robin&#x2F;Library&#x2F;</p>
</li>
<li><p>使用vim 修改 &#x2F;etc&#x2F;ld.so.conf 这个文件, 将上边的路径添加到文件中(独自占一行)</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 打开文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo vim /etc/ld.so.conf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 添加动态库路径, 并保存退出</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>更新 &#x2F;etc&#x2F;ld.so.conf中的数据到 &#x2F;etc&#x2F;ld.so.cache 中</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">必须使用管理员权限执行这个命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ldconfig</span>   </span><br></pre></td></tr></table></figure>

<p>方案 3: 拷贝动态库文件到系统库目录 &#x2F;lib&#x2F; 或者 &#x2F;usr&#x2F;lib 中 (或者将库的软链接文件放进去)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">库拷贝</span></span><br><span class="line">sudo cp /xxx/xxx/libxxx.so /usr/lib</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建软连接</span></span><br><span class="line">sudo ln -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so</span><br></pre></td></tr></table></figure>

<p>验证执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法:</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd 可执行程序名</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例:</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd app</span></span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffe8fbd6000)</span><br><span class="line">    libcalc.so =&gt; /home/robin/Linux/3Day/calc/test/libcalc.so (0x00007f5d85dd4000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5d85a0a000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007f5d85fd6000)  ==&gt; 动态链接器, 操作系统提供</span><br></pre></td></tr></table></figure>

<br>

<h4 id="5-3-指定输出的路径："><a href="#5-3-指定输出的路径：" class="headerlink" title="5.3 指定输出的路径："></a>5.3 指定输出的路径：</h4><ul>
<li><p>方式1 - 适用于动态库</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式2 - 都适用</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h4 id="5-4-包含库文件："><a href="#5-4-包含库文件：" class="headerlink" title="5.4 包含库文件："></a>5.4 包含库文件：</h4><h5 id="5-4-1-链接静态库："><a href="#5-4-1-链接静态库：" class="headerlink" title="5.4.1 链接静态库："></a>5.4.1 链接静态库：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure>
<p>现在我们把上面<code>src</code>目录中的<code>add.cpp</code>、<code>div.cpp</code>、<code>mult.cpp</code>、<code>sub.cpp</code>编译成一个静态库文件<code>libcalc.a</code>。通过命令制作并使用静态链接库。</p>
<p>测试目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span> </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a     # 制作出的静态库的名字</span><br><span class="line">└── src</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 4 files</span><br></pre></td></tr></table></figure>

<p>在cmake中，链接静态库的命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br></pre></td></tr></table></figure>

<ul>
<li>参数1：指定出要链接的静态库的名字<ul>
<li>可以是全名 libxxx.a</li>
<li>也可以是掐头（lib）去尾（.a）之后的名字 xxx</li>
</ul>
</li>
<li>参数2-N：要链接的其它静态库的名字</li>
</ul>
<p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(&lt;lib path&gt;)</span><br></pre></td></tr></table></figure>

<p>这样，修改之后的CMakeLists.txt文件内容如下:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 包含静态库路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>
<br>

<h5 id="5-4-2-链接动态库："><a href="#5-4-2-链接动态库：" class="headerlink" title="5.4.2 链接动态库："></a>5.4.2 链接动态库：</h5><p>动态库的链接和静态库是完全不同的：</p>
<ul>
<li>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。</li>
<li>动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存</li>
</ul>
<p>因此，在<code>cmake</code>中指定要链接的动态库的时候，<code>应该将命令写到生成了可执行文件之后</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 添加并指定最终生成的可执行程序名</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 指定可执行程序要链接的动态库名字</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread)</span><br></pre></td></tr></table></figure>

<p>在<code>target_link_libraries(app pthread)</code>中：</p>
<ul>
<li><code>app</code>: 对应的是最终生成的可执行程序的名字</li>
<li><code>pthread</code>：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为<code>libpthread.so</code>，在指定的时候一般会掐头<code>（lib）</code>去尾<code>（.so）</code>。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread calc)</span><br></pre></td></tr></table></figure>

<p>在第六行中，pthread、calc都是可执行程序app要链接的动态库的名字。当可执行程序app生成之后并执行该文件，会提示有如下错误信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./app</span> </span><br><span class="line">./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>在 <code>CMake</code> 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(path)</span><br></pre></td></tr></table></figure>

<p>所以修改之后的CMakeLists.txt文件应该是这样的：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 指定源文件或者动态库对应的头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 指定要链接的动态库的路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 添加并生成一个可执行程序</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 指定要链接的动态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread calc)</span><br></pre></td></tr></table></figure>

<p>通过link_directories指定了动态库的路径之后，在执行生成的可执行程序的时候，就不会出现找不到动态库的问题了。</p>
<p><strong>温馨提示：使用 target_link_libraries 命令就可以链接动态库，也可以链接静态库文件。</strong></p>
<br>

<h3 id="6-日志"><a href="#6-日志" class="headerlink" title="6. 日志"></a>6. 日志</h3><p>在<code>CMake</code>中可以用用户显示一条消息，该命令的名字为<code>message</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(无)</code> ：重要消息</li>
<li><code>STATUS</code> ：非重要消息</li>
<li><code>WARNING</code>：CMake 警告, 会继续执行</li>
<li><code>AUTHOR_WARNING</code>：CMake 警告 (dev), 会继续执行</li>
<li><code>SEND_ERROR</code>：CMake 错误, 继续执行，但是会跳过生成的步骤</li>
<li><code>FATAL_ERROR</code>：CMake 错误, 终止所有处理过程</li>
</ul>
<p><code>CMake</code>的命令行工具会在<code>stdout</code>上显示S<code>TATUS</code>消息，在<code>stderr</code>上显示其他所有消息。<code>CMake</code>的<code>GUI</code>会在它的<code>log</code>区域显示所有消息。</p>
<p><code>CMake</code>警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出一般日志信息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 输出警告信息</span></span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 输出错误信息</span></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="7-变量操作"><a href="#7-变量操作" class="headerlink" title="7. 变量操作"></a>7. 变量操作</h3><h4 id="7-1-追加"><a href="#7-1-追加" class="headerlink" title="7.1 追加"></a>7.1 追加</h4><p>有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过<code>file</code>命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用<code>set</code>命令也可以使用<code>list</code>命令。</p>
<br>

<h5 id="7-1-1-使用set拼接"><a href="#7-1-1-使用set拼接" class="headerlink" title="7.1.1 使用set拼接"></a>7.1.1 使用set拼接</h5><p>如果使用<code>set</code>进行字符串拼接，对应的命令格式如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(变量名<span class="number">1</span> <span class="variable">$&#123;变量名1&#125;</span> <span class="variable">$&#123;变量名2&#125;</span> ...)</span><br></pre></td></tr></table></figure>

<p>关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"><span class="comment"># 追加(拼接)</span></span><br><span class="line"><span class="keyword">set</span>(SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span> <span class="variable">$&#123;TEMP&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<br>

<h5 id="7-1-2-使用list拼接"><a href="#7-1-2-使用list拼接" class="headerlink" title="7.1.2 使用list拼接"></a>7.1.2 使用list拼接</h5><p><code>list</code>命令的功能比<code>set</code>要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，<code>APPEND</code>表示进行数据追加，后边的参数和<code>set</code>就一样了。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>

<br>

<h4 id="7-2-字符串移除"><a href="#7-2-字符串移除" class="headerlink" title="7.2 字符串移除"></a>7.2 字符串移除</h4><p>使用<code>list</code>命令，<code>REMOVE_ITEM</code>表示对数据进行移除</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 移除前日志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 移除 main.cpp</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/main.cpp)</span><br><span class="line"><span class="comment"># 移除后日志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="8-宏定义"><a href="#8-宏定义" class="headerlink" title="8. 宏定义"></a>8. 宏定义</h3><p>在<code>CMake</code>中，对应的命令叫做<code>add_definitions</code>:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-D宏名称)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="comment"># 自定义 DEBUG 宏</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DDEBUG)</span><br><span class="line"><span class="keyword">add_executable</span>(app ./<span class="keyword">test</span>.c)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="9-预定义宏"><a href="#9-预定义宏" class="headerlink" title="9. 预定义宏"></a>9. 预定义宏</h3><p>下面的列表中为大家整理了一些<code>CMake</code>中常用的宏：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>PROJECT_SOURCE_DIR</td>
<td>使用<code>cmake</code>命令后紧跟的目录，一般是工程的根目录</td>
</tr>
<tr>
<td>PROJECT_BINARY_DIR</td>
<td>执行<code>cmake</code>命令的目录</td>
</tr>
<tr>
<td>CMAKE_CURRENT_SOURCE_DIR</td>
<td>当前处理的<code>CMakeLists.txt</code>所在的路径</td>
</tr>
<tr>
<td>CMAKE_CURRENT_BINARY_DIR</td>
<td><code>target</code> 编译目录</td>
</tr>
<tr>
<td>EXECUTABLE_OUTPUT_PATH</td>
<td>重新定义目标二进制可执行文件的存放位置</td>
</tr>
<tr>
<td>LIBRARY_OUTPUT_PATH</td>
<td>重新定义目标链接库文件的存放位置</td>
</tr>
<tr>
<td>PROJECT_NAME</td>
<td>返回通过<code>PROJECT</code>指令定义的项目名称</td>
</tr>
<tr>
<td>CMAKE_BINARY_DIR</td>
<td>项目实际构建路径，假设在<code>build</code>目录进行的构建，那么得到的就是这个目录的路径</td>
</tr>
</tbody></table>
<br>

<h3 id="10-嵌套的CMake"><a href="#10-嵌套的CMake" class="headerlink" title="10. 嵌套的CMake"></a>10. 嵌套的CMake</h3><p>如果项目很大，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果只使用一个CMakeLists.txt，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个CMakeLists.txt文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。</p>
<p>先来看一下下面的这个的目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── calc</span><br><span class="line">│   ├── add.c</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── div.c</span><br><span class="line">│   ├── mult.c</span><br><span class="line">│   └── sub.c</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   ├── calc.h</span><br><span class="line">│   └── sort.h</span><br><span class="line">├── sort</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── insert.c</span><br><span class="line">│   └── select.c</span><br><span class="line">├── test1</span><br><span class="line">│   ├── calc.cpp</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">└── test2</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── sort.c</span><br><span class="line"></span><br><span class="line">6 directories, 15 files</span><br></pre></td></tr></table></figure>

<ul>
<li><code>include 目录</code>：头文件目录</li>
<li><code>calc 目录</code>：目录中的四个源文件对应的加、减、乘、除算法<ul>
<li>对应的头文件是<code>include</code>中的<code>calc.h</code></li>
</ul>
</li>
<li><code>sort 目录</code> ：目录中的两个源文件对应的是插入排序和选择排序算法<ul>
<li>对应的头文件是i<code>nclude</code>中的<code>sort.h</code></li>
</ul>
</li>
<li><code>test1 目录</code>：测试目录，对加、减、乘、除算法进行测试</li>
<li><code>test2 目录</code>：测试目录，对排序算法进行测试</li>
</ul>
<p>可以看到各个源文件目录所需要的<code>CMakeLists.txt</code>文件现在已经添加完毕了。接下来庖丁解牛，我们依次分析一下各个文件中需要添加的内容。</p>
<br>

<h3 id="10-1-节点关系"><a href="#10-1-节点关系" class="headerlink" title="10.1 节点关系"></a>10.1 节点关系</h3><p>众所周知，<code>Linux</code>的目录是树状结构，所以<code>嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。</code>因此，我们需要了解一些关于 <code>CMakeLists.txt</code> 文件变量作用域的一些信息：</p>
<ul>
<li>根节点<code>CMakeLists.txt</code>中的变量全局有效</li>
<li>父节点<code>CMakeLists.txt</code>中的变量可以在子节点中使用</li>
<li>子节点<code>CMakeLists.txt</code>中的变量只能在当前节点中使用</li>
</ul>
<br>

<h3 id="10-2-添加子目录"><a href="#10-2-添加子目录" class="headerlink" title="10.2 添加子目录"></a>10.2 添加子目录</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>source_dir</code>：指定了<code>CMakeLists.txt</code>源文件和代码文件的位置，其实就是指定子目录</li>
<li><code>binary_dir</code>：指定了输出文件的路径，一般不需要指定，忽略即可。</li>
<li><code>EXCLUDE_FROM_ALL</code>：在子路径下的目标默认不会被包含到父路径的<code>ALL</code>目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。</li>
</ul>
<p>通过这种方式<code>CMakeLists.txt</code>文件之间的父子关系就被构建出来了。</p>
<h3 id="10-3-编写CMakeLists-txt文件"><a href="#10-3-编写CMakeLists-txt文件" class="headerlink" title="10.3 编写CMakeLists.txt文件"></a>10.3 编写CMakeLists.txt文件</h3><h4 id="10-3-1-根目录"><a href="#10-3-1-根目录" class="headerlink" title="10.3.1 根目录"></a>10.3.1 根目录</h4><p>根目录中的 <code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(test)</span><br><span class="line"># 定义变量</span><br><span class="line"># 静态库生成的路径</span><br><span class="line">set(LIB_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)</span><br><span class="line"># 测试程序生成的路径</span><br><span class="line">set(EXEC_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/bin)</span><br><span class="line"># 头文件目录</span><br><span class="line">set(HEAD_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)</span><br><span class="line"># 静态库的名字</span><br><span class="line">set(CALC_LIB calc)</span><br><span class="line">set(SORT_LIB sort)</span><br><span class="line"># 可执行程序的名字</span><br><span class="line">set(APP_NAME_1 test1)</span><br><span class="line">set(APP_NAME_2 test2)</span><br><span class="line"># 添加子目录</span><br><span class="line">add_subdirectory(calc)</span><br><span class="line">add_subdirectory(sort)</span><br><span class="line">add_subdirectory(test1)</span><br><span class="line">add_subdirectory(test2)</span><br></pre></td></tr></table></figure>

<p>在根节点对应的文件中主要做了两件事情：定义全局变量和添加子目录。</p>
<ul>
<li>定义的全局变量主要是给子节点使用，目的是为了提高子节点中的<code>CMakeLists.txt</code>文件的可读性和可维护性，避免冗余并降低出差的概率。</li>
<li>一共添加了四个子目录，每个子目录中都有一个<code>CMakeLists.txt</code>文件，这样它们的父子关系就被确定下来了。</li>
</ul>
<h4 id="10-3-2-calc-目录"><a href="#10-3-2-calc-目录" class="headerlink" title="10.3.2 calc 目录"></a>10.3.2 calc 目录</h4><p><code>calc</code> 目录中的 <code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCLIB)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;CALC_LIB&#125;</span> STATIC <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第3行<code>aux_source_directory</code>：搜索当前目录（calc目录）下的所有源文件</li>
<li>第4行<code>include_directories</code>：包含头文件路径，HEAD_PATH是在根节点文件中定义的</li>
<li>第5行<code>set</code>：设置库的生成的路径，LIB_PATH是在根节点文件中定义的</li>
<li>第6行<code>add_library</code>：生成静态库，静态库名字CALC_LIB是在根节点文件中定义的</li>
</ul>
<h4 id="10-3-2-sort-目录"><a href="#10-3-2-sort-目录" class="headerlink" title="10.3.2 sort 目录"></a>10.3.2 sort 目录</h4><p>sort 目录中的 CMakeLists.txt文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCLIB)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;CALC_LIB&#125;</span> SHARED <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第6行<code>add_library</code>：生成动态库，动态库名字SORT_LIB是在根节点文件中定义的</li>
</ul>
<p>这个文件中的内容和<code>calc</code>节点文件中的内容类似，只不过这次生成的是动态库。</p>
<h4 id="10-3-3-test1-目录"><a href="#10-3-3-test1-目录" class="headerlink" title="10.3.3 test1 目录"></a>10.3.3 test1 目录</h4><p>test1 目录中的 CMakeLists.txt文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCTEST)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="variable">$&#123;CALC_LIB&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;EXEC_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME_1&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第4行include_directories：指定头文件路径，HEAD_PATH变量是在根节点文件中定义的</li>
<li>第6行link_libraries：指定可执行程序要链接的静态库，CALC_LIB变量是在根节点文件中定义的</li>
<li>第7行set：指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的</li>
<li>第8行add_executable：生成可执行程序，APP_NAME_1变量是在根节点文件中定义的</li>
</ul>
<p>此处的可执行程序链接的是静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被加载到内存中了。</p>
<h4 id="10-3-4-test2-目录"><a href="#10-3-4-test2-目录" class="headerlink" title="10.3.4 test2 目录"></a>10.3.4 test2 目录</h4><p>test2 目录中的 CMakeLists.txt文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(SORTTEST)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;EXEC_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME_2&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;APP_NAME_2&#125;</span> <span class="variable">$&#123;SORT_LIB&#125;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第四行<code>include_directories</code>：包含头文件路径，HEAD_PATH变量是在根节点文件中定义的</li>
<li>第五行<code>set</code>：指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的</li>
<li>第六行<code>link_directories</code>：指定可执行程序要链接的动态库的路径，LIB_PATH变量是在根节点文件中定义的</li>
<li>第七行<code>add_executable</code>：生成可执行程序，APP_NAME_2变量是在根节点文件中定义的</li>
<li>第八行<code>target_link_libraries</code>：指定可执行程序要链接的动态库的名字</li>
</ul>
<p>在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库。</p>
<p><strong>注意：引用变量要使用{},不要用成()</strong></p>
<ul>
<li>set(EXECUTABLE_OUTPUT_PATH <code>$&#123;EXEC_PATH&#125;</code>) 写成如下就会出错：</li>
<li>set(EXECUTABLE_OUTPUT_PATH <code>$(EXEC_PATH)</code>) 就会出错</li>
</ul>
<br>

<h4 id="10-3-4-构建项目"><a href="#10-3-4-构建项目" class="headerlink" title="10.3.4 构建项目"></a>10.3.4 构建项目</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xuan@DESKTOP-A52B6V9:~/linux/demos/cpro$ cd build/</span><br><span class="line">xuan@DESKTOP-A52B6V9:~/linux/demos/cpro/build$ cmake ..</span><br><span class="line">-- The C compiler identification is GNU 11.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 11.4.0</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc - skipped</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ - skipped</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/xuan/linux/demos/cpro/build</span><br><span class="line"></span><br><span class="line">xuan@DESKTOP-A52B6V9:~/linux/demos/cpro/build$ make</span><br><span class="line">[  8%] Building C object calc/CMakeFiles/calc.dir/add.c.o</span><br><span class="line">[ 16%] Building C object calc/CMakeFiles/calc.dir/div.c.o</span><br><span class="line">[ 25%] Building C object calc/CMakeFiles/calc.dir/mult.c.o</span><br><span class="line">[ 33%] Building C object calc/CMakeFiles/calc.dir/sub.c.o</span><br><span class="line">[ 41%] Linking C static library ../../lib/libcalc.a</span><br><span class="line">[ 41%] Built target calc</span><br><span class="line">[ 50%] Building C object sort/CMakeFiles/sort.dir/insert.c.o</span><br><span class="line">[ 58%] Building C object sort/CMakeFiles/sort.dir/select.c.o</span><br><span class="line">[ 66%] Linking C shared library ../../lib/libsort.so</span><br><span class="line">[ 66%] Built target sort</span><br><span class="line">[ 75%] Building C object test2/CMakeFiles/test2.dir/sort.c.o</span><br><span class="line">[ 83%] Linking C executable ../../bin/test2</span><br><span class="line">[ 83%] Built target test2</span><br><span class="line">[ 91%] Building C object test1/CMakeFiles/test1.dir/calc.c.o</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Linking C executable ../../bin/test1</span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target test1</span></span><br></pre></td></tr></table></figure>

<p>通过上述<code>log</code>可以得到如下信息：</p>
<ul>
<li>在项目根目录的<code>lib目录</code>中生成了静态库<code>libcalc.a</code></li>
<li>在项目根目录的<code>lib目录</code>中生成了动态库<code>libsort.so</code></li>
<li>在项目根目录的<code>bin目录</code>中生成了可执行程序<code>test1</code></li>
<li>在项目根目录的<code>bin目录</code>中生成了可执行程序<code>test2</code></li>
</ul>
<p>以下是生成的树状图：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree bin/ lib/</span></span><br><span class="line">bin/</span><br><span class="line">├── test1</span><br><span class="line">└── test2</span><br><span class="line">lib/</span><br><span class="line">├── libcalc.a</span><br><span class="line">└── libsort.so</span><br></pre></td></tr></table></figure>

<ul>
<li>在项目中，如果将程序中的某个模块制作成了动态库或者静态库并且在<code>CMakeLists.txt</code> 中指定了库的输出目录，而后其它模块又需要加载这个生成的库文件，此时直接使用就可以了。</li>
<li>如果没有指定库的输出路径或者需要直接加载外部提供的库文件，此时就需要使用<code>link_directories($&#123;LIB_PATH&#125;)</code>将库文件路径指定出来,然后链接库的名字<code>link_libraries($&#123;CALC_LIB&#125;)</code>。</li>
</ul>
<br>

<h3 id="11-流程控制"><a href="#11-流程控制" class="headerlink" title="11. 流程控制"></a>11. 流程控制</h3><h4 id="11-1-条件判断"><a href="#11-1-条件判断" class="headerlink" title="11.1 条件判断"></a>11.1 条件判断</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;condition&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">elseif</span>(&lt;condition&gt;) <span class="comment"># 可选快, 可以重复</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">else</span>()              <span class="comment"># 可选快</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h5 id="11-1-1-基本表达式"><a href="#11-1-1-基本表达式" class="headerlink" title="11.1.1 基本表达式"></a>11.1.1 基本表达式</h5><ul>
<li><p><code>if(&lt;expression&gt;)</code>: <code>expression</code> 有以下三种情况：常量、变量、字符串。</p>
<ul>
<li>如果是<code>1</code>, <code>ON</code>, <code>YES</code>, <code>TRUE</code>, <code>Y</code>, <code>非零值</code>，<code>非空字符串</code>时，条件判断返回<code>True</code></li>
<li>如果是 <code>0</code>, <code>OFF</code>, <code>NO</code>, <code>FALSE</code>, <code>N</code>, <code>IGNORE</code>, <code>NOTFOUND</code>，<code>空字符串</code>时，条件判断返回<code>False</code></li>
</ul>
</li>
</ul>
<br>

<h5 id="11-1-2-逻辑判断"><a href="#11-1-2-逻辑判断" class="headerlink" title="11.1.2 逻辑判断"></a>11.1.2 逻辑判断</h5><ul>
<li>if(NOT <condition>)</li>
<li>if(<cond1> AND <cond2>)</li>
<li>if(<cond1> OR <cond2>)</li>
</ul>
<br>

<h5 id="11-1-3-比较"><a href="#11-1-3-比较" class="headerlink" title="11.1.3 比较"></a>11.1.3 比较</h5><ul>
<li><code>if(&lt;variable|string&gt; &lt;COMMAND&gt; &lt;variable|string&gt;)</code></li>
<li>&lt;<code>COMMAND</code>&gt;为如下值的解释：<ul>
<li><code>LESS</code>：如果左侧数值&#x2F;字符串<code>小于</code>右侧，返回<code>True</code></li>
<li><code>GREATER</code>：如果左侧数值&#x2F;字符串<code>大于</code>右侧，返回<code>True</code></li>
<li><code>EQUAL</code>：如果左侧数值&#x2F;字符串<code>等于</code>右侧，返回<code>True</code></li>
<li><code>LESS_EQUAL</code>：如果左侧数值&#x2F;字符串<code>小于等于</code>右侧，返回<code>True</code></li>
<li><code>GREATER_EQUAL</code>：如果左侧数值&#x2F;字符串<code>大于等于</code>右侧，返回<code>True</code></li>
</ul>
</li>
</ul>
<br>

<h5 id="11-1-4-文件操作"><a href="#11-1-4-文件操作" class="headerlink" title="11.1.4 文件操作"></a>11.1.4 文件操作</h5><p><strong>存在&#x2F;是</strong>返回<code>True</code>，<strong>不存在&#x2F;否</strong>返回<code>False</code></p>
<ul>
<li>判断文件或者目录是否存在：<code>if(EXISTS path-to-file-or-directory)</code></li>
<li>判断是不是目录：<code>if(IS_DIRECTORY path)</code><ul>
<li>此处目录的 <code>path</code> 必须是绝对路径</li>
</ul>
</li>
<li>判断是不是软连接：<code>if(IS_SYMLINK file-name)</code><ul>
<li>此处的 <code>file-name</code> 对应的路径必须是绝对路径</li>
<li>软链接相当于 <code>Windows</code> 里的快捷方式</li>
</ul>
</li>
<li>判断是不是绝对路径：<code>if(IS_ABSOLUTE path)</code><ul>
<li>如果绝对路径是Linux，该路径需要从根目录开始描述</li>
<li>如果绝对路径是Windows，该路径需要从盘符开始描述</li>
</ul>
</li>
</ul>
<br>

<h5 id="11-1-5-其他"><a href="#11-1-5-其他" class="headerlink" title="11.1.5 其他"></a>11.1.5 其他</h5><ul>
<li>判断某个元素是否在列表中：<code>if(&lt;variable|string&gt; IN_LIST &lt;variable&gt;)</code></li>
<li>比较两个路径是否相等：<code>if(&lt;variable|string&gt; PATH_EQUAL &lt;variable|string&gt;)</code></li>
</ul>
<br>

<h4 id="11-2-循环"><a href="#11-2-循环" class="headerlink" title="11.2 循环"></a>11.2 循环</h4><p>在 <code>CMake</code> 中循环有两种方式，分别是：<code>foreach</code>和<code>while</code>。</p>
<h5 id="11-2-1-foreach"><a href="#11-2-1-foreach" class="headerlink" title="11.2.1 foreach"></a>11.2.1 foreach</h5><p>使用 foreach 进行循环，语法格式如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; &lt;items&gt;)</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>foreach(&lt;loop_var&gt; RANGE &lt;stop&gt;)</code><ul>
<li><code>RANGE</code>：关键字，表示要遍历范围</li>
<li><code>stop</code>：这是一个正整数，表示范围的结束值，在遍历的时候从 0 开始，最大值为 <code>stop</code>。</li>
<li><code>loop_var</code>：存储每次循环取出的值</li>
</ul>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>上面例子输出<code>0~10</code></p>
<br>

<ul>
<li><code>foreach(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;])</code><ul>
<li><code>RANGE</code>：关键字，表示要遍历范围</li>
<li><code>start</code>：这是一个正整数，表示范围的起始值，也就是说最小值为 <code>start</code></li>
<li><code>stop</code>：这是一个正整数，表示范围的结束值，也就是说最大值为 <code>stop</code></li>
<li><code>step</code>：控制每次遍历的时候以怎样的步长增长，默认为<code>1</code>，可以不设置<br>  -<code>loop_var</code>：存储每次循环取出的值</li>
</ul>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">10</span> <span class="number">30</span> <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>上面例子输出<code>10~30</code>,从<code>10</code>开始,每次增长<code>2</code>。</p>
<br>

<ul>
<li><code>foreach(&lt;loop_var&gt; IN [LISTS [&lt;lists&gt;]] [ITEMS [&lt;items&gt;]])</code><ul>
<li><code>IN</code>：关键字，表示在 <code>xxx</code> 里边</li>
<li><code>LISTS</code>：关键字，对应的是列表<code>list</code>，通过<code>set</code>、<code>list</code>可以获得</li>
<li><code>ITEMS</code>：关键字，对应的也是列表</li>
<li><code>loop_var</code>：存储每次循环取出的值</li>
</ul>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 创建 list</span></span><br><span class="line"><span class="keyword">set</span>(WORD a b c d)</span><br><span class="line"><span class="keyword">set</span>(NAME ace sabo luffy)</span><br><span class="line"><span class="comment"># 遍历 list</span></span><br><span class="line"><span class="keyword">foreach</span>(item IN LISTS WORD NAME)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，创建了两个 <code>list</code> 列表，在遍历的时候对它们两个都进行了遍历（可以根据实际需求选择同时遍历多个或者只遍历一个）</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(WORD a b c <span class="string">&quot;d e f&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(NAME ace sabo luffy)</span><br><span class="line"><span class="keyword">foreach</span>(item IN ITEMS <span class="variable">$&#123;WORD&#125;</span> <span class="variable">$&#123;NAME&#125;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，遍历过程中将关键字<code>LISTS</code>改成了<code>ITEMS</code>，后边跟的还是一个或者多个列表，只不过此时需要通过<code>$&#123;&#125;</code>将列表中的值取出。其输出的信息和上一个例子是一样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: a</span><br><span class="line">-- 当前遍历的值为: b</span><br><span class="line">-- 当前遍历的值为: c</span><br><span class="line">-- 当前遍历的值为: d e f</span><br><span class="line">-- 当前遍历的值为: ace</span><br><span class="line">-- 当前遍历的值为: sabo</span><br><span class="line">-- 当前遍历的值为: luffy</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure>

<p>小细节：在通过 set 组织列表的时候，如果某个字符串中有空格，可以通过双引号将其包裹起来，具体的操作方法可以参考上面的例子。</p>
<br>

<ul>
<li><code>foreach(&lt;loop_var&gt;... IN ZIP_LISTS &lt;lists&gt;)</code><ul>
<li><code>loop_var</code>：存储每次循环取出的值，可以根据要遍历的列表的数量指定多个变量，用于存储对应的列表当前取出的那个值。<ul>
<li>如果指定了多个变量名，它们的数量应该和列表的数量相等</li>
<li>如果只给出了一个 <code>loop_var</code>，那么它将一系列的 <code>loop_var_N</code> 变量来存储对应列表中的当前项，也就是说 <code>loop_var_0</code> 对应第一个列表，<code>loop_var_1</code> 对应第二个列表，以此类推……</li>
<li>如果遍历的多个列表中一个列表较短，当它遍历完成之后将不会再参与后续的遍历（因为其它列表还没有遍历完）。</li>
</ul>
</li>
<li><code>IN</code>：关键字，表示在 <code>xxx</code> 里边</li>
<li><code>ZIP_LISTS</code>：关键字，对应的是列表<code>list</code>，通过<code>set</code> 、<code>list</code>可以获得</li>
</ul>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 通过list给列表添加数据</span></span><br><span class="line"><span class="keyword">list</span>(APPEND WORD hello world <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">list</span>(APPEND NAME ace sabo luffy zoro sanji)</span><br><span class="line"><span class="comment"># 遍历列表</span></span><br><span class="line"><span class="keyword">foreach</span>(item1 item2 IN ZIP_LISTS WORD NAME)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: item1 = $&#123;item1&#125;, item2=$&#123;item2&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;=============================&quot;</span>)</span><br><span class="line"><span class="comment"># 遍历列表</span></span><br><span class="line"><span class="keyword">foreach</span>(item  IN ZIP_LISTS WORD NAME)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: item1 = $&#123;item_0&#125;, item2=$&#123;item_1&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>在这个例子中关于列表数据的添加是通过<code>list</code>来实现的。在遍历列表的时候一共使用了两种方式，一种提供了多个变量来存储当前列表中的值，另一种只有一个变量，但是实际取值的时候需要通过<code>变量名_0、变量名_1、变量名_N</code> 的方式来操作，<code>注意事项：第一个列表对应的编号是0，第一个列表对应的编号是0，第一个列表对应的编号是0。</code></p>
<p>上面的例子输出的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: item1 = hello, item2=ace</span><br><span class="line">-- 当前遍历的值为: item1 = world, item2=sabo</span><br><span class="line">-- 当前遍历的值为: item1 = hello world, item2=luffy</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=zoro</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=sanji</span><br><span class="line">=============================</span><br><span class="line">-- 当前遍历的值为: item1 = hello, item2=ace</span><br><span class="line">-- 当前遍历的值为: item1 = world, item2=sabo</span><br><span class="line">-- 当前遍历的值为: item1 = hello world, item2=luffy</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=zoro</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=sanji</span><br><span class="line">-- Configuring done (0.0s)</span><br><span class="line">-- Generating done (0.0s)</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure>

<br>

<h5 id="11-2-2-while"><a href="#11-2-2-while" class="headerlink" title="11.2.2 while"></a>11.2.2 while</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(&lt;condition&gt;)</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure>
<p><code>while</code> 比较简单就不做描述了。</p>
<br>

<h3 id="12-cmake设置编译器"><a href="#12-cmake设置编译器" class="headerlink" title="12. cmake设置编译器"></a>12. cmake设置编译器</h3><h4 id="12-1-命令行"><a href="#12-1-命令行" class="headerlink" title="12.1 命令行"></a>12.1 命令行</h4><p>在命令行中指定编译器，你可以在调用 <code>cmake</code> 命令时使用 <code>-DCMAKE_C_COMPILER</code> 和 <code>-DCMAKE_CXX_COMPILER</code> 选项来分别为<code>C</code>和<code>C++</code>设置编译器。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ /path/to/source</span><br></pre></td></tr></table></figure>

<br>

<h4 id="12-2-CMakeLists-txt"><a href="#12-2-CMakeLists-txt" class="headerlink" title="12.2 CMakeLists.txt"></a>12.2 CMakeLists.txt</h4><p>在项目的 <code>CMakeLists.txt</code> 文件中，你可以使用 <code>set</code> 命令来指定编译器：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER /user/bin/gcc)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER /user/bin/g++)</span><br></pre></td></tr></table></figure>

<br>

<h4 id="12-3-工具链文件"><a href="#12-3-工具链文件" class="headerlink" title="12.3 工具链文件"></a>12.3 工具链文件</h4><p><code>CMake</code>允许使用所谓的“工具链文件”（toolchain file）来指定编译器和工具链设置。这在跨平台构建时非常有用。工具链文件是一个普通的<code>CMake</code>脚本，它设置了构建系统所需的编译器和工具链选项。例如，创建一个名为 <code>toolchain.cmake</code> 的文件，并在其中设置编译器：</p>
<pre><code>set(CMAKE_C_COMPILER gcc)
set(CMAKE_CXX_COMPILER g++)
</code></pre>
<p>然后在调用 <code>cmake</code> 命令时指定工具链文件：</p>
<pre><code>cmake -DCMAKE_TOOLCHAIN_FILE=path/to/toolchain.cmake /path/to/source
</code></pre>
<p>请记住，一旦<code>CMake</code>缓存生成，更改编译器的设置就需要清理<code>CMake</code>缓存并重新运行<code>CMake</code>配置。这是因为<code>CMake</code>在第一次运行时会将编译器和工具链的信息缓存起来，以便后续构建使用。</p>
]]></content>
      <categories>
        <category>自动编译工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt5学习笔记</title>
    <url>/2024/04/30/Qt5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><strong>Qt官方下载地址</strong>: <a href="https://download.qt.io/archive/qt/">https://download.qt.io/archive/qt/</a></li>
<li><strong>参考教程文档</strong>: <a href="https://subingwen.cn/qt/qt-primer/">https://subingwen.cn/qt/qt-primer/</a></li>
</ul>
<br>

<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="打印问题"><a href="#打印问题" class="headerlink" title="打印问题"></a>打印问题</h3><p><strong>问题现象：</strong></p>
<ul>
<li>在Qt Creater中，使用<code>qDebug()</code>打印信息时，在调试界面中，<code>qDebug()</code>的输出信息会显示在调试终端，当直接运行<code>.exe</code>文件时，<code>qDebug()</code>的输出信息会丢失。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;这是测试打印程序&quot;</span> &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<ul>
<li>在<code>qt.pro</code>工程文件中中，添加如下代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CONFIG += c++<span class="number">17</span> console			<span class="comment">//添加console</span></span><br></pre></td></tr></table></figure></li>
<li>勾选以下选项：</li>
</ul>
<p><img src="/../pictures/qt_terminal%E9%85%8D%E7%BD%AE.png" alt="qt_terminal配置"></p>
<p><strong>总结：</strong></p>
<ul>
<li>需要重新编译代码，<code>.exe</code>文件更新后生效。</li>
<li>再次编译运行时,会弹出<code>terminal</code>。</li>
</ul>
]]></content>
      <categories>
        <category>图形界面</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile笔记</title>
    <url>/2024/05/08/Makefile%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<br>

<h2 id="makefile问题汇总"><a href="#makefile问题汇总" class="headerlink" title="makefile问题汇总"></a>makefile问题汇总</h2><h3 id="修改-h文件没有重新编译"><a href="#修改-h文件没有重新编译" class="headerlink" title="修改.h文件没有重新编译"></a>修改.h文件没有重新编译</h3><ul>
<li>定义<code>COMPILE_FLAGS = -MD</code>或者<code>-MMD</code>, 编译器标志，用于生成 <code>.d</code> 文件</li>
<li><code>$(BUILD_DIR)</code>为编译文件目录，跟进自身makefile修改，原来的编译规则：</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">-include</span> <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(BUILD_DIR)</span>/*/*.d)</span>	<span class="comment"># 包含所有生成的依赖文件，避免重复编译、提高效率</span></span><br></pre></td></tr></table></figure>
<p><code>/*/*.d</code> 为当前目录下的二级所有文件检索。</p>
<ul>
<li>修改为以下编译规则：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到所有的 .d 文件</span></span><br><span class="line">DEP_FILES := <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(BUILD_DIR)</span> -type f -name &#x27;*.d&#x27;)</span><span class="comment"># 包含所有生成的依赖文件，避免重复编译、提高效率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含所有的 .d 文件</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEP_FILES)</span></span><br></pre></td></tr></table></figure>
或者：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-include $(wildcard $(BUILD_DIR)<span class="comment">/**/</span>*.d)</span><br><span class="line">-include $(wildcard $(BUILD_DIR)<span class="comment">/*/*/</span>*.d)</span><br></pre></td></tr></table></figure>
<code>/**/*.d</code> 它允许你搜索和匹配嵌套在任意深度的目录中的文件。<br><code>/*/*/*.d</code> 为当前目录下的三级所有文件检索，根据具体情况修改。</li>
</ul>
<br>

<h3 id=""><a href="#" class="headerlink" title="$&lt; 和 $^ 的区别"></a><code>$&lt;</code> 和 <code>$^</code> 的区别</h3><p>在<code>Makefile</code>中，<code>$&lt;</code> 和 <code>$^</code> 是两个自动变量，它们在规则中用来引用规则的依赖文件，但它们的用途和行为有所不同：</p>
<ul>
<li><p><code>$&lt;</code> - 代表规则的第一个依赖文件。</p>
<ul>
<li>当规则有多个依赖文件时，<code>$&lt;</code> 只引用第一个依赖文件。</li>
<li>它通常用于指定要编译的源文件，特别是在编译单个目标文件时。</li>
</ul>
</li>
<li><p><code>$^</code> - 代表规则的所有依赖文件。</p>
<ul>
<li>无论规则有多少个依赖文件，<code>$^</code> 都会将它们全部列出。</li>
<li>它常用于链接阶段，当你需要将多个目标文件链接成最终的可执行文件时。</li>
</ul>
</li>
</ul>
<p>举个例子来说明它们的不同：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设有一个目标文件 main.o 需要两个源文件 main.c 和 utils.c 来生成</span></span><br><span class="line"><span class="section">main.o: main.c utils.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c main.c -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个例子中，$&lt; 就是 main.c，而 $^ 就是 main.c utils.c</span></span><br></pre></td></tr></table></figure>

<p>再看一个示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: %.c</span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDE)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>这个规则的意思是，对于<code>$(BUILD_DIR)</code>目录下的每个<code>.o</code>文件，都有一个对应的<code>.c</code>文件。在<code>Makefile</code>中，<code>$&lt;</code> 是一个自动变量，它代表当前规则的第一个依赖文件。然而，<code>$&lt;</code> 并不会直接依赖所有的 <code>.c</code> 文件，而是依赖于当前规则的 <strong>第一个依赖文件</strong>。</p>
<p>总结一下：</p>
<ul>
<li>使用 <code>$&lt;</code> 时，只有第一个依赖文件会被考虑。</li>
<li>使用 <code>$^</code> 时，所有依赖文件都会被考虑。</li>
</ul>
<p>在实际编写Makefile时，根据你的需要选择合适的变量。</p>
<br>

<h3 id="makefile伪指令"><a href="#makefile伪指令" class="headerlink" title="makefile伪指令"></a>makefile伪指令</h3><p>在 <code>Makefile</code> 中，<code>.PHONY</code> 是一个特殊的声明，用来指出一些目标并不是实际的文件，而是一些需要执行的命令序列。这样做可以让 <code>Make</code> 工具在遇到同名文件时，不会误认为这些目标是要操作的文件，而是要执行的命令。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean all copy mix download</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span>.bin <span class="variable">$(TARGET)</span>.list <span class="variable">$(TARGET)</span>.hex</span></span><br><span class="line">	<span class="variable">$(SZ)</span> <span class="variable">$(TARGET)</span>.elf</span><br><span class="line">	@make copy</span><br><span class="line">	@make mix</span><br><span class="line">	</span><br><span class="line"><span class="section">copy: <span class="variable">$(TARGET)</span>.bin</span></span><br><span class="line">	cp <span class="variable">$(TARGET)</span>.bin app.bin</span><br><span class="line">	cp ../bootloader/bootloader.bin bootloader.bin</span><br><span class="line"><span class="comment">#	cp $(TARGET).hex app.hex</span></span><br><span class="line"></span><br><span class="line"><span class="section">mix:</span></span><br><span class="line">	./tools/papp_up</span><br><span class="line">	./tools/mix_10K</span><br><span class="line">	<span class="variable">$(OC)</span> -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex</span><br><span class="line">	rm bootloader.bin</span><br><span class="line">	rm app.bin</span><br><span class="line">	rm mix.bin</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line">	rm papp.bin</span><br><span class="line">	rm mix.hex</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Makefile</code>默认执行的是 <strong>第一个目标</strong>（不包括以点开头的目标）<code>all</code>，而不是 <code>.PHONY</code> 后的第一个目标。<code>.PHONY</code> 宏的作用是防止<code>Make</code>错误地将伪目标与文件系统中的文件混淆。</li>
<li><code>make</code>会加载依赖<code>$(TARGET).bin</code> <code>$(TARGET).list</code> <code>$(TARGET).hex</code> <code>$(SZ) $(TARGET).elf</code>。</li>
<li><code>@</code>符号使得 <code>Make</code> 工具在执行命令时不会打印该命令本身,如<code>make copy</code>。</li>
<li><strong>拓展</strong>：<code>$(OC) -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex</code>表示将 <code>mix.bin</code> 的二进制文件转换为名为 <code>mix.hex</code> 的 <code>Intel HEX</code>格式文件，并将所有地址偏移设置为 <code>0x8000000</code></li>
</ul>
<br>

<h2 id="n32g452rc的makefile解析"><a href="#n32g452rc的makefile解析" class="headerlink" title="n32g452rc的makefile解析"></a>n32g452rc的makefile解析</h2><p><strong><code>makefile</code>源码：</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># C编译器的宏定义</span></span><br><span class="line">C_DEFS +=  \</span><br><span class="line">-DN32G45X \</span><br><span class="line">-DUSE_STDPERIPH_DRIVER</span><br><span class="line"></span><br><span class="line"><span class="comment"># C编译器的头文件搜索路径</span></span><br><span class="line">INCLUDE +=  \</span><br><span class="line">-ICMSIS/core  \</span><br><span class="line">-ICMSIS/device	\</span><br><span class="line">-Istd_periph_lib/inc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># APP源文件</span></span><br><span class="line">C_APP_SOURCES +=  \</span><br><span class="line">application/main.c \</span><br><span class="line">application/n32g45x_it.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间层驱动源文件</span></span><br><span class="line">C_DRV_SOURCES +=  \</span><br><span class="line">msp/drv_msp.c \</span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> rtt-nano/src/*.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># C编译器的底层驱动源文件</span></span><br><span class="line">C_LIB_SOURCES +=  \</span><br><span class="line">CMSIS/device/system_n32g45x.c \</span><br><span class="line">std_periph_lib/src/misc.c \</span><br><span class="line">std_periph_lib/src/n32g45x_rcc.c</span><br><span class="line"></span><br><span class="line">C_SOURCES += <span class="variable">$(C_LIB_SOURCES)</span></span><br><span class="line">C_SOURCES += <span class="variable">$(C_APP_SOURCES)</span></span><br><span class="line">C_SOURCES += <span class="variable">$(C_DRV_SOURCES)</span></span><br><span class="line"></span><br><span class="line">ASM_SOURCES +=  \</span><br><span class="line">CMSIS/device/startup/startup_n32g45x_gcc.S \</span><br><span class="line">rtt-nano/libcpu/arm/cortex-m4/context_gcc.S</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定交叉编译工具链的 编译器、连接器、库管理器、</span></span><br><span class="line">CROSS_COMPILE=arm-none-eabi-</span><br><span class="line">CC=<span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">LD=<span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">AR=<span class="variable">$(CROSS_COMPILE)</span>ar</span><br><span class="line">AS=<span class="variable">$(CROSS_COMPILE)</span>as</span><br><span class="line">OC=<span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OD=<span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line">SZ=<span class="variable">$(CROSS_COMPILE)</span>size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定目标硬件的架构和浮点运算单元   -mfpu=fpv4-sp-d16 -mfloat-abi=hard -mfloat-abi=soft </span></span><br><span class="line">MCU = -mcpu=cortex-m4 -mthumb \</span><br><span class="line">	-ffunction-sections \</span><br><span class="line">	-fdata-sections \</span><br><span class="line">	--specs=nano.specs \</span><br><span class="line">	--specs=nosys.specs \</span><br><span class="line">	-Os -ggdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编译C源文件的编译选项：禁用共享变量、函数和数据分段、优化级别、调试信息级别、开启所有警告、目标架构、预定义宏</span></span><br><span class="line"><span class="comment"># O0:禁用优化，O1：基本优化，O2, O3, Os</span></span><br><span class="line"><span class="comment"># g0:禁用调试信息, g1, g2, g3, g</span></span><br><span class="line">CFLAGS += -c -fno-common \</span><br><span class="line">	--specs=rdimon.specs \</span><br><span class="line">	-std=gnu99 -mabi=aapcs \</span><br><span class="line">	-Wall \</span><br><span class="line">	<span class="variable">$(MCU)</span> \</span><br><span class="line">	<span class="variable">$(C_DEFS)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义链接器脚本、链接选项、目标文件格式转换选项、反汇编 -nostdlib -lnosys</span></span><br><span class="line">LDSCRIPT=n32g452_flash.ld</span><br><span class="line">LDFLAGS += -Wl,--gc-sections --data-sections -mabi=aapcs <span class="variable">$(MCU)</span> -T<span class="variable">$(LDSCRIPT)</span> \</span><br><span class="line">	-x assembler-with-cpp -Wa,-mimplicit-it=thumb</span><br><span class="line"></span><br><span class="line"><span class="comment"># printf打印浮点数</span></span><br><span class="line"><span class="comment"># LDFLAGS += -lc -lrdimon -u _printf_float</span></span><br><span class="line"></span><br><span class="line">OCFLAGS	= -Obinary</span><br><span class="line">ODFLAGS	= -S</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出目录和目标文件名</span></span><br><span class="line">BUILD_DIR = build</span><br><span class="line">TARGET  = <span class="variable">$(BUILD_DIR)</span>/app</span><br><span class="line"></span><br><span class="line"><span class="comment"># C源文件、汇编源文件的目标文件路径</span></span><br><span class="line">C_OBJECTS = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BUILD_DIR)</span>/, $(C_SOURCES:.c=.o)</span>)</span><br><span class="line">ASM_OBJECTS = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BUILD_DIR)</span>/, $(ASM_SOURCES:.S=.o)</span>)</span><br><span class="line">OBJECTS += <span class="variable">$(ASM_OBJECTS)</span> <span class="variable">$(C_OBJECTS)</span></span><br><span class="line"></span><br><span class="line">.PHONY : clean all</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span>.bin <span class="variable">$(TARGET)</span>.list <span class="variable">$(TARGET)</span>.hex</span></span><br><span class="line">	<span class="variable">$(SZ)</span> <span class="variable">$(TARGET)</span>.elf</span><br><span class="line">	@make copy</span><br><span class="line">	@make mix</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: copy</span></span><br><span class="line"></span><br><span class="line"><span class="section">copy: <span class="variable">$(TARGET)</span>.bin</span></span><br><span class="line">	cp <span class="variable">$(TARGET)</span>.bin app.bin</span><br><span class="line">	cp ../bootloader/bootloader.bin bootloader.bin</span><br><span class="line"><span class="comment">#	cp $(TARGET).hex app.hex</span></span><br><span class="line"></span><br><span class="line"><span class="section">mix:</span></span><br><span class="line">	./tools/papp_up</span><br><span class="line">	./tools/mix_10K</span><br><span class="line">	<span class="variable">$(OC)</span> -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex</span><br><span class="line">	rm bootloader.bin</span><br><span class="line">	rm app.bin</span><br><span class="line">	rm mix.bin</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line">	rm papp.bin</span><br><span class="line">	rm mix.hex</span><br><span class="line"></span><br><span class="line">SYS := <span class="variable">$(<span class="built_in">shell</span> uname -a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">findstring</span> Microsoft,<span class="variable">$(SYS)</span>)</span>,Microsoft)</span><br><span class="line"><span class="section">COPY_CMD:</span></span><br><span class="line">	cp <span class="variable">$(TARGET)</span>.hex <span class="string">&quot;/mnt/c/Users/Breo/Desktop/iap-tools/linux_download&quot;</span></span><br><span class="line">	wsl.exe -d Ubuntu-20.04 cmd.exe /c <span class="string">&quot;C:\\\Users\\\BREO\\\Desktop\\\iap-tools\\\linux_download\\\program452RC.bat&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="section">COPY_CMD:</span></span><br><span class="line">	echo <span class="string">&quot;当前系统不是 WSL，跳过拷贝文件指令&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">download:</span></span><br><span class="line">	@make all</span><br><span class="line">	@<span class="variable">$(MAKE)</span> COPY_CMD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义生成目标文件的规则</span></span><br><span class="line"><span class="variable">$(TARGET)</span>.list: <span class="variable">$(TARGET)</span>.elf</span><br><span class="line">	<span class="variable">$(OD)</span> <span class="variable">$(ODFLAGS)</span> <span class="variable">$&lt;</span> &gt; <span class="variable">$(TARGET)</span>.lst</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>.bin: <span class="variable">$(TARGET)</span>.elf</span><br><span class="line">	<span class="variable">$(OC)</span> <span class="variable">$(OCFLAGS)</span> <span class="variable">$(TARGET)</span>.elf <span class="variable">$(TARGET)</span>.bin</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>.elf: <span class="variable">$(OBJECTS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(ASM_OBJECTS)</span> <span class="variable">$(C_OBJECTS)</span> <span class="variable">$(LDFLAGS)</span> -Wl,-Map=<span class="variable">$(TARGET)</span>.map -o <span class="variable">$(TARGET)</span>.elf</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>.hex: <span class="variable">$(TARGET)</span>.elf</span><br><span class="line">	<span class="variable">$(OC)</span> -O ihex <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编译C源文件、汇编源文件的规则，将源文件编译成目标文件</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: %.c</span><br><span class="line">	mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -MMD -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: %.S</span><br><span class="line">	mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#-include $(wildcard $(BUILD_DIR)/**/*.d)	# 包含所有生成的依赖文件，避免重复编译、提高效率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到所有的 .d 文件</span></span><br><span class="line">DEP_FILES := <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(BUILD_DIR)</span> -type f -name &#x27;*.d&#x27;)</span><span class="comment"># 包含所有生成的依赖文件，避免重复编译、提高效率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含所有的 .d 文件</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEP_FILES)</span></span><br></pre></td></tr></table></figure>
<p>下面是对这段代码的逐句分析：</p>
<ol>
<li><p>宏定义 (<code>C_DEFS</code>):</p>
<ul>
<li><code>-DN32G45X</code> 和 <code>-DUSE_STDPERIPH_DRIVER</code> 是编译器的宏定义，用于在编译时定义特定的预处理变量。</li>
</ul>
</li>
</ol>
<br>

<ol start="2">
<li><p>头文件搜索路径 (<code>INCLUDE</code>):</p>
<p> <code>-ICMSIS/core</code>, <code>-ICMSIS/device</code>, <code>-Istd_periph_lib/inc</code> 指定了编译器搜索头文件的路径。</p>
</li>
</ol>
<br>

<ol start="3">
<li><p>应用层源文件 (<code>C_APP_SOURCES</code>):</p>
<ul>
<li>列出了应用层的 <code>C</code> 源文件。</li>
</ul>
</li>
</ol>
<br>

<ol start="4">
<li><p>中间层驱动源文件 (<code>C_DRV_SOURCES</code>):</p>
<ul>
<li>使用 $(wildcard rtt-nano&#x2F;src&#x2F;*.c) 来匹配 rtt-nano&#x2F;src 目录下的所有 .c 文件。</li>
</ul>
</li>
</ol>
<br>

<ol start="5">
<li><p>底层驱动源文件 (<code>C_LIB_SOURCES</code>):</p>
<ul>
<li>列出了底层驱动的 C 源文件。</li>
</ul>
</li>
</ol>
<br>

<ol start="6">
<li><p>源文件汇总 (<code>C_SOURCES</code>):</p>
<ul>
<li>将应用层、中间层和底层驱动的源文件汇总到 <code>C_SOURCES。</code></li>
</ul>
</li>
</ol>
<br>

<ol start="7">
<li><p>汇编源文件 (<code>ASM_SOURCES</code>):</p>
<ul>
<li>列出了汇编语言的源文件。</li>
</ul>
</li>
</ol>
<br>

<ol start="8">
<li><p>交叉编译工具链 (<code>CROSS_COMPILE</code>, <code>CC</code>, <code>LD</code>, <code>AR</code>, <code>AS</code>, <code>OC</code>, <code>OD</code>, <code>SZ</code>):</p>
<ul>
<li>定义了交叉编译工具链的前缀和各个工具（编译器、链接器、库管理器等）的命令。</li>
</ul>
</li>
</ol>
<br>

<ol start="9">
<li><p>目标硬件的架构和浮点运算单元 (<code>MCU</code>):</p>
<ul>
<li><p><code>-mcpu=cortex-m4</code>:</p>
<ul>
<li>编译器目标处理器是 <code>Cortex-M4</code> CPU</li>
<li><code>-mcpu=</code> 后面跟的是具体的目标 CPU 型号</li>
</ul>
</li>
<li><p><code>-mthumb</code>:</p>
<ul>
<li>编译器生成 <code>Thumb</code> 指令集的代码。<code>Thumb</code> 指令集是 <code>ARM</code> 架构的一种<code>16位指令集</code>,用于嵌入式系统以减少内存占用和提高代码密度。</li>
</ul>
</li>
<li><p><code>-ffunction-sections</code>:</p>
<ul>
<li>允许编译器将 <strong>每个函数</strong> 分别放入程序的 <strong>单独段</strong> 中。这可以使得链接器在最终的链接阶段丢弃未使用的函数，从而<em>减小最终固件的大小</em>。</li>
</ul>
</li>
<li><p><code>-fdata-sections</code>:</p>
<ul>
<li>类似于 <code>-ffunction-sections</code>，这个选项允许编译器将 <strong>不同的数据</strong> 放入程序的 <strong>不同段</strong> 中。这同样有助于链接器优化，<code>移除未使用的数据段</code>。</li>
</ul>
</li>
<li><p><code>--specs=nano.specs</code>:</p>
<ul>
<li>这个选项指定使用新<code>libnano</code>规格，这是针对小型嵌入式系统的 <strong>C 标准库的缩减版本</strong>。它提供了比标准<code> C</code> 库 <strong>更小的占用空间</strong>，适合资源受限的系统。</li>
</ul>
</li>
<li><p><code>--specs=nosys.specs</code>:</p>
<ul>
<li>这个选项指定编译器使用 <code>nosys</code> 作为系统调用的默认返回值。在嵌入式系统中，系统调用可能并不总是可用，这个选项 <strong>允许编译器生成不依赖系统调用的代码</strong>。</li>
</ul>
</li>
<li><p><code>-Os</code>:</p>
<ul>
<li>这个选项指示编译器<code>优化大小</code>。编译器会尝试在不牺牲太多性能的情况下，生成尽可能小的代码。还有 <code>-O0(无优化)</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Og</code>(优化调试,不是优化性能或大小)</li>
</ul>
</li>
<li><p><code>-ggdb</code>:</p>
<ul>
<li>这个选项用于生成调试信息。<code>-g</code> 让编译器在对象文件中包含调试信息，使得开发者可以使用调试器（如 <code>GDB</code>）来调试程序。</li>
</ul>
</li>
<li><p><code>-mfpu=fpv4-sp-d16</code>(未使用):</p>
<ul>
<li>符合 <code>FPU 版本 4（FPv4）</code>的浮点单元，它支持单精度（<code>single-precision</code>）和双精度（<code>double-precision</code>）浮点运算。<code>-sp-d16</code> 表示该 <code>FPU</code> 拥有 <code>16</code> 个双精度寄存器，它们被组织为 <code>32</code> 个单精度寄存器。</li>
</ul>
</li>
<li><p><code>-mfloat-abi=hard</code>(未使用):</p>
<ul>
<li>这个选项指定使用“硬”浮点 <code>ABI</code>，意味着浮点运算将使用目标硬件的 FPU 执行，并且浮点函数（如 <code>sin</code>、<code>cos</code>、<code>sqrt</code> 等）将被实现为直接调用硬件支持的浮点指令。这通常可以提高性能，因为 <strong>浮点运算更快</strong>，但可能会 <strong>增加固件的大小</strong>，因为需要包含 FPU 的指令集。</li>
</ul>
</li>
<li><p><code>-mfloat-abi=soft</code>(未使用):</p>
<ul>
<li>soft 浮点 ABI 指定浮点运算将通过软件库实现，而不是直接使用硬件 FPU。这种方式可以 <strong>生成更小的代码</strong>，因为不需要包含 FPU 的指令集，但运行时的 <strong>浮点运算会较慢</strong>，因为它们需要通过软件模拟。</li>
</ul>
</li>
</ul>
<p> <strong>注意：</strong><code>-mfpu=fpv4-sp-d16</code> 与 <code>-mfloat-abi=hard</code> 或 <code>-mfloat-abi=soft</code> 选项一起使用。</p>
</li>
</ol>
<br>

<ol start="10">
<li>编译选项 (<code>CFLAGS</code>):<br>定义了编译 <code>C</code> 源文件时使用的选项,<code>$(MCU)</code> 和 <code>$(C_DEFS)</code>上面有解释，不过多阐述。<ul>
<li><code>-c</code>:<ul>
<li>这个选项告诉编译器 <strong>仅编译源代码</strong> 文件而 <strong>不进行链接</strong>。编译器会为每个源文件生成一个目标（<code>object</code>）文件，这些目标文件 <strong>随后可以被链接</strong> 器链接成<strong>可执行文件</strong>或<strong>库</strong>。</li>
</ul>
</li>
<li><code>-fno-common</code>:<ul>
<li>在一些系统中，<code>-fcommon</code> 是默认行为，它允许存在多个未初始化的相同大小的全局变量或静态变量，它们在<strong>链接时合并为一个</strong>。<code>-fno-common</code> 选项禁用了这一行为，要求每个全局变量或静态变量都有其自己的内存位置。这在嵌入式系统或某些特定系统中可能是必需的。</li>
</ul>
</li>
<li><code>--specs=rdimon.specs</code>:<ul>
<li>这个选项指定使用 <code>rdimon.specs</code> 文件作为编译器的规格说明。规格说明文件包含了特定于系统的编译和链接规则，<code>rdimon.specs</code> 可能是指某个特定实时操作系统（<code>RTOS</code>）或嵌入式平台的规格。</li>
</ul>
</li>
<li><code>-std=gnu99</code>:<ul>
<li>这个选项指定编译器遵循 <code>ISO C99</code> 标准，同时包括 GNU 的扩展。gnu99 意味着除了标准的 <code>C99</code> 特性外，编译器还会接受 GNU C 的特定扩展。</li>
</ul>
</li>
<li><code>-mabi=aapcs</code>:<ul>
<li>这个选项指定使用 <code>ARM</code> 架构程序调用标准（<code>AAPCS，ARM Architecture Procedure Call Standard</code>）。<code>AAPCS</code> 定义了函数调用时的参数传递、返回值以及寄存器使用等规则。</li>
</ul>
</li>
<li><code>-Wall</code>:<ul>
<li>这个选项告诉编译器打开大多数警告信息。虽然 <code>-Wall</code> 并不打开所有的警告选项，但它会启用大量标准警告，帮助开发者发现潜在的问题。</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>

<ol start="11">
<li><p>链接器脚本和链接选项 (<code>LDSCRIPT</code>, <code>LDFLAGS</code>):</p>
<ul>
<li><code>LDSCRIPT=n32g452_flash.ld</code><ul>
<li>链接器使用的脚本</li>
</ul>
</li>
<li><code>-Wl,--gc-sections</code><ul>
<li><code>Wl</code> 是告诉 <code>GCC</code> 后面的选项是传递给链接器的</li>
<li><code>--gc-sections</code> 告诉链接器在最终的可执行文件中删除未使用的代码段，减小程序大小。</li>
</ul>
</li>
<li><code>--data-sections</code>:<ul>
<li>这个选项类似于 <code>--gc-sections</code>，但它专门用于数据段。它允许链接器移除未使用的数据段，进一步减小程序大小。</li>
</ul>
</li>
<li><code>-mabi=aapcs</code>:<ul>
<li>这个选项指定了应用程序二进制接口（<code>ABI</code>）。<code>aapcs</code> 代表 <code>ARM 架构</code>过程调用标准，它定义了 <code>ARM 架构</code>中函数调用的规则，包括如何传递参数、如何管理堆栈等。</li>
</ul>
</li>
<li><code>-T$(LDSCRIPT)</code>:<ul>
<li><code>-T</code> 是<strong>链接器选项</strong>，用来指定<strong>链接脚本文件</strong>。链接脚本包含了有关如何链接程序的附加信息，比如内存布局、各种段的位置等。<code>$(LDSCRIPT)</code> 是一个 <code>Makefile</code> 变量，它的值是链接脚本文件的名称，通常是一个文本文件，告诉链接器如何组织内存中的段。</li>
</ul>
</li>
<li><code>-x assembler-with-cpp</code>:<ul>
<li>这个选项告诉链接器将<strong>所有输入文件</strong>视为<strong>预处理过</strong>的<strong>汇编源文件</strong>。这通常用于确保链接器正确处理由 <strong>C 预处理器</strong>生成的<strong>汇编代码</strong>。</li>
</ul>
</li>
<li><code>-Wa,-mimplicit-it=thumb</code>:<ul>
<li>这是传递给汇编器的选项（通过 <code>-Wa</code> 前缀）。<code>-mimplicit-it=thumb</code> 指定默认的指令集为 <code>Thumb</code> 模式，这是 <code>ARM 架构</code>的一种 <code>16 位指令集</code>，用于减小代码大小。</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>

<ol start="12">
<li>目标文件格式转换选项 (<code>OCFLAGS</code>, <code>ODFLAGS</code>):<br>- <code>OCFLAGS = -Obinary</code><br>- <code>ODFLAGS = -S</code></li>
</ol>
<br>

<ol start="13">
<li>输出目录和目标文件名 (<code>BUILD_DIR</code>, <code>TARGET</code>):<ul>
<li>定义了构建输出目录和最终目标文件的名称。</li>
</ul>
</li>
</ol>
<br>

<ol start="14">
<li>目标文件的生成 (<code>C_OBJECTS</code>, <code>ASM_OBJECTS</code>, <code>OBJECTS</code>):<ul>
<li><code>C_OBJECTS = $(addprefix $(BUILD_DIR)/, $(C_SOURCES:.c=.o))</code><ul>
<li><code>$(C_SOURCES:.c=.o)</code>将所有的 <code>C</code> 源文件列表 <code>$(C_SOURCES)</code> 中的每个 <code>.c</code> 扩展名替换为 <code>.o</code> 扩展名，得到目标文件（<code>object files</code>）列表。</li>
<li><code>$(addprefix $(BUILD_DIR)/, ...) </code>为每个 <code>.o</code> 文件<strong>加前缀</strong>加上构建目录 <code>$(BUILD_DIR)/</code> 的路径。</li>
<li><code>C_OBJECTS</code> 变量包含了所有 <code>C</code> 源文件对应的、带有完整路径的目标文件列表。</li>
</ul>
</li>
<li><code>ASM_OBJECTS = $(addprefix $(BUILD_DIR)/, $(ASM_SOURCES:.S=.o))</code>:<ul>
<li>这行代码的逻辑与 <code>C_OBJECTS</code> 类似，但是针对汇编源文件 <code>$(ASM_SOURCES)</code>。</li>
<li>它将所有 <code>.S</code> 源文件扩展名替换为 <code>.o</code>，然后添加构建目录的前缀，生成汇编语言目标文件的列表。</li>
</ul>
</li>
<li><code>OBJECTS += $(ASM_OBJECTS) $(C_OBJECTS)</code>:<ul>
<li>这行代码使用 <code>+=</code> 操作符将 <code>$(ASM_OBJECTS)</code> 和 <code>$(C_OBJECTS)</code> 列表中的所有目标文件添加到 <code>OBJECTS</code> 变量中。</li>
<li>OBJECTS 变量通常用于表示所有需要链接的文件的列表，它可能已经包含了一些其他目标文件，这里通过 <code>+=</code> 操作符将<code>汇编</code>和 <code>C</code> 语言的目标文件列表追加进去。</li>
<li>最终，<code>OBJECTS </code>包含了所有需要被链接器用来生成最终可执行文件或库文件的目标文件。</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>

<ol start="15">
<li>伪目标 (<code>.PHONY</code>):<ul>
<li>定义了 <code>clean</code>, <code>all</code>, <code>copy</code>, <code>mix</code>, <code>download</code> 等伪目标，用于执行特定的命令序列。</li>
</ul>
</li>
</ol>
<br>

<ol start="16">
<li>条件命令 (<code>SYS</code>, <code>ifeq</code>):<ul>
<li><code>SYS := $(shell uname -a)</code>:<ul>
<li>这行使用 <code>uname -a</code> 命令来获取当前系统的内核信息，并将输出赋值给 <code>SYS</code> 变量。<code>$(shell ...)</code> 命令会在 <code>shell</code> 中执行括号内的内容，并返回其输出。</li>
</ul>
</li>
<li><code>ifeq ($(findstring Microsoft,$(SYS)),Microsoft)</code>:<ul>
<li>这是一个条件语句，用于检查 <code>SYS</code> 变量中是否包含字符串 “<code>Microsoft</code>“。<code>$(findstring ...)</code> 函数在 <code>SYS</code> 的值中搜索 “<code>Microsoft</code>“ 字符串。如果找到，返回 “<code>Microsoft</code>“；否则返回空字符串。</li>
<li><code>ifeq</code> 检查 <code>$(findstring Microsoft,$(SYS))</code> 的结果是否等于 “<code>Microsoft</code>“。如果是，将执行下面的命令</li>
</ul>
</li>
<li><code>wsl.exe -d Ubuntu-20.04 cmd.exe /c &quot;C:\\\Users\\\BREO\\\Desktop\\\iap-tools\\\linux_download\\\program452RC.bat&quot;</code>:<ul>
<li>使用 <code>wsl.exe</code> 调用 <code>WSL</code> 环境。</li>
<li><code>-d Ubuntu-20.04</code>中，<code>-d</code> 选项允许你选择一个特定的发行版来启动,这里是<code>Ubuntu-20.04</code>。</li>
<li><code>cmd.exe</code>:这是 <code>Windows</code> 的命令行解释器，来运行一个 <code>Windows 批处理脚本</code>。</li>
<li><code>/c</code>: 告诉 <code>cmd.exe</code> 执行指定的命令，然后关闭窗口。</li>
<li><code>&quot;C:\\\...bat&quot;</code>: 需要执行脚本的路径。</li>
<li>**不知道为什么要用<code>\\\</code>**。</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>

<ol start="17">
<li>生成目标文件的规则 (<code>$(TARGET).list</code>, <code>$(TARGET).bin</code>, <code>$(TARGET).elf</code>, <code>$(TARGET).hex</code>):<ul>
<li><code>$(TARGET).list: $(TARGET).elf</code>:(以下规则类似)<ul>
<li><code>$(TARGET).list</code>: <code>$@</code>(<strong>目标文件</strong>)</li>
<li><code>$(TARGET).elf</code>: <code>$&lt;</code>(<strong>输入文件</strong>)</li>
</ul>
</li>
<li><code>$(OD) $(ODFLAGS) $&lt; &gt; $(TARGET).lst</code>:<ul>
<li>这是上述规则的命令部分。<code>$(OD)</code> 是 <code>objdump</code> 工具的变量，<code>$(ODFLAGS)</code> 是 <code>objdump</code> 的相关参数。<code>$&lt;</code> 是自动变量，表示第一个依赖文件，也就是 <code>$(TARGET).elf</code>。</li>
<li>命令使用 <code>objdump</code> 提取 <code>.elf</code> 文件的汇编内容，并重定向输出到 <code>$(TARGET).lst</code> 文件。</li>
</ul>
</li>
<li><code>$(OC) $(OCFLAGS) $(TARGET).elf $(TARGET).bin</code>:<ul>
<li>这是上述规则的命令部分。<code>$(OC)</code> 是 <code>objcopy</code> 工具的变量，<code>$(OCFLAGS)</code> 是 <code>objcopy</code> 的相关参数。</li>
<li>命令使用 <code>objcopy</code> 从 <code>.elf</code> 文件生成二进制格式的 <code>.bin</code> 文件。</li>
</ul>
</li>
<li><code>$(CC) $(ASM_OBJECTS) $(C_OBJECTS) $(LDFLAGS) -Wl,-Map=$(TARGET).map -o $(TARGET).elf</code>:<ul>
<li>这是 <strong>链接命令</strong>，使用 <code>$(CC)</code> 编译器（实际上是链接器）来链接对象文件 <code>$(ASM_OBJECTS)</code> 和 <code>$(C_OBJECTS)</code>，以及链接器标志 <code>$(LDFLAGS)</code>。</li>
<li><code>-Wl,-Map=$(TARGET).map</code> 选项告诉链接器生成一个内存映射文件 <code>$(TARGET).map</code>。</li>
<li><code>-o $(TARGET).elf</code> 指定了输出的 <strong>可执行文件</strong>名。</li>
</ul>
</li>
<li><code>$(OC) -O ihex $&lt; $@</code>:<ul>
<li>这是上述规则的命令部分，使用 <code>objcopy</code> 的 <code>-O ihex</code> 选项将输入文件（<code>$&lt;</code>）转换为 <code>Intel HEX</code> 格式，并命名为 <code>$@</code>，即 <code>$(TARGET).hex</code>。</li>
</ul>
</li>
<li><code>mkdir -p $(dir $@)</code><ul>
<li>这条命令确保目标文件的目录存在。<code>$(dir $@)</code> 获取目标文件的目录路径，<code>mkdir -p</code> 命令 <strong>创建这个目录（如果它还不存在）</strong>。</li>
</ul>
</li>
<li><code>$(CC) $(INCLUDE) $(CFLAGS) -MMD -c $&lt; -o $@</code><ul>
<li>这是编译单个 <code>C</code> 源文件的命令。它使用 <code>$(CC)</code> 编译器，<code>$(INCLUDE)</code> 包含路径，<code>$(CFLAGS)</code> 编译选项，<code>-c</code> 选项来编译不链接，<code>-MMD</code> 生成依赖文件，<code>$&lt;</code> 是源文件，<code>$@</code> 是目标文件。</li>
</ul>
</li>
<li><code>$(BUILD_DIR)/%.o: %.S</code>:<ul>
<li>这是一个模式规则，用于从 <code>.S</code> 汇编源文件生成 <code>.o</code> 目标文件，其命令与上面编译 <code>C</code> 文件的命令类似，但是通常 <strong>不包含编译选项</strong>，因为汇编语言的处理方式与 <code>C</code> 语言不同。</li>
</ul>
</li>
<li><code>-include $(wildcard $(BUILD_DIR)/**/*.d)</code>:<ul>
<li><code>$(wildcard *.c)</code> 会列出当前目录下所有的 <code>.c</code> 文件。</li>
<li><code>$(wildcard $(BUILD_DIR)/**/*.d)</code> 会列出 <code>$(BUILD_DIR)</code> 目录下的所有 <code>.d</code> 文件。</li>
</ul>
</li>
<li><code>DEP_FILES := $(shell find $(BUILD_DIR) -type f -name &#39;*.d&#39;)</code>,<code>-include $(DEP_FILES)</code>:<ul>
<li><code>find</code> 这是一个 <code>find</code> 命令，用于在文件系统中搜索文件。</li>
<li><code>$(BUILD_DIR)</code> 是之前定义的 <code>Makefile</code> 变量，表示构建目录的路径。</li>
<li><code>-type f</code> 指定 <code>find</code> 命令只搜索文件（不包括目录）。</li>
<li><code>-name &#39;*.d&#39;</code> 定义了搜索的文件名模式，<code>*.d</code> 匹配所有以 <code>.d</code> 结尾的文件，这通常是由编译器生成的依赖文件。</li>
<li><code>-include $(DEP_FILES)</code>： <code>make</code> 将会包含这些 <code>.d</code> ,这些文件包含了<strong>头文件的依赖信息</strong>,从而确保 <code>make</code> 能够正确地<strong>检测到源文件的依赖关系</strong>，并且在<strong>源文件</strong>或其<strong>头文件</strong>发生变化时<strong>重新编译</strong>相应的目标文件。</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>

<ol start="18">
<li><p>编译C源文件和汇编源文件的规则 (<code>$(BUILD_DIR)/%.o: %.c</code>, <code>$(BUILD_DIR)/%.o: %.S</code>):</p>
<ul>
<li>定义了如何编译 <code>C</code> 和汇编源文件为 <code>.o</code> 目标文件。</li>
</ul>
</li>
</ol>
<br>

<ol start="19">
<li>包含生成的依赖文件 <code>(-include $(wildcard $(BUILD_DIR)/**/*.d), DEP_FILES)</code>:<ul>
<li>使用 <code>find</code> 命令找到所有的 <code>.d</code> 文件，然后使用 <code>-include</code> 指令包含这些文件，以确保 <code>Make</code> 能够跟踪源文件的变化并避免不必要的重新编译。</li>
</ul>
</li>
</ol>
<br>

<h2 id="标准makefile基本语法"><a href="#标准makefile基本语法" class="headerlink" title="标准makefile基本语法"></a>标准makefile基本语法</h2><p>[参考文档]：<a href="https://seisman.github.io/how-to-write-makefile/index.html">https://seisman.github.io/how-to-write-makefile/index.html</a></p>
<h3 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h3><h4 id="规则的语法"><a href="#规则的语法" class="headerlink" title="规则的语法"></a>规则的语法</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">targets : prerequisites</span><br><span class="line">    command</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>或是这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">targets : prerequisites ; command</span><br><span class="line">    command</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>如果命令太长，你可以使用反斜杠（ <code>\</code> ）作为换行符</p>
<br>

<h4 id="在规则中使用通配符"><a href="#在规则中使用通配符" class="headerlink" title="在规则中使用通配符"></a>在规则中使用通配符</h4><p><code>make</code>支持三个通配符： <code>*</code> ， <code>?</code> 和 <code>~</code> 。这是和<code>Unix</code>的<code>B-Shell</code>是相同的。</p>
<ul>
<li><code>*</code>：通配符代替了你一系列的文件，如 <code>*.c</code> 表示所有后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如： <code>*</code> ，那么可以用转义字符 <code>\</code> ，如 <code>\*</code> 来表示真实的 <code>*</code> 字符，而不是任意长度的字符串。<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o</span><br></pre></td></tr></table></figure>
<code>clean</code>是操作系统<code>Shell</code>所支持的通配符。<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = *.o</span><br></pre></td></tr></table></figure>
<code>objects</code>的值就是 <code>*.o</code>, 并不是说 *.o 会展开， 如需展开进行以下操作。<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects := <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br></pre></td></tr></table></figure>
<strong>示例1</strong>：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">var = <span class="variable">$(<span class="built_in">shell</span> echo &quot;Hello, World!&quot;)</span></span><br></pre></td></tr></table></figure></li>
<li><code>:=</code> 和 <code>=</code>区别：<ul>
<li><code>=</code> (递归展开):<strong>示例1</strong>每次引用 <code>$(var)</code> 时，<code>Make</code> 都会执行 <code>echo &quot;Hello, World!&quot;</code></li>
<li><code>:=</code> (直接展开):<strong>示例1</strong>每次引用 <code>$(var)</code> 的值在 <code>Makefile</code> 解析时设置为 <code>&quot;Hello, World!&quot;</code></li>
</ul>
</li>
</ul>
<p><strong>示例2</strong><br>可写出编译并链接所有 <code>.c</code> 和 <code>.o</code> 文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">foo : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o foo <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>patsubst</code> 函数用于将第一个参数中匹配第二个参数模式的部分替换为第三个参数中的相应模式</li>
<li><code>patsubst</code> 函数用于将 <code>*.c</code> 替换为 <code>*.o</code>，<code>wildcard</code> 函数用于获取当前目录下所有 <code>.c</code> 文件。</li>
</ul>
<br>

<h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Makefile</code>文件中的特殊变量 <code>VPATH</code>,当<code>make</code>就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。</li>
<li>“<code>src</code>”和“<code>../headers</code>”，make会按照这个顺序进行搜索。目录由“<code>冒号</code>”分隔。（当然，当前目录永远是最高优先搜索的地方）。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> &lt;pattern&gt; &lt;directories&gt;</span><br><span class="line"><span class="keyword">vpath</span> %.h ../headers</span><br></pre></td></tr></table></figure>
<ul>
<li><code>vpath</code>使用方法中的<code>&lt;pattern&gt;</code>需要包含 <code>%</code> 字符。 <code>%</code> 的意思是匹配<code>零</code>或<code>若干字符</code>，（需引用 <code>%</code> ，使用 <code>\</code> ）例如， <code>%.h</code> 表示所有以 <code>.h</code> 结尾的文件。<code>&lt;pattern&gt;</code>指定了要搜索的文件集，而<code>&lt;directories&gt;</code>则指定了<code>&lt;pattern&gt;</code>的文件集的搜索的目录。</li>
</ul>
<br>

<h4 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure>
<p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“<strong>默认目标</strong>”，只要将其放在<strong>第一个</strong>。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">all : prog1 prog2 prog3</span><br><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">    cc -o prog1 prog1.o utils.o</span><br><span class="line"></span><br><span class="line">prog2 : prog2.o</span><br><span class="line">    cc -o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">    cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Makefile</code>中的第一个目标会被作为其<strong>默认目标</strong>。我们声明了一个“<code>all</code>”的伪目标，其依赖于其它三个目标。由于默认目标的特性是，总是被执行的，但由于“<code>all</code>”又是一个伪目标，伪目标只是一个标签不会生成文件，所以不会有“<code>all</code>”文件产生。于是，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。</li>
<li><code>.PHONY : all</code> 声明了“<code>all</code>”这个目标为“伪目标”。（注：这里的显式“<code>.PHONY : all</code>” 不写的话一般情况也可以正确的执行，这样<code>make</code>可通过隐式规则推导出， “<code>all</code>” 是一个伪目标，执行<code>make</code>不会生成“<code>all</code>”文件，而执行后面的多个目标。建议：显式写出是一个好习惯。）</li>
</ul>
<br>

<h4 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h4><p><code>Makefile</code>的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">    generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>上述规则等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bigoutput : text.g</span><br><span class="line">    generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">    generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure>
<p>其中，<code>-$(subst output,,$@)</code>中的 <code>$</code> 表示执行一个<code>Makefile</code>的函数，函数名为<code>subst</code>，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思， <code>$@</code> 表示目标的集合，就像一个数组， <code>$@</code> 依次取出目标，并执于命令。</p>
<ul>
<li><code>$(subst from,to,text)</code><ul>
<li><code>from</code> 是您想要替换的字符串。</li>
<li><code>to</code> 是您想要替换成的新字符串。</li>
<li><code>text</code> 是原始文本。</li>
</ul>
</li>
<li><code>generate text.g -$(subst output,,$@) &gt; $@</code>中的”<code>&gt;</code>“ 是一个<code>shell</code>命令，用于将 <code>generate text.g -$(subst output,,$@)</code> 的输出重定向到右侧<code>$@</code>文件中。</li>
</ul>
<br>

<h4 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h4><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>我们的“<strong>目标模式</strong>”或是“<strong>依赖模式</strong>”中都应该有 <code>%</code> 这个字符，如果你的文件名中有 <code>%</code> 那么你可以使用反斜杠 <code>\</code> 进行转义，来标明真实的 <code>%</code> 字符。看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们的目标从<code>$object</code>中获取</li>
<li><code>%.o</code> 表明要所有以 <code>.o</code> 结尾的目标，也就是 <code>foo.o</code> <code>bar.o</code>,也就是变量 <code>$object</code> 集合的模式</li>
<li>依赖模式 <code>%.c</code> 则取模式 <code>%.o</code> 的 <code>%</code> ，也就是 <code>foo</code> <code>bar</code> ，并为其加下 <code>.c</code> 的后缀，于是，我们的依赖目标就是 <code>foo.c</code> <code>bar.c </code></li>
<li>命令中的 <code>$&lt;</code> 和 <code>$@</code> 则是自动化变量， <code>$&lt;</code> 表示 <strong>第一个依赖文件</strong>， <code>$@</code> 表示 <strong>目标集</strong>（也就是“<code>foo.o</code> <code>bar.o</code>”）</li>
</ul>
<p>上面的规则展开后等价于下面的规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>
<p>如果我们的 <code>%.o</code> 有几百个，使用“<strong>静态模式规则</strong>”很方便，再看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o,<span class="variable">$(files)</span>)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.elc,<span class="variable">$(files)</span>)</span>: %.elc: %.el</span><br><span class="line">    emacs -f batch-byte-compile <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>$(filter %.o,$(files))</code>表示调用<code>Makefile</code>的<code>filter</code>函数，过滤“<code>$files</code>”集，只要其中模式为“<code>%.o</code>”的内容。</li>
</ul>
<br>

<h4 id="自动生成依赖性"><a href="#自动生成依赖性" class="headerlink" title="自动生成依赖性"></a>自动生成依赖性</h4><p>在<code>Makefile</code>中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的<code>main.c</code>中有一句 <code>#include &quot;defs.h&quot;</code> ，那么我们的依赖关系应该是：</p>
<pre><code>main.o : main.c defs.h
</code></pre>
<p>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件,例如，如果我们执行下面的命令:</p>
<pre><code>cc -M main.c
</code></pre>
<p>其输出是：</p>
<pre><code>main.o : main.c defs.h
</code></pre>
<p>需要提醒一句的是，如果你使用<code>GNU</code>的<code>C/C++</code>编译器，你得用 <code>-MM</code> 参数，不然，<code>-M</code> 参数会把一些 <strong>标准库的头文件也包含进来</strong>。</p>
<ul>
<li><code>gcc -M main.c</code>的输出是:<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \</span></span><br><span class="line">    /usr/<span class="keyword">include</span>/sys/cdefs.h /usr/<span class="keyword">include</span>/gnu/stubs.h \</span><br><span class="line">    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class="keyword">include</span>/stddef.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/types.h /usr/<span class="keyword">include</span>/bits/pthreadtypes.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/sched.h /usr/<span class="keyword">include</span>/libio.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/_G_config.h /usr/<span class="keyword">include</span>/wchar.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/wchar.h /usr/<span class="keyword">include</span>/gconv.h \</span><br><span class="line">    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class="keyword">include</span>/stdarg.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/stdio_lim.h</span><br></pre></td></tr></table></figure></li>
<li><code>gcc -MM main.c</code>的输出则是:<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main.o: main.c defs.h</span></span><br></pre></td></tr></table></figure></li>
<li><code>GNU</code>组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 <code>name.c</code> 的文件都生成一个 <code>name.d</code> 的<code>Makefile</code>文件， <code>.d</code> 文件中就存放对应 <code>.c</code> 文件的依赖关系。</li>
<li>我们可以写出 <code>.c</code> 文件和 <code>.d</code> 文件的依赖关系，并让<code>make</code>自动更新或生成 <code>.d</code> 文件，并把其包含在我们的主<code>Makefile</code>中，这样，我们就可以自动化地生成每个文件的依赖关系了。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">    @set -e; rm -f <span class="variable">$@</span>; \</span><br><span class="line">    <span class="variable">$(CC)</span> -M <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span>.$$$$; \</span><br><span class="line">    sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.$$$$ &gt; <span class="variable">$@</span>; \</span><br><span class="line">    rm -f <span class="variable">$@</span>.$$$$</span><br></pre></td></tr></table></figure>
<ul>
<li>规则的意思是，所有的 <code>.d</code> 文件依赖于 <code>.c</code> 文件</li>
<li><code>rm -f $@</code> 的意思是删除所有的目标，也就是 <code>.d</code> 文件</li>
<li>第二行的意思是，为每个依赖文件 <code>$&lt;</code> ，也就是 <code>.c</code> 文件生成依赖文件， <code>$@</code> 表示模式 <code>%.d</code> 文件，如果有一个<code>C</code>文件是<code>name.c</code>，那么 <code>%</code> 就是 <code>name</code> ， <code>$$$$</code> 意为一个随机编号，第二行生成的文件有可能是“<code>name.d.12345</code>”</li>
<li>第三行使用<code>sed</code>命令做了一个替换，关于<code>sed</code>命令的用法请参看相关的使用文档</li>
<li>第四行就是删除临时文件</li>
</ul>
<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入 <code>.d</code> 文件的依赖，即把依赖关系：</p>
<pre><code>main.o : main.c defs.h
</code></pre>
<p>转成：</p>
<pre><code>main.o main.d : main.c defs.h
</code></pre>
<p>于是，我们的 <code>.d</code> 文件也会自动更新了，并会自动生成了, 你还可以在这个 <code>.d</code> 文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 <code>.d</code> 文件都包含一个完整的规则, 例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$(sources:.c=.d)</code> 中的 <code>.c=.d</code> 的意思是做一个替换，把变量 <code>$(sources)</code> 所有 <code>.c</code> 的字串都替换成 <code>.d</code></li>
<li>因为<code>include</code>是按次序来载入文件，最先载入的 <code>.d</code> 文件中的目标会成为默认目标。</li>
</ul>
<br>

<h3 id="书写命令"><a href="#书写命令" class="headerlink" title="书写命令"></a>书写命令</h3><h4 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">@echo 正在编译XXX模块......</span><br></pre></td></tr></table></figure>
<p>当<code>make</code>执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“<code>@</code>”，那么，<code>make</code>将输出:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">echo 正在编译XXX模块......		//输出命令</span><br><span class="line">正在编译XXX模块......</span><br></pre></td></tr></table></figure>
<ul>
<li>如果<code>make</code>执行时，带入<code>make</code>参数 <code>-n</code> 或 <code>--just-print</code> ，那么其只是显示命令，但不会执行命令。</li>
<li><code>make</code>参数 <code>-s</code> 或 <code>--silent</code> 或 <code>--quiet</code> 则是全面禁止命令的显示。</li>
</ul>
<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是<code>cd</code>命令，你希望第二条命令得在<code>cd</code>之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。</p>
<ul>
<li>示例一：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/hchen</span><br><span class="line">    pwd</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/hchen; pwd</span><br></pre></td></tr></table></figure>
<p>当我们执行 <code>make exec</code> 时，第一个例子中的<code>cd</code>没有作用，<code>pwd</code>会打印出当前的<code>Makefile</code>目录，而第二个例子中，<code>cd</code>就起作用了，<code>pwd</code>会打印出“<code>/home/hchen</code>”。</p>
<h4 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h4><p>忽略命令的出错，我们可以在<code>Makefile</code>的命令行前加一个减号 <code>-</code> （在<code>Tab</code>键之后），标记为不管命令出不出错都认为是成功的。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm -f *.o</span><br></pre></td></tr></table></figure>
<ul>
<li>还有一个全局的办法是，给<code>make</code>加上 <code>-i</code> 或是 <code>--ignore-errors</code> 参数，那么，<code>Makefile</code>中所有命令都会忽略错误。如果一个规则是以 <code>.IGNORE</code> 作为目标的，那么这个规则中的所有命令将会忽略错误。</li>
<li>还有一个要提一下的<code>make</code>的参数的是 <code>-k</code> 或是 <code>--keep-going </code>，这个参数的意思是，如果某规则中的命令出错了，那么就 <strong>终止该规则</strong> 的执行，但 <strong>继续执行其它规则</strong>。</li>
</ul>
<h4 id="嵌套执行make"><a href="#嵌套执行make" class="headerlink" title="嵌套执行make"></a>嵌套执行make</h4><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的<code>Makefile</code></p>
<p>例如，我们有一个子目录叫<code>subdir</code>，这个目录下有个<code>Makefile</code>文件，来指明了这个目录下文件的编译规则。那么我们总控的<code>Makefile</code>可以这样书写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">    cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>Makefile</code>的<code>-C</code>选项，可以指定编译目录，<code>-f</code>选项可以指定编译文件。</p>
</li>
<li><p>定义<code>$(MAKE)</code>宏变量的意思是，也许我们的<code>make</code>需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“<code>subdir</code>”目录，然后执行<code>make</code>命令。</p>
</li>
<li><p>我们把这个<code>Makefile</code>叫做“<code>总控Makefile</code>”，<code>总控Makefile</code>的<strong>变量</strong>可以传递到<code>下级的Makefile</code>中（如果你显示的声明），但是<strong>不会覆盖</strong>下层的<code>Makefile</code>中所定义的变量，除非指定了 <code>-e</code> 参数。</p>
</li>
<li><p>如果你要传递变量到下级<code>Makefile</code>中，那么你可以使用这样的声明: <code>export &lt;variable ...&gt;;</code></p>
</li>
<li><p>如果你不想让某些变量传递到下级<code>Makefile</code>中，那么你可以这样声明: <code>unexport &lt;variable ...&gt;;</code></p>
</li>
<li><p>如果你要传递所有的变量，那么，只要一个<code>export</code>就行了。后面什么也不用跟，表示传递所有的变量。<br>示例一：</p>
<p>  export variable &#x3D; value<br>  &#x2F;&#x2F; 其等价于：<br>  variable &#x3D; value<br>  export variable<br>  &#x2F;&#x2F; 其等价于：<br>  export variable :&#x3D; value<br>  &#x2F;&#x2F; 其等价于：<br>  variable :&#x3D; value<br>  export variable</p>
</li>
</ul>
<p>示例二：</p>
<pre><code>export variable += value
// 其等价于：
variable += value
export variable
</code></pre>
<ul>
<li>需要注意的是，有两个变量，一个是 <code>SHELL</code> ，一个是 <code>MAKEFLAGS</code> ，这两个变量不管你是否<code>export</code>，其总是要 <strong>传递到下层</strong> <code>Makefile</code>中，特别是 <code>MAKEFLAGS</code> 变量，其中包含了<code>make</code>的 <strong>参数信息</strong>，如果我们执行“<code>总控Makefile</code>”时有<code>make</code>参数或是在上层 <code>Makefile</code>中定义了这个变量，那么 <code>MAKEFLAGS</code> 变量将会是这些参数，并会传递到下层<code>Makefile</code>中，这是一个系统级的环境变量。</li>
<li>但是<code>make</code>命令中的有几个参数并不往下传递，它们是 <code>-C</code> , <code>-f</code> , <code>-h</code>, <code>-o</code> 和 <code>-W</code> （有关<code>Makefile</code>参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> MAKEFLAGS=</span><br></pre></td></tr></table></figure></li>
<li>如果你定义了环境变量 <code>MAKEFLAGS</code> ，那么你得确信其中的选项是大家都会用到的，如果其中有 <code>-t</code> , <code>-n</code> 和 <code>-q</code> 参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</li>
<li>还有一个在“<strong>嵌套执行</strong>”中比较有用的参数， <code>-w</code> 或是 <code>--print-directory</code> 会在<code>make</code>的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级<code>make</code>目录是“<code>/home/hchen/gnu/make</code>”，如果我们使用 <code>make -w</code> 来执行，那么当进入该目录时，我们会看到:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make: Entering directory `/home/hchen/gnu/make&#x27;.</span><br></pre></td></tr></table></figure>
而在完成下层make后离开目录时，我们会看到:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make: Leaving directory `/home/hchen/gnu/make&#x27;</span><br></pre></td></tr></table></figure></li>
<li>当你使用 <code>-C</code> 参数来指定<code>make</code>下层<code>Makefile</code>时， <code>-w</code> 会被自动打开的。如果参数中有 <code>-s</code> （ <code>--slient</code> ）或是 <code>--no-print-directory</code> ，那么， <code>-w</code> 总是失效的。</li>
</ul>
<br>

<h4 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h4><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 <code>define</code> 开始，以 <code>endef</code> 结束，如:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在 define 和 endef 中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.c : foo.y</span><br><span class="line">    $(run-yacc)</span><br></pre></td></tr></table></figure>
<p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“<code>run-yacc</code>”中的 <code>$^</code> 就是 <code>foo.y</code> ， <code>$@</code> 就是 <code>foo.c</code> （有关这种以 <code>$</code> 开头的特殊变量，我们会在后面介绍），<code>make</code>在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<br>

<h3 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h3><h4 id="函数的调用语法"><a href="#函数的调用语法" class="headerlink" title="函数的调用语法"></a>函数的调用语法</h4><p>函数调用，很像变量的使用，也是以 <code>$</code> 来标识的，其语法如下：</p>
<pre><code>$(&lt;function&gt; &lt;arguments&gt;)    
// 或者
$&#123;&lt;function&gt; &lt;arguments&gt;&#125;
</code></pre>
<h4 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h4><h5 id="subst"><a href="#subst" class="headerlink" title="subst"></a>subst</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：字符串替换函数</li>
<li>功能：把字串 <code>&lt;text&gt;</code> 中的 <code>&lt;from&gt;</code> 字符串替换成 <code>&lt;to&gt;</code> 。</li>
<li>返回：函数返回被替换过后的字符串。</li>
</ul>
<h5 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：<strong>模式</strong> 字符串替换函数。</li>
<li>功能：查找 <code>&lt;text&gt;</code> 中的单词（单词以“<strong>空格</strong>”、“<strong>Tab</strong>”或“<strong>回车</strong>”“<strong>换行</strong>”分隔）是否符合模式 <code>&lt;pattern&gt;</code> ，如果匹配的话，则以 <code>&lt;replacement&gt;</code> 替换。这里， <code>&lt;pattern&gt;</code> 可以包括通配符 <code>%</code> ，表示任意长度的字串。如果 <code>&lt;replacement&gt;</code> 中也包含 <code>%</code> ，那么， <code>&lt;replacement&gt;</code> 中的这个 <code>%</code> 将是 <code>&lt;pattern&gt;</code> 中的那个 % 所代表的字串。（可以用 <code>\</code> 来转义，以 <code>\%</code> 来表示真实含义的 <code>%</code> 字符）</li>
<li>返回：函数返回被替换过后的字符串。</li>
<li>示例：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span></span><br></pre></td></tr></table></figure>
把字串 <code>x.c.c</code> <code>bar.c</code> 符合模式 <code>%.c</code> 的单词替换成 <code>%.o</code> ，返回结果是 <code>x.c.o</code> <code>bar.o</code></li>
</ul>
<h5 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h5><pre><code>$(strip &lt;string&gt;)
</code></pre>
<ul>
<li>名称：去空格函数。</li>
<li>功能：去掉 <code>&lt;string&gt;</code> 字串中开头和结尾的空字符。</li>
<li>返回：返回被去掉空格的字符串值。</li>
<li>示例：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> a b c )</span></span><br></pre></td></tr></table></figure>
把字串<code>a b c</code> 去掉开头和结尾的空格，结果是 <code>a b c</code>。</li>
</ul>
<h5 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h5><pre><code>$(findstring &lt;find&gt;,&lt;in&gt;)
</code></pre>
<ul>
<li>名称：查找字符串函数</li>
<li>功能：在字串 <in> 中查找 <find> 字串。</li>
<li>返回：如果找到，那么返回 <find> ，否则返回空字符串。</li>
<li>示例：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,a b c)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,b c)</span></span><br></pre></td></tr></table></figure>
第一个函数返回 <code>a</code> 字符串，第二个返回<code>空</code>字符串</li>
</ul>
<h5 id="混合总结"><a href="#混合总结" class="headerlink" title="混合总结"></a>混合总结</h5><pre><code>override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))
</code></pre>
<p>如果我们的 <code>$(VPATH)</code> 值是 <code>src:../headers </code>，那么 <code>$(patsubst %,-I%,$(subst :, ,$(VPATH)))</code> 将返回 <code>-Isrc -I../headers</code> ，这正是<code>cc</code>或<code>gcc</code>搜索头文件路径的参数。</p>
<p><strong>注</strong>：函数太多，不做概述。详见：<a href="https://seisman.github.io/how-to-write-makefile/functions.html">https://seisman.github.io/how-to-write-makefile/functions.html</a><br><strong>例程</strong>：<a href="https://github.com/XUAN9527/linux_test/tree/main/make_demo">https://github.com/XUAN9527/linux_test/tree/main/make_demo</a></p>
<br>

<h2 id="Makefile搭配Kconfig使用"><a href="#Makefile搭配Kconfig使用" class="headerlink" title="Makefile搭配Kconfig使用"></a>Makefile搭配Kconfig使用</h2><p>话不多说，我们一般使用<code>menuconfig</code>+<code>Kconfig</code>的方式进行版本配置，这里简单的笔记一个<code>Python</code>解析器版本的实现<code>Kconfiglib</code>。<br>[参考链接1]：<a href="https://cstriker1407.info/blog/kconfiglib-simple-note/">https://cstriker1407.info/blog/kconfiglib-simple-note/</a><br>[参考链接2]：<a href="https://juejin.cn/post/7101836149915648030">https://juejin.cn/post/7101836149915648030</a></p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul>
<li>安装必须组件：<code>Python3</code> + <code>kconfiglib</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3</span><br><span class="line">sudo apt install python3-pip</span><br><span class="line">pip3 install kconfiglib</span><br></pre></td></tr></table></figure>

<ul>
<li>验证安装:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3 --version</span></span><br><span class="line">Python 3.10.14</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip3 show kconfiglib</span></span><br><span class="line">Name: kconfiglib</span><br><span class="line">Version: 14.1.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h3><ul>
<li><p>在跟目录下创建<code>Kconfig</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mainmenu &quot;N32l40x 128K MCU, Flash Configuration&quot;</span><br><span class="line">config SPI_FLASH_ENABLE</span><br><span class="line">  bool &quot;spi flash enable&quot;</span><br><span class="line">  default n</span><br><span class="line">  help </span><br><span class="line">  config spi flash enable/disable</span><br><span class="line"></span><br><span class="line">menu &quot;Internal Flash Configuration&quot;</span><br><span class="line">depends on !SPI_FLASH_ENABLE</span><br><span class="line">config INTER_BOOTLOAD_FIRMWARE_SIZE</span><br><span class="line">    int &quot;bootloader fireware size (K)&quot;</span><br><span class="line">    range 10 32</span><br><span class="line">    default 10</span><br><span class="line">    help</span><br><span class="line">    config bootloader fireware size</span><br><span class="line"></span><br><span class="line">config INTER_FACTORY_FIRMWARE_SIZE</span><br><span class="line">    int &quot;factory fireware size (K)&quot;</span><br><span class="line">    range 56 96</span><br><span class="line">    default 56</span><br><span class="line">    help</span><br><span class="line">    config factory fireware size 56K/96K</span><br><span class="line"></span><br><span class="line">config INTER_APPLICATION_FIRMWARE_SIZE</span><br><span class="line">    int &quot;application fireware size (K)&quot;</span><br><span class="line">    range 56 96</span><br><span class="line">    default 56</span><br><span class="line">    help</span><br><span class="line">    config application fireware size 56K/96K</span><br><span class="line"></span><br><span class="line">config INTER_DOWNLOAD_AREA_SIZE</span><br><span class="line">    int &quot;download fireware size (K)&quot;</span><br><span class="line">    range 56 96</span><br><span class="line">    default 56</span><br><span class="line">    help</span><br><span class="line">    config download area size 56K/96K</span><br><span class="line"></span><br><span class="line">config INTER_UPGRADE_DATA_SIZE</span><br><span class="line">    int &quot;upgrade data size (K)&quot;</span><br><span class="line">    range 2 4</span><br><span class="line">    default 2</span><br><span class="line">    help</span><br><span class="line">    config upgrade data size 2K/4K</span><br><span class="line"></span><br><span class="line">config INTER_DCD_DATA_SIZE</span><br><span class="line">    int &quot;dcd data size (K)&quot;</span><br><span class="line">    range 2 4</span><br><span class="line">    default 2</span><br><span class="line">    help</span><br><span class="line">    config dcd data size 2K/4K</span><br><span class="line"></span><br><span class="line">config INTER_USER_DATA_SIZE</span><br><span class="line">    int &quot;user data size (K)&quot;</span><br><span class="line">    range 2 408</span><br><span class="line">    default 2</span><br><span class="line">    help</span><br><span class="line">    config user data size 2K/408K; 2k - inter flash; 408K - outerflash</span><br><span class="line">endmenu</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>shell</code>执行<code>menuconfig</code>指令：</p>
</li>
</ul>
<p><img src="/../pictures/menuconfig.png" alt="menuconfig"><br><img src="/../pictures/menusubconfig.png" alt="menusubconfig"></p>
<ul>
<li>选择好需要的参数后，保存退出，生成<code>.config</code>配置文件。</li>
<li><code>shell</code>执行<code>genconfig</code>指令，将<code>.config</code>文件生成<code>config.h</code>文件，可供程序调用。</li>
<li>如需搭配<code>makefile</code>使用，则需要将<code>config.h</code>文件添加到<code>Makefile</code>中,添加以下依赖规则。<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: genconfig ...</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">menuconfig:</span></span><br><span class="line">	menuconfig</span><br><span class="line">	@echo <span class="string">&quot;menuconfig running!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">genconfig:</span></span><br><span class="line">	genconfig</span><br><span class="line">	@echo <span class="string">&quot;genconfig .config &gt; config.h complete!&quot;</span></span><br></pre></td></tr></table></figure>
执行<code>make menuconfig</code>进行配置，<code>make</code>编译生成即可。</li>
</ul>
<h2 id="makefile隐藏打印输出"><a href="#makefile隐藏打印输出" class="headerlink" title="makefile隐藏打印输出"></a>makefile隐藏打印输出</h2><ul>
<li><p>以下是<code>makefile</code>使用<code>make</code>编译的<code>shell</code>输出信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xuan@DESKTOP-A52B6V9:~/work/wireless-charging/app$ make</span><br><span class="line">mkdir -p build/application/</span><br><span class="line">arm-none-eabi-gcc -ICMSIS/core -ICMSIS/device -Istd_periph_lib/inc -Iuser -Imsp -Idriver -Iapplication/inc -Icomponents/letter_shell -Icomponents/iap -Icomponents/ntc -Icomponents/soft_timer -Icomponents/comp_misc_lib -Icomponents/flexibleButton -Icomponents/aw9523b -c -fno-common --specs=rdimon.specs -std=gnu99 -mabi=aapcs -Wall -mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard -ffunction-sections -fdata-sections -lm --specs=nosys.specs --specs=nano.specs -Os -ggdb -DN32L40X -DUSE_STDPERIPH_DRIVER -D__FPU_PRESENT=1 -MMD -c application/main.c -o build/application/main.o</span><br><span class="line">arm-none-eabi-gcc build/CMSIS/device/startup/startup_n32l40x_gcc.o build/CMSIS/device/system_n32l40x.o build/std_periph_lib/src/n32l40x_rcc.o build/std_periph_lib/src/n32l40x_tim.o build/std_periph_lib/src/n32l40x_adc.o build/std_periph_lib/src/n32l40x_dma.o build/std_periph_lib/src/n32l40x_usart.o build/std_periph_lib/src/n32l40x_iwdg.o build/std_periph_lib/src/n32l40x_flash.o build/std_periph_lib/src/n32l40x_gpio.o build/std_periph_lib/src/n32l40x_spi.o build/std_periph_lib/src/misc.o build/application/main.o build/application/n32l40x_it.o build/application/system_work.o build/user/module_battery.o build/user/module_botton.o build/user/module_led.o build/user/module_power.o build/user/module_storage.o build/user/shell_debug.o build/user/user_board.o build/msp/board.o build/msp/drv_msp.o build/driver/drv_adc.o build/driver/drv_flash.o build/driver/drv_gpio.o build/driver/drv_iwdg.o build/driver/drv_pwm_gpio.o build/driver/drv_pwm_input.o build/driver/drv_usart.o build/driver/drv_spi_led.o build/driver/drv_i2c.o build/driver/drv_i2c_bit_ops.o build/components/comp_misc_lib/comp_misc_lib.o build/components/flexibleButton/flexible_button.o build/components/iap/af_utils.o build/components/iap/dcd_port.o build/components/iap/dcd_user.o build/components/iap/iap.o build/components/iap/ymodem.o build/components/letter_shell/log.o build/components/letter_shell/shell.o build/components/letter_shell/shell_cmd_list.o build/components/letter_shell/shell_companion.o build/components/letter_shell/shell_ext.o build/components/letter_shell/shell_port.o build/components/ntc/ntc.o build/components/soft_timer/soft_timer.o build/components/aw9523b/aw9523b.o -Wl,--gc-sections --data-sections -mabi=aapcs -mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard -ffunction-sections -fdata-sections -lm --specs=nosys.specs --specs=nano.specs -Os -ggdb -Tn32l40x_flash.ld -x assembler-with-cpp -Wa,-mimplicit-it=thumb -Wl,-Map=build/app.map -o build/app.elf</span><br><span class="line">arm-none-eabi-objcopy -Obinary build/app.elf build/app.bin</span><br><span class="line">arm-none-eabi-objdump -S build/app.elf &gt; build/app.lst</span><br><span class="line">arm-none-eabi-objcopy -O ihex build/app.elf build/app.hex</span><br><span class="line">arm-none-eabi-size build/app.elf</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">  29280     292   11888   41460    a1f4 build/app.elf</span><br><span class="line">make[1]: Entering directory &#x27;/home/xuan/work/wireless-charging/app&#x27;</span><br><span class="line">cp build/app.bin app.bin</span><br><span class="line">cp ../bootloader/bootloader.bin bootloader.bin</span><br><span class="line">make[1]: Leaving directory &#x27;/home/xuan/work/wireless-charging/app&#x27;</span><br><span class="line">make[1]: Entering directory &#x27;/home/xuan/work/wireless-charging/app&#x27;</span><br><span class="line">./tools/papp_up</span><br><span class="line">./tools/mix_10K</span><br><span class="line">arm-none-eabi-objcopy -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex</span><br><span class="line">rm bootloader.bin</span><br><span class="line">rm app.bin</span><br><span class="line">rm mix.bin</span><br><span class="line">make[1]: Leaving directory &#x27;/home/xuan/work/wireless-charging/app&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以下是<code>makefile</code>的代码：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean all</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span>.bin <span class="variable">$(TARGET)</span>.list <span class="variable">$(TARGET)</span>.hex</span></span><br><span class="line">	<span class="variable">$(SZ)</span> <span class="variable">$(TARGET)</span>.elf</span><br><span class="line">	@make copy</span><br><span class="line">	@make mix</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: copy download</span></span><br><span class="line"></span><br><span class="line"><span class="section">copy: <span class="variable">$(TARGET)</span>.bin</span></span><br><span class="line">	cp <span class="variable">$(TARGET)</span>.bin app.bin</span><br><span class="line">	cp ../bootloader/bootloader.bin bootloader.bin</span><br><span class="line"></span><br><span class="line"><span class="section">mix:</span></span><br><span class="line">	./tools/papp_up</span><br><span class="line">	./tools/mix_10K</span><br><span class="line">	<span class="variable">$(OC)</span> -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex</span><br><span class="line">	rm bootloader.bin</span><br><span class="line">	rm app.bin</span><br><span class="line">	rm mix.bin</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(OUTPUT_DIR)</span></span><br><span class="line">	rm papp.bin</span><br><span class="line">	rm mix.hex</span><br><span class="line"></span><br><span class="line">SYS := <span class="variable">$(<span class="built_in">shell</span> uname -a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">findstring</span> Microsoft,<span class="variable">$(SYS)</span>)</span>,Microsoft)</span><br><span class="line"><span class="section">COPY_CMD:</span></span><br><span class="line">	cp <span class="variable">$(OUTPUT_DIR)</span>/app.hex <span class="string">&quot;/mnt/c/Users/Breo/Desktop/iap-tools/linux_download/&quot;</span></span><br><span class="line">	wsl.exe -d Ubuntu-20.04 cmd.exe /c <span class="string">&quot;C:\\\Users\\\BREO\\\Desktop\\\iap-tools\\\linux_download\\\program.bat&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="section">COPY_CMD:</span></span><br><span class="line">	echo <span class="string">&quot;当前系统不是 WSL，跳过拷贝文件指令&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">download:</span></span><br><span class="line">	@make all</span><br><span class="line">	@<span class="variable">$(MAKE)</span> COPY_CMD</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>@</code>和<code>--no-print</code>来隐藏打印信息，改进后：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean all</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span>.bin <span class="variable">$(TARGET)</span>.list <span class="variable">$(TARGET)</span>.hex</span></span><br><span class="line">	<span class="variable">$(SZ)</span> <span class="variable">$(TARGET)</span>.elf</span><br><span class="line">	@make --no-print copy</span><br><span class="line">	@make --no-print mix</span><br><span class="line">	</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: copy</span></span><br><span class="line"></span><br><span class="line"><span class="section">copy: <span class="variable">$(TARGET)</span>.bin</span></span><br><span class="line">	@cp <span class="variable">$(TARGET)</span>.bin app.bin</span><br><span class="line">	@cp ../bootloader/bootloader.bin bootloader.bin</span><br><span class="line"></span><br><span class="line"><span class="section">mix:</span></span><br><span class="line">	@./tools/papp_up</span><br><span class="line">	@./tools/mix_10K</span><br><span class="line">	@<span class="variable">$(OC)</span> -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex</span><br><span class="line">	@rm bootloader.bin</span><br><span class="line">	@rm app.bin</span><br><span class="line">	@rm mix.bin</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(OUTPUT_DIR)</span></span><br><span class="line">	-rm papp.bin</span><br><span class="line">	-rm mix.hex</span><br><span class="line"></span><br><span class="line">SYS := <span class="variable">$(<span class="built_in">shell</span> uname -a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">findstring</span> Microsoft,<span class="variable">$(SYS)</span>)</span>,Microsoft)</span><br><span class="line"><span class="section">COPY_CMD:</span></span><br><span class="line">	cp <span class="variable">$(TARGET)</span>.hex <span class="string">&quot;/mnt/c/Users/Breo/Desktop/iap-tools/linux_download/&quot;</span></span><br><span class="line">	wsl.exe -d Ubuntu-20.04 cmd.exe /c <span class="string">&quot;C:\\\Users\\\BREO\\\Desktop\\\iap-tools\\\linux_download\\\program.bat&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="section">COPY_CMD:</span></span><br><span class="line">	echo <span class="string">&quot;当前系统不是 WSL，跳过拷贝文件指令&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">download:</span></span><br><span class="line">	@make all</span><br><span class="line">	@<span class="variable">$(MAKE)</span> COPY_CMD</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Cotex-M4启动详解</title>
    <url>/2024/05/29/Cotex-M4%E5%90%AF%E5%8A%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="启动文件"><a href="#启动文件" class="headerlink" title="启动文件"></a>启动文件</h2><p><code>startup_n32l40x_gcc.s</code> 文件为例，以下是源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  ****************************************************************************</span><br><span class="line">  Copyright (c) 2019, Nations Technologies Inc.</span><br><span class="line"></span><br><span class="line">  All rights reserved.</span><br><span class="line">  ****************************************************************************</span><br><span class="line"></span><br><span class="line">  Redistribution and use in source and binary forms, with or without</span><br><span class="line">  modification, are permitted provided that the following conditions are met:</span><br><span class="line"></span><br><span class="line">  - Redistributions of source code must retain the above copyright notice,</span><br><span class="line">  this list of conditions and the disclaimer below.</span><br><span class="line"></span><br><span class="line">  Nations&#x27; name may not be used to endorse or promote products derived from</span><br><span class="line">  this software without specific prior written permission.</span><br><span class="line"></span><br><span class="line">  DISCLAIMER: THIS SOFTWARE IS PROVIDED BY NATIONS &quot;AS IS&quot; AND ANY EXPRESS OR</span><br><span class="line">  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span><br><span class="line">  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE</span><br><span class="line">  DISCLAIMED. IN NO EVENT SHALL NATIONS BE LIABLE FOR ANY DIRECT, INDIRECT,</span><br><span class="line">  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span><br><span class="line">  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,</span><br><span class="line">  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span><br><span class="line">  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span><br><span class="line">  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,</span><br><span class="line">  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line">  ****************************************************************************</span><br><span class="line"> **/</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">* Amount of memory (in bytes) allocated for Stack</span><br><span class="line">* Tailor this value to your application needs</span><br><span class="line">* &lt;h&gt; Stack Configuration</span><br><span class="line">*   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">* &lt;/h&gt;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">******************************************************************************</span><br><span class="line">* @file      startup_n32l40x_gcc.s</span><br><span class="line">******************************************************************************</span><br><span class="line">*/</span><br><span class="line">    </span><br><span class="line">  .syntax unified</span><br><span class="line">  .cpu cortex-m4</span><br><span class="line">  .fpu softvfp</span><br><span class="line">  .thumb</span><br><span class="line"></span><br><span class="line">.global  g_pfnVectors</span><br><span class="line">.global  Default_Handler</span><br><span class="line"></span><br><span class="line">/* start address for the initialization values of the .data section. </span><br><span class="line">defined in linker script */</span><br><span class="line">.word  _sidata</span><br><span class="line">/* start address for the .data section. defined in linker script */  </span><br><span class="line">.word  _sdata</span><br><span class="line">/* end address for the .data section. defined in linker script */</span><br><span class="line">.word  _edata</span><br><span class="line">/* start address for the .bss section. defined in linker script */</span><br><span class="line">.word  _sbss</span><br><span class="line">/* end address for the .bss section. defined in linker script */</span><br><span class="line">.word  _ebss</span><br><span class="line">/* stack used for SystemInit_ExtMemCtl; always internal RAM used */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief  This is the code that gets called when the processor first</span><br><span class="line"> *          starts execution following a reset event. Only the absolutely</span><br><span class="line"> *          necessary set is performed, after which the application</span><br><span class="line"> *          supplied main() routine is called. </span><br><span class="line"> * @param  None</span><br><span class="line"> * @retval : None</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">  .section  .text.Reset_Handler</span><br><span class="line">  .weak  Reset_Handler</span><br><span class="line">  .type  Reset_Handler, %function</span><br><span class="line">  Reset_Handler:  </span><br><span class="line"></span><br><span class="line">/* Copy the data segment initializers from flash to SRAM */  </span><br><span class="line">  movs  r1, #0</span><br><span class="line">  b  LoopCopyDataInit</span><br><span class="line"></span><br><span class="line">CopyDataInit:</span><br><span class="line">  ldr  r3, =_sidata</span><br><span class="line">  ldr  r3, [r3, r1]</span><br><span class="line">  str  r3, [r0, r1]</span><br><span class="line">  adds  r1, r1, #4</span><br><span class="line">    </span><br><span class="line">LoopCopyDataInit:</span><br><span class="line">  ldr  r0, =_sdata</span><br><span class="line">  ldr  r3, =_edata</span><br><span class="line">  adds  r2, r0, r1</span><br><span class="line">  cmp  r2, r3</span><br><span class="line">  bcc  CopyDataInit</span><br><span class="line">  ldr  r2, =_sbss</span><br><span class="line">  b  LoopFillZerobss</span><br><span class="line">/* Zero fill the bss segment. */  </span><br><span class="line">FillZerobss:</span><br><span class="line">  movs  r3, #0</span><br><span class="line">  str  r3, [r2], #4</span><br><span class="line">    </span><br><span class="line">LoopFillZerobss:</span><br><span class="line">  ldr  r3, = _ebss</span><br><span class="line">  cmp  r2, r3</span><br><span class="line">  bcc  FillZerobss</span><br><span class="line"></span><br><span class="line">/* Call the clock system intitialization function.*/</span><br><span class="line">  bl  SystemInit   </span><br><span class="line">/* Call static constructors */</span><br><span class="line">  bl __libc_init_array</span><br><span class="line">/* Call the application&#x27;s entry point.*/</span><br><span class="line">  bl  main</span><br><span class="line">  bx  lr    </span><br><span class="line">.size  Reset_Handler, .-Reset_Handler</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief  This is the code that gets called when the processor receives an </span><br><span class="line"> *         unexpected interrupt.  This simply enters an infinite loop, preserving</span><br><span class="line"> *         the system state for examination by a debugger.</span><br><span class="line"> * @param  None     </span><br><span class="line"> * @retval None       </span><br><span class="line">*/</span><br><span class="line">    .section  .text.Default_Handler,&quot;ax&quot;,%progbits</span><br><span class="line">Default_Handler:</span><br><span class="line">Infinite_Loop:</span><br><span class="line">  b  Infinite_Loop</span><br><span class="line">  .size  Default_Handler, .-Default_Handler</span><br><span class="line">/******************************************************************************</span><br><span class="line">*</span><br><span class="line">* The minimal vector table for a Cortex M3. Note that the proper constructs</span><br><span class="line">* must be placed on this to ensure that it ends up at physical address</span><br><span class="line">* 0x0000.0000.</span><br><span class="line">* </span><br><span class="line">*******************************************************************************/</span><br><span class="line">   .section  .isr_vector,&quot;a&quot;,%progbits</span><br><span class="line">  .type  g_pfnVectors, %object</span><br><span class="line">  .size  g_pfnVectors, .-g_pfnVectors</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">g_pfnVectors:</span><br><span class="line">  .word  _estack</span><br><span class="line">  .word  Reset_Handler</span><br><span class="line">  .word  NMI_Handler</span><br><span class="line">  .word  HardFault_Handler</span><br><span class="line">  .word  MemManage_Handler</span><br><span class="line">  .word  BusFault_Handler</span><br><span class="line">  .word  UsageFault_Handler</span><br><span class="line">  .word  0</span><br><span class="line">  .word  0</span><br><span class="line">  .word  0</span><br><span class="line">  .word  0</span><br><span class="line">  .word  SVC_Handler</span><br><span class="line">  .word  DebugMon_Handler</span><br><span class="line">  .word  0</span><br><span class="line">  .word  PendSV_Handler</span><br><span class="line">  .word  SysTick_Handler</span><br><span class="line">  </span><br><span class="line">  /* External Interrupts */</span><br><span class="line">  .word     WWDG_IRQHandler                     /* Window WatchDog                      */                                        </span><br><span class="line">  .word     PVD_IRQHandler                      /* PVD through EXTI Line detection      */                        </span><br><span class="line">  .word     TAMPER_IRQHandler                   /* Tamper                               */            </span><br><span class="line">  .word     RTC_WKUP_IRQHandler                 /* RTC Wakeup                           */                      </span><br><span class="line">  .word     FLASH_IRQHandler                    /* FLASH                                */                                          </span><br><span class="line">  .word     RCC_IRQHandler                      /* RCC                                  */                                            </span><br><span class="line">  .word     EXTI0_IRQHandler                    /* EXTI Line0                           */                        </span><br><span class="line">  .word     EXTI1_IRQHandler                    /* EXTI Line1                           */                          </span><br><span class="line">  .word     EXTI2_IRQHandler                    /* EXTI Line2                           */                          </span><br><span class="line">  .word     EXTI3_IRQHandler                    /* EXTI Line3                           */                          </span><br><span class="line">  .word     EXTI4_IRQHandler                    /* EXTI Line4                           */                          </span><br><span class="line">  .word     DMA_Channel1_IRQHandler            /* DMA1 Channel 1                       */                  </span><br><span class="line">  .word     DMA_Channel2_IRQHandler            /* DMA1 Channel 2                       */                   </span><br><span class="line">  .word     DMA_Channel3_IRQHandler            /* DMA1 Channel 3                       */                   </span><br><span class="line">  .word     DMA_Channel4_IRQHandler            /* DMA1 Channel 4                       */                   </span><br><span class="line">  .word     DMA_Channel5_IRQHandler            /* DMA1 Channel 5                       */                   </span><br><span class="line">  .word     DMA_Channel6_IRQHandler            /* DMA1 Channel 6                       */                   </span><br><span class="line">  .word     DMA_Channel7_IRQHandler            /* DMA1 Channel 7                       */       </span><br><span class="line">  .word     DMA_Channel8_IRQHandler             /* DMA1 Channel 8                       */ </span><br><span class="line">  .word     ADC_IRQHandler                      /* ADC                                  */                   </span><br><span class="line">  .word     USB_HP_IRQHandler                   /* USB High Priority                    */                         </span><br><span class="line">  .word     USB_LP_IRQHandler                   /* USB Low  Priority                    */                          </span><br><span class="line">  .word     COMP_1_2_IRQHandler                 /* COMP1 &amp; COMP2 through EXTI line 21/22    */                          </span><br><span class="line">  .word     EXTI9_5_IRQHandler                  /* EXTI Line 9..5                       */                          </span><br><span class="line">  .word     TIM1_BRK_IRQHandler                 /* TIM1 Break                           */</span><br><span class="line">  .word     TIM1_UP_IRQHandler                  /* TIM1 Update                          */         </span><br><span class="line">  .word     TIM1_TRG_COM_IRQHandler             /* TIM1 Trigger and Commutation         */</span><br><span class="line">  .word     TIM1_CC_IRQHandler                  /* TIM1 Capture Compare                 */                          </span><br><span class="line">  .word     TIM2_IRQHandler                     /* TIM2                                 */                   </span><br><span class="line">  .word     TIM3_IRQHandler                     /* TIM3                                 */                   </span><br><span class="line">  .word     TIM4_IRQHandler                     /* TIM4                                 */                   </span><br><span class="line">  .word     I2C1_EV_IRQHandler                  /* I2C1 Event                           */                          </span><br><span class="line">  .word     I2C1_ER_IRQHandler                  /* I2C1 Error                           */                          </span><br><span class="line">  .word     I2C2_EV_IRQHandler                  /* I2C2 Event                           */                          </span><br><span class="line">  .word     I2C2_ER_IRQHandler                  /* I2C2 Error                           */                            </span><br><span class="line">  .word     SPI1_IRQHandler                     /* SPI1                                 */                   </span><br><span class="line">  .word     SPI2_IRQHandler                     /* SPI2                                 */                   </span><br><span class="line">  .word     USART1_IRQHandler                   /* USART1                               */                   </span><br><span class="line">  .word     USART2_IRQHandler                   /* USART2                               */                   </span><br><span class="line">  .word     USART3_IRQHandler                   /* USART3                               */                   </span><br><span class="line">  .word     EXTI15_10_IRQHandler                /* EXTI Line 15..10                     */                          </span><br><span class="line">  .word     RTCAlarm_IRQHandler                 /* RTC Alarm through EXTI Line          */                 </span><br><span class="line">  .word     USBWakeUp_IRQHandler                /* USB Wakeup from suspend              */                       </span><br><span class="line">  .word     TIM8_BRK_IRQHandler                 /* TIM8 Break                           */         </span><br><span class="line">  .word     TIM8_UP_IRQHandler                  /* TIM8 Update                          */         </span><br><span class="line">  .word     TIM8_TRG_COM_IRQHandler             /* TIM8 Trigger and Commutation         */</span><br><span class="line">  .word     TIM8_CC_IRQHandler                  /* TIM8 Capture Compare                 */                          </span><br><span class="line">  .word     UART4_IRQHandler                    /* UART4                                */                   </span><br><span class="line">  .word     UART5_IRQHandler                    /* UART5                                */       </span><br><span class="line">  .word     LPUART_IRQHandler                   /* LPUART                               */</span><br><span class="line">  .word     TIM5_IRQHandler                     /* TIM5                                 */   </span><br><span class="line">  .word     TIM6_IRQHandler                     /* TIM6                                 */                   </span><br><span class="line">  .word     TIM7_IRQHandler                     /* TIM7                                 */</span><br><span class="line">  .word     CAN_TX_IRQHandler                   /* CAN TX                               */                          </span><br><span class="line">  .word     CAN_RX0_IRQHandler                  /* CAN RX0                              */                          </span><br><span class="line">  .word     CAN_RX1_IRQHandler                  /* CAN RX1                              */                          </span><br><span class="line">  .word     CAN_SCE_IRQHandler                  /* CAN SCE                              */                          </span><br><span class="line">  .word     LPUART_WKUP_IRQHandler              /* LPUART_WKUP                          */                   </span><br><span class="line">  .word     LPTIM_WKUP_IRQHandler               /* LPTIM_WKUP                           */                   </span><br><span class="line">  .word     LCD_IRQHandler                      /* LCD                                  */                   </span><br><span class="line">  .word     SAC_IRQHandler                      /* SAC                                  */                   </span><br><span class="line">  .word     MMU_IRQHandler                      /* MMU                                  */</span><br><span class="line">  .word     TSC_IRQHandler                      /* TSC                                  */</span><br><span class="line">  .word     RAMC_PERR_IRQHandler                /* RAMC ERR                             */</span><br><span class="line">  .word     TIM9_IRQHandler                     /* TIM9                                 */</span><br><span class="line">  .word     UCDR_IRQHandler                     /* UCDR ERR                             */</span><br><span class="line"></span><br><span class="line">/*******************************************************************************</span><br><span class="line">*</span><br><span class="line">* Provide weak aliases for each Exception handler to the Default_Handler. </span><br><span class="line">* As they are weak aliases, any function with the same name will override </span><br><span class="line">* this definition.</span><br><span class="line">* </span><br><span class="line">*******************************************************************************/</span><br><span class="line">   .weak      NMI_Handler</span><br><span class="line">   .thumb_set NMI_Handler,Default_Handler</span><br><span class="line">  </span><br><span class="line">   .weak      HardFault_Handler</span><br><span class="line">   .thumb_set HardFault_Handler,Default_Handler</span><br><span class="line">  </span><br><span class="line">   .weak      MemManage_Handler</span><br><span class="line">   .thumb_set MemManage_Handler,Default_Handler</span><br><span class="line">  </span><br><span class="line">   .weak      BusFault_Handler</span><br><span class="line">   .thumb_set BusFault_Handler,Default_Handler</span><br><span class="line"></span><br><span class="line">   .weak      UsageFault_Handler</span><br><span class="line">   .thumb_set UsageFault_Handler,Default_Handler</span><br><span class="line"></span><br><span class="line">   .weak      SVC_Handler</span><br><span class="line">   .thumb_set SVC_Handler,Default_Handler</span><br><span class="line"></span><br><span class="line">   .weak      DebugMon_Handler</span><br><span class="line">   .thumb_set DebugMon_Handler,Default_Handler</span><br><span class="line"></span><br><span class="line">   .weak      PendSV_Handler</span><br><span class="line">   .thumb_set PendSV_Handler,Default_Handler</span><br><span class="line"></span><br><span class="line">   .weak      SysTick_Handler</span><br><span class="line">   .thumb_set SysTick_Handler,Default_Handler              </span><br><span class="line">  </span><br><span class="line">   .weak      WWDG_IRQHandler                   </span><br><span class="line">   .thumb_set WWDG_IRQHandler,Default_Handler      </span><br><span class="line">                  </span><br><span class="line">   .weak      PVD_IRQHandler      </span><br><span class="line">   .thumb_set PVD_IRQHandler,Default_Handler</span><br><span class="line">               </span><br><span class="line">   .weak      TAMPER_IRQHandler            </span><br><span class="line">   .thumb_set TAMPER_IRQHandler,Default_Handler</span><br><span class="line">            </span><br><span class="line">   .weak      RTC_WKUP_IRQHandler                  </span><br><span class="line">   .thumb_set RTC_WKUP_IRQHandler,Default_Handler</span><br><span class="line">            </span><br><span class="line">   .weak      FLASH_IRQHandler         </span><br><span class="line">   .thumb_set FLASH_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      RCC_IRQHandler      </span><br><span class="line">   .thumb_set RCC_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      EXTI0_IRQHandler         </span><br><span class="line">   .thumb_set EXTI0_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      EXTI1_IRQHandler         </span><br><span class="line">   .thumb_set EXTI1_IRQHandler,Default_Handler</span><br><span class="line">                     </span><br><span class="line">   .weak      EXTI2_IRQHandler         </span><br><span class="line">   .thumb_set EXTI2_IRQHandler,Default_Handler </span><br><span class="line">                 </span><br><span class="line">   .weak      EXTI3_IRQHandler         </span><br><span class="line">   .thumb_set EXTI3_IRQHandler,Default_Handler</span><br><span class="line">                        </span><br><span class="line">   .weak      EXTI4_IRQHandler         </span><br><span class="line">   .thumb_set EXTI4_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      DMA_Channel1_IRQHandler               </span><br><span class="line">   .thumb_set DMA_Channel1_IRQHandler,Default_Handler</span><br><span class="line">         </span><br><span class="line">   .weak      DMA_Channel2_IRQHandler               </span><br><span class="line">   .thumb_set DMA_Channel2_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      DMA_Channel3_IRQHandler               </span><br><span class="line">   .thumb_set DMA_Channel3_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      DMA_Channel4_IRQHandler               </span><br><span class="line">   .thumb_set DMA_Channel4_IRQHandler,Default_Handler </span><br><span class="line">                 </span><br><span class="line">   .weak      DMA_Channel5_IRQHandler              </span><br><span class="line">   .thumb_set DMA_Channel5_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      DMA_Channel6_IRQHandler               </span><br><span class="line">   .thumb_set DMA_Channel6_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      DMA_Channel7_IRQHandler               </span><br><span class="line">   .thumb_set DMA_Channel7_IRQHandler,Default_Handler</span><br><span class="line"></span><br><span class="line">   .weak      DMA_Channel8_IRQHandler               </span><br><span class="line">   .thumb_set DMA_Channel8_IRQHandler,Default_Handler</span><br><span class="line">   </span><br><span class="line">   .weak      ADC_IRQHandler      </span><br><span class="line">   .thumb_set ADC_IRQHandler,Default_Handler</span><br><span class="line">               </span><br><span class="line">   .weak      USB_HP_IRQHandler   </span><br><span class="line">   .thumb_set USB_HP_IRQHandler,Default_Handler</span><br><span class="line">            </span><br><span class="line">   .weak      USB_LP_IRQHandler                  </span><br><span class="line">   .thumb_set USB_LP_IRQHandler,Default_Handler</span><br><span class="line"></span><br><span class="line">   .weak      COMP_1_2_IRQHandler                  </span><br><span class="line">   .thumb_set COMP_1_2_IRQHandler,Default_Handler</span><br><span class="line"> </span><br><span class="line">   .weak      EXTI9_5_IRQHandler   </span><br><span class="line">   .thumb_set EXTI9_5_IRQHandler,Default_Handler</span><br><span class="line">            </span><br><span class="line">   .weak      TIM1_BRK_IRQHandler            </span><br><span class="line">   .thumb_set TIM1_BRK_IRQHandler,Default_Handler</span><br><span class="line">            </span><br><span class="line">   .weak      TIM1_UP_IRQHandler            </span><br><span class="line">   .thumb_set TIM1_UP_IRQHandler,Default_Handler</span><br><span class="line">      </span><br><span class="line">   .weak      TIM1_TRG_COM_IRQHandler      </span><br><span class="line">   .thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler</span><br><span class="line">      </span><br><span class="line">   .weak      TIM1_CC_IRQHandler   </span><br><span class="line">   .thumb_set TIM1_CC_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      TIM2_IRQHandler            </span><br><span class="line">   .thumb_set TIM2_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      TIM3_IRQHandler            </span><br><span class="line">   .thumb_set TIM3_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      TIM4_IRQHandler            </span><br><span class="line">   .thumb_set TIM4_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      I2C1_EV_IRQHandler   </span><br><span class="line">   .thumb_set I2C1_EV_IRQHandler,Default_Handler</span><br><span class="line">                     </span><br><span class="line">   .weak      I2C1_ER_IRQHandler   </span><br><span class="line">   .thumb_set I2C1_ER_IRQHandler,Default_Handler</span><br><span class="line">                     </span><br><span class="line">   .weak      I2C2_EV_IRQHandler   </span><br><span class="line">   .thumb_set I2C2_EV_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      I2C2_ER_IRQHandler   </span><br><span class="line">   .thumb_set I2C2_ER_IRQHandler,Default_Handler</span><br><span class="line">                           </span><br><span class="line">   .weak      SPI1_IRQHandler            </span><br><span class="line">   .thumb_set SPI1_IRQHandler,Default_Handler</span><br><span class="line">                        </span><br><span class="line">   .weak      SPI2_IRQHandler            </span><br><span class="line">   .thumb_set SPI2_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      USART1_IRQHandler      </span><br><span class="line">   .thumb_set USART1_IRQHandler,Default_Handler</span><br><span class="line">                     </span><br><span class="line">   .weak      USART2_IRQHandler      </span><br><span class="line">   .thumb_set USART2_IRQHandler,Default_Handler</span><br><span class="line">                     </span><br><span class="line">   .weak      USART3_IRQHandler      </span><br><span class="line">   .thumb_set USART3_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      EXTI15_10_IRQHandler               </span><br><span class="line">   .thumb_set EXTI15_10_IRQHandler,Default_Handler</span><br><span class="line">               </span><br><span class="line">   .weak      RTCAlarm_IRQHandler               </span><br><span class="line">   .thumb_set RTCAlarm_IRQHandler,Default_Handler</span><br><span class="line">            </span><br><span class="line">   .weak      USBWakeUp_IRQHandler         </span><br><span class="line">   .thumb_set USBWakeUp_IRQHandler,Default_Handler</span><br><span class="line">            </span><br><span class="line">   .weak      TIM8_BRK_IRQHandler         </span><br><span class="line">   .thumb_set TIM8_BRK_IRQHandler,Default_Handler</span><br><span class="line">         </span><br><span class="line">   .weak      TIM8_UP_IRQHandler            </span><br><span class="line">   .thumb_set TIM8_UP_IRQHandler,Default_Handler</span><br><span class="line">         </span><br><span class="line">   .weak      TIM8_TRG_COM_IRQHandler      </span><br><span class="line">   .thumb_set TIM8_TRG_COM_IRQHandler,Default_Handler</span><br><span class="line">      </span><br><span class="line">   .weak      TIM8_CC_IRQHandler   </span><br><span class="line">   .thumb_set TIM8_CC_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      UART4_IRQHandler         </span><br><span class="line">   .thumb_set UART4_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      UART5_IRQHandler         </span><br><span class="line">   .thumb_set UART5_IRQHandler,Default_Handler</span><br><span class="line">   </span><br><span class="line">   .weak      LPUART_IRQHandler         </span><br><span class="line">   .thumb_set LPUART_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      TIM5_IRQHandler            </span><br><span class="line">   .thumb_set TIM5_IRQHandler,Default_Handler</span><br><span class="line">                  </span><br><span class="line">   .weak      TIM6_IRQHandler                  </span><br><span class="line">   .thumb_set TIM6_IRQHandler,Default_Handler</span><br><span class="line">               </span><br><span class="line">   .weak      TIM7_IRQHandler            </span><br><span class="line">   .thumb_set TIM7_IRQHandler,Default_Handler</span><br><span class="line">            </span><br><span class="line">   .weak      CAN_TX_IRQHandler   </span><br><span class="line">   .thumb_set CAN_TX_IRQHandler,Default_Handler</span><br><span class="line">                           </span><br><span class="line">   .weak      CAN_RX0_IRQHandler                  </span><br><span class="line">   .thumb_set CAN_RX0_IRQHandler,Default_Handler</span><br><span class="line">                           </span><br><span class="line">   .weak      CAN_RX1_IRQHandler                  </span><br><span class="line">   .thumb_set CAN_RX1_IRQHandler,Default_Handler</span><br><span class="line">                           </span><br><span class="line">   .weak      CAN_SCE_IRQHandler                  </span><br><span class="line">   .thumb_set CAN_SCE_IRQHandler,Default_Handler</span><br><span class="line">                           </span><br><span class="line">   .weak      LPUART_WKUP_IRQHandler      </span><br><span class="line">   .thumb_set LPUART_WKUP_IRQHandler,Default_Handler</span><br><span class="line">                     </span><br><span class="line">   .weak      LPTIM_WKUP_IRQHandler               </span><br><span class="line">   .thumb_set LPTIM_WKUP_IRQHandler,Default_Handler</span><br><span class="line"></span><br><span class="line">   .weak      LCD_IRQHandler            </span><br><span class="line">   .thumb_set LCD_IRQHandler,Default_Handler</span><br><span class="line">   </span><br><span class="line">   .weak      SAC_IRQHandler            </span><br><span class="line">   .thumb_set SAC_IRQHandler,Default_Handler</span><br><span class="line">               </span><br><span class="line">   .weak      MMU_IRQHandler                  </span><br><span class="line">   .thumb_set MMU_IRQHandler,Default_Handler   </span><br><span class="line"></span><br><span class="line">   .weak      TSC_IRQHandler                  </span><br><span class="line">   .thumb_set TSC_IRQHandler,Default_Handler  </span><br><span class="line">    </span><br><span class="line">   .weak      RAMC_PERR_IRQHandler                  </span><br><span class="line">   .thumb_set RAMC_PERR_IRQHandler,Default_Handler  </span><br><span class="line">    </span><br><span class="line">   .weak      TIM9_IRQHandler                  </span><br><span class="line">   .thumb_set TIM9_IRQHandler,Default_Handler  </span><br><span class="line">   </span><br><span class="line">   .weak      UCDR_IRQHandler                  </span><br><span class="line">   .thumb_set UCDR_IRQHandler,Default_Handler  </span><br><span class="line">   </span><br><span class="line">/************************ (C) COPYRIGHT Nations Technologies Inc *****END OF FILE****/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>

<p><strong>以下为这段<code>assembly</code>代码的注释</strong>：</p>
<pre><code>.syntax unified
</code></pre>
<p>指定统一的<code>ARM</code>和<code>Thumb</code>指令集语法。</p>
<pre><code>.cpu cortex-m4
.fpu softvfp
.thumb
</code></pre>
<p>指定目标<code>CPU</code>为<code>Cortex-M4</code>，浮点单元为软件实现（<code>softvfp</code>），并使用<code>Thumb</code>指令集。</p>
<pre><code>.global  g_pfnVectors
.global  Default_Handler
</code></pre>
<p>声明全局符号<code>g_pfnVectors</code>和<code>Default_Handler</code>，使其在其他汇编文件或<code>C</code>代码中也可访问。</p>
<pre><code>.section  .text.Reset_Handler
.weak  Reset_Handler
.type  Reset_Handler, %function
</code></pre>
<p>定义了一个名为<code>.text.Reset_Handler</code>的代码段，并声明<code>Reset_Handler</code>函数较弱，意味着如果有其他同名函数，将覆盖此声明。</p>
<pre><code>Reset_Handler:	
</code></pre>
<p>定义<code>Reset_Handler</code>函数的开始。</p>
<pre><code>movs  r1, #0
b  LoopCopyDataInit
</code></pre>
<p>将寄存器r1清零，并跳转到<code>LoopCopyDataInit</code>标签。</p>
<pre><code>CopyDataInit:
ldr  r3, =_sidata
ldr  r3, [r3, r1]
str  r3, [r0, r1]
adds  r1, r1, #4
</code></pre>
<p>定义<code>CopyDataInit</code>代码块，从<code>_sidata</code>地址开始复制初始化数据到数据段(<code>_sdata</code>至<code>_edata</code>)。</p>
<pre><code>LoopCopyDataInit:
ldr  r0, =_sdata
ldr  r3, =_edata
adds  r2, r0, r1
cmp  r2, r3
bcc  CopyDataInit
</code></pre>
<p>创建一个循环，将初始化数据从<code>_sidata</code>复制到<code>_sdata</code>，直到<code>_edata</code>。</p>
<pre><code>ldr  r2, =_sbss
b  LoopFillZerobss
</code></pre>
<p>将<code>r2</code>寄存器加载到<code>BSS</code>段的起始地址，并跳转到<code>LoopFillZerobss</code>。</p>
<pre><code>FillZerobss:
movs  r3, #0
str  r3, [r2], #4
</code></pre>
<p>将<code>BSS</code>段的每个位置初始化为<code>0</code>。</p>
<pre><code>LoopFillZerobss:
ldr  r3, = _ebss
cmp  r2, r3
bcc  FillZerobss
</code></pre>
<p>创建一个循环，将<code>BSS</code>段从<code>_sbss</code>到<code>_ebss</code>的所有字节初始化为<code>0</code>。</p>
<pre><code>bl  SystemInit   
bl __libc_init_array
bl  main
bx  lr    
</code></pre>
<p>调用系统初始化函数<code>SystemInit</code>，调用<code>C++</code>静态对象构造函数<code>__libc_init_array</code>，然后调用<code>main</code>函数，并从<code>Reset_Handler</code>返回。</p>
<pre><code>.size  Reset_Handler, .-Reset_Handler
</code></pre>
<p>指定<code>Reset_Handler</code>函数的大小。</p>
<pre><code>.section  .text.Default_Handler,&quot;ax&quot;,%progbits
</code></pre>
<p>定义一个新的代码段，用于默认的中断处理函数。</p>
<p>Default_Handler:<br>Infinite_Loop:<br>  b  Infinite_Loop<br>定义<code>Default_Handler</code>函数，如果处理器接收到未处理的中断，则进入无限循环。</p>
<pre><code>.size  Default_Handler, .-Default_Handler
</code></pre>
<p>指定<code>Default_Handler</code>函数的大小。</p>
<pre><code>.section  .isr_vector,&quot;a&quot;,%progbits
</code></pre>
<p>定义中断向量表的代码段。</p>
<pre><code>g_pfnVectors:
</code></pre>
<p>定义中断向量表的开始。</p>
<pre><code>.word  _estack
.word  Reset_Handler
...
</code></pre>
<p>中断向量表包含了系统堆栈的顶端、重置处理程序的地址和其他中断处理程序的地址。</p>
<pre><code>.weak      NMI_Handler
.thumb_set NMI_Handler,Default_Handler
</code></pre>
<p>声明<code>NMI_Handler</code>为弱引用，并将其默认地址设置为<code>Default_Handler</code>。<br>这段代码的其余部分继续定义中断向量表和提供中断处理程序的弱引用，以便在没有提供特定中断处理程序时使用默认处理程序。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>启动文件</category>
      </categories>
      <tags>
        <tag>MCU</tag>
      </tags>
  </entry>
  <entry>
    <title>I.MX6ULL开发指南</title>
    <url>/2024/07/13/I.MX6ULL%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h3><ol>
<li>下载安装VMware Workstation Pro工具。</li>
<li>下载安装ubuntu 20.04 LTS系统镜像。</li>
<li>快速创建虚拟机。</li>
<li>配置虚拟机环境。</li>
</ol>
<ul>
<li><p>虚拟机-设置(见以下图片)：<br><img src="/../pictures/ubuntu%E9%85%8D%E7%BD%AE1.png" alt="ubuntu配置"><br><img src="/../pictures/ubuntu%E9%85%8D%E7%BD%AE2.png" alt="ubuntu配置"><br><img src="/../pictures/ubuntu%E9%85%8D%E7%BD%AE3.png" alt="ubuntu配置"></p>
</li>
<li><p>网络适配器可按自己需要设置。<br><img src="/../pictures/ubuntu%E9%85%8D%E7%BD%AE4.png" alt="ubuntu配置"></p>
</li>
</ul>
<ol start="5">
<li>启动虚拟机，进入<code>ubuntu</code>系统。</li>
</ol>
<ul>
<li><p>进入系统后会自动弹出<code>DVD</code>, 里面有<code>VMware Tools</code>的压缩包。</p>
</li>
<li><p>复制压缩包到<code>Donwnloads</code>目录下，解压。</p>
</li>
<li><p>执行<code>sudo ./vmware-install.pl</code>安装。 </p>
</li>
<li><p>解决Windows和Ubuntu之间复制粘贴问题。</p>
<ul>
<li>输入安装命令：sudo apt install open-vm-tools</li>
<li>输入命令：sudo apt install open-vm-tools-desktop</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>：输入第一条命令后，等待安装，遇到选择<code>Y/N</code>，选择<code>Y</code>；第一条安装完成后，输入第二条命令，同样遇到选择<code>Y/N</code>，选择<code>Y</code>。<br>安装完毕后，切记：一定要<strong>重新启动Linux系统</strong>才可以双向复制粘贴。</p>
<h3 id="虚拟机安装配置遇到的问题"><a href="#虚拟机安装配置遇到的问题" class="headerlink" title="虚拟机安装配置遇到的问题"></a>虚拟机安装配置遇到的问题</h3><p><a href="https://segmentfault.com/a/1190000039918994">桥接模式资料(仅供参考)</a></p>
<ul>
<li>尝试解决无法使用桥接使用与PC机相同IP上网<ul>
<li>虚拟网络编辑器-还原默认设置（该过程会卸载虚拟网卡，重新安装适配器）</li>
<li>桥接模式启动</li>
<li>笔试还不能关闭网络服务，<code>ubuntu</code>内部配置<code>IPv4</code>（先打开<code>PC主机</code>以太网，按下图所示手动填写<code>地址</code>和<code>DNS</code>）,重新启动网络服务。</li>
</ul>
</li>
</ul>
<p><img src="/../pictures/%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E8%BE%91%E5%99%A8.png" alt="虚拟网络"><br><img src="/../pictures/PC%E6%9C%BAIPv4%E9%85%8D%E7%BD%AE.png" alt="PC以太网配置"><br><img src="/../pictures/ubuntu%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.png" alt="ubuntu网络配置"></p>
<ul>
<li>虚拟机右下角的USB是灰的，不能链接&#x2F;断开。</li>
</ul>
<p><a href="https://blog.csdn.net/weixin_44259058/article/details/127639566">参考资料</a><br><br></p>
<h2 id="Uboot移植"><a href="#Uboot移植" class="headerlink" title="Uboot移植"></a>Uboot移植</h2><p><a href="https://www.eet-china.com/mp/a68264.html">参考资料</a></p>
<h3 id="I-MX6ULL启动模式"><a href="#I-MX6ULL启动模式" class="headerlink" title="I.MX6ULL启动模式"></a>I.MX6ULL启动模式</h3><p><img src="/../pictures/IMX6ULL%E5%90%AF%E5%8A%A8%E6%8B%A8%E7%A0%81%E5%9B%BE.png" alt="IMX6ULL启动拨码图"></p>
<h3 id="Uboot编译烧录"><a href="#Uboot编译烧录" class="headerlink" title="Uboot编译烧录"></a>Uboot编译烧录</h3><ul>
<li><p>将<code>uboot</code>压缩文件<code>uboot-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4.tar.bz2</code>放到<code>/home/xuan/linux/</code>目录下。</p>
</li>
<li><p>将<code>uboot</code>文件<code>tar -xjvf uboot-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4.tar.bz2</code> 解压到该目录下。</p>
</li>
<li><p><code>cd /home/xuan/linux/uboot-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4</code></p>
</li>
<li><p>编写以下脚本：(<code>mx6ull_14x14_evk_emmc.sh</code>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_alientek_emmc_defconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- V=1 -j12</span><br></pre></td></tr></table></figure></li>
<li><p>执行脚本：<code>./mx6ull_14x14_evk_emmc.sh</code></p>
</li>
</ul>
<h4 id="Uboot烧录到SD卡"><a href="#Uboot烧录到SD卡" class="headerlink" title="Uboot烧录到SD卡"></a>Uboot烧录到SD卡</h4><ul>
<li>插上<code>SD卡</code>，启动<code>uboot</code>, <code>SD</code>卡和<code>EMMC</code>驱动检查:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mmc dev 0</span><br><span class="line">mmc info</span><br><span class="line"></span><br><span class="line">mmc dev 1</span><br><span class="line">mmc info</span><br></pre></td></tr></table></figure></li>
<li>烧写验证与驱动测试<ul>
<li>挂载<code>SD卡</code>，不做描述，挂载上之后<code>ls /dev/sd*</code>显示。</li>
<li>执行以下<code>shell</code>指令。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/linux/uboot-alientek-v2.4		//进入uboot文件夹	</span><br><span class="line">chmod 777 imxdownload 				//给予 imxdownload 可执行权限</span><br><span class="line">./imxdownload u-boot.bin /dev/sdb 	//烧写到 SD 卡中，不能烧写到/dev/sda 或 sda1 里面</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<br>

<ul>
<li><code>U-Boot</code> 图形化配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libncurses5-dev</span><br><span class="line"></span><br><span class="line">make mx6ull_alientek_emmc_defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>配置网口的环境变量，开发板上的<code>ENET2</code>,上电进入<code>uboot</code>,打开的<code>USB_TTL</code>对应的串口控制台。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env default -a;saveenv				//default好像有问题</span><br><span class="line">setenv ipaddr 192.168.104.130		//开发板 ip 地址</span><br><span class="line">setenv ethaddr b8:ae:1d:01:00:00	//开发板的MAC地址，一定要设置, 如有多块开发板，MAC需不一致</span><br><span class="line">setenv gatewayip 192.168.104.1		//网关地址</span><br><span class="line">setenv netmask 255.255.240.0		//子网掩码</span><br><span class="line">setenv serverip 192.168.104.129		//服务器 IP 地址，也就是 Ubuntu 主机 IP 地址，用于调试代码。</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h2 id="Linux内核移植"><a href="#Linux内核移植" class="headerlink" title="Linux内核移植"></a>Linux内核移植</h2><h3 id="移植步骤"><a href="#移植步骤" class="headerlink" title="移植步骤"></a>移植步骤</h3><p><strong>1. Ubuntu下搭建网络传输环境</strong></p>
<p><strong>1.1 搭建网络tftp服务</strong></p>
<ul>
<li><p>执行以下指令，安装<code>xinetd</code>: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install xinetd</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询<code>/etc/</code>下是否存在 <code>xinetd.conf</code> 文件，没有的话则自己新建一个。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /etc/xinetd.conf</span><br><span class="line">sudo vi /etc/xinetd.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建出来的文件是空白的， 修改 <code>xinetd.conf</code> 文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Simple configuration file <span class="keyword">for</span> xinetd</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Some defaults, and include /etc/xinetd.d/</span></span></span><br><span class="line">defaults</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please note that you need a log_type line to be able to use log_on_success</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and log_on_failure. The default is the following :</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">log_type = SYSLOG daemon info</span></span><br><span class="line">&#125;</span><br><span class="line">includedir /etc/xinetd.d</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建 <code>TFTP</code> 目录，这里建立在&#x2F;home&#x2F;xuan&#x2F;linux 目录下，目录名为 tftp。将 tftp 目录赋予可读可写可执行权限。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/xuan/linux/tftp</span><br><span class="line">sudo chmod 777 /home/xuan/linux/tftp/</span><br><span class="line">cd /home/xuan/linux/</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行以下程序安装 <code>tftp-hpa</code> 和 <code>tftpd-hpa</code> 服务程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tftp-hpa tftpd-hpa</span><br><span class="line">sudo vi /etc/default/tftpd-hpa</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行以下指令创建<code>/etc/xinetd.d/tftp</code>配置文件。（如果没有 <code>xinetd.d</code> 这个目录，可以先自己手动创建）,注意 <code>server_args = -s</code> 后面要添加自己的 <code>tftp</code> 工作路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server tftp</span><br><span class="line">&#123;</span><br><span class="line">socket_type = dgram</span><br><span class="line">wait = yes</span><br><span class="line">disable = no</span><br><span class="line">user = root</span><br><span class="line">protocol = udp</span><br><span class="line">server = /usr/sbin/in.tftpd</span><br><span class="line">server_args = -s /home/xuan/linux/tftp -c</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">log_on_success += PID HOST DURATION</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">log_on_failure += HOST</span></span><br><span class="line">per_source = 11</span><br><span class="line">cps =100 2</span><br><span class="line">flags =IPv4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;添加 <code>tftp</code> 文件后， 执行以下指令重启 <code>tftpd-hpa</code>, 重启 <code>xinetd</code> 服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service tftpd-hpa restart</span><br><span class="line">sudo service xinetd restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>确保网络环境正常，<code>Ubuntu</code>、<code>Windows</code>和<code>开发板</code>能相互 <code>ping</code> 通。</p>
<ul>
<li>开发板 IP： 192.168.104.130</li>
<li>虚拟机 IP： 192.168.104.129</li>
<li>电脑网口的 IP： 192.168.104.29</li>
</ul>
</li>
</ul>
<br>

<p><strong>1.2 搭建网络nfs服务</strong></p>
<ul>
<li><p>在 <code>Ubuntu</code> 终端执行以下指令安装 <code>NFS</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建 <code>NFS</code> 共享目录，并给予 <code>NFS</code> 目录可读可写可执行权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /home/xuan/linux/nfs</span><br><span class="line">sudo chmod 777 /home/xuan/linux/nfs/</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行以下指令打开 <code>etc/exports</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/exports</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 <code>etc/exports</code> 文件，在最后添加如下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/alientek/linux/nfs *(rw,sync,no_root_squash)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>/home/alientek/linux/nfs</code> 表示 <code>NFS</code> 共享的目录<br><code>*</code>表示允许所有的网络段访问<br><code>rw</code> 表示访问者具有可读写权限<br><code>sync</code> 表示将缓存写入设备中，可以说是同步缓存的意思<br><code>no_root_squash</code> 表示访问者具有 <code>root</code> 权限。</p>
<ul>
<li><p>执行以下指令重启 <code>NFS</code> 服务器, 查看 <code>NFS</code> 共享目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/nfs-kernel-server restart</span><br><span class="line">showmount -e</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 <code>NFS</code> 服务开机自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable nfs-kernel-server</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试 <code>NFS</code> 服务，执行以下指令设置开发板 <code>IP</code>，创建一个 <code>get</code> 目录，将虚拟机（<code>192.168.104.129</code>） <code>NFS</code> 共享目<br>录挂载到到开发板的 <code>get</code> 目录中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir get</span><br><span class="line">mount -t nfs -o nolock,nfsvers=3 192.168.104.129:/home/xuan/linux/nfs get/</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看挂载的 <code>NFS</code> 目录：<code>df</code>, 显示如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.104.129:/home/xuan/linux/nfs 204795392 14416896 179902464   8% /home/root/get</span><br></pre></td></tr></table></figure></li>
<li><p>卸载 <code>NFS</code> 目录：<code>umount get</code></p>
</li>
</ul>
<br>

<p><strong>2. 拷贝内核文件</strong></p>
<ul>
<li><p>将内核压缩文件<code>linux-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4.tar.bz2</code>放到<code>/home/xuan/linux/linux-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4</code>目录下。</p>
</li>
<li><p>将内核文件<code>tar -xjvf linux-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4.tar.bz2</code> 解压到该目录下。</p>
</li>
</ul>
<p><strong>3. 编译内核文件</strong></p>
<p>按以下步骤进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make clean 					//第一次编译 Linux 内核之前先清理一下</span><br><span class="line">make imx_v7_mfg_defconfig 	//配置 Linux 内核</span><br><span class="line">make -j16					//编译 Linux 内核</span><br></pre></td></tr></table></figure>
<p>发现编译报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  LZO     arch/arm/boot/compressed/piggy.lzo</span><br><span class="line">/bin/sh: 1: lzop: not found</span><br><span class="line">make[2]: *** [arch/arm/boot/compressed/Makefile:180：arch/arm/boot/compressed/piggy.lzo] 错误 1</span><br><span class="line">make[1]: *** [arch/arm/boot/Makefile:52：arch/arm/boot/compressed/vmlinux] 错误 2</span><br><span class="line">make: *** [arch/arm/Makefile:316：zImage] 错误 2</span><br><span class="line">make: *** 正在等待未完成的任务....</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<ol>
<li>安装lzop：sudo apt install lzop</li>
<li>添加lzop到环境变量：export PATH&#x3D;$PATH:&#x2F;usr&#x2F;bin(直接安装的不需要添加环境变量)</li>
<li>重新编译：make -j16</li>
</ol>
<br>

<ul>
<li>若执行 <code>./mx6ull_alientek_emmc.sh</code></li>
</ul>
<p>发现编译报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;command-line&gt;: fatal error: curses.h: 没有那个文件或目录</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<ul>
<li>执行 <code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</code> 后报错 <code>fatal error:curses.h:</code>没有那个文件或目录，这个是少了某个库，执行如下指令安装库：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libncurses*</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<p><strong>4. 整理编译后的镜像文件</strong></p>
<p><code>Linux</code> 内核编译完成以后会在 <code>arch/arm/boot</code> 目录下生成 <code>zImage</code> 镜像文件，如果使用设备树<br>的话还会在 <code>arch/arm/boot/dtb</code> 目录下开发板对应的.dtb(设备树)文件，比如 <code>imx6ull-alientek-emmc.dtb</code><br>就是 <code>NXP</code> 官方的 <code>I.MX6ULL EVK开发板</code>对应的设备树文件。至此我们得到两个文件：</p>
<ul>
<li><code>Linux</code> 内核镜像文件： <code>zImage。</code></li>
<li><code>NXP</code>官方<code>I.MX6ULL EVK开发板</code>对应的设备树文件： imx6ull-alientek-emmc.dtb。</li>
</ul>
<br>

<p><strong>5. 内核启动测试</strong></p>
<ul>
<li><p>修改<code>uboot</code> 中的环境变量 <code>bootargs</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw</span><br></pre></td></tr></table></figure>
</li>
<li><p>将上一小节编译出来的 <code>zImage</code> 和 <code>imx6ull-alientek-emmc.dtb</code> 复制到 <code>Ubuntu</code> 中的 <code>tftp</code> 目录下，<br>因为我们要在 <code>uboot</code> 中使用 <code>tftp</code> 命令将其下载到开发板中，拷贝命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp arch/arm/boot/zImage /home/xuan/linux/tftpboot/ -f</span><br><span class="line">cp arch/arm/boot/dtb/imx6ull-alientek-emmc.dtb /home/xuan/linux/tftpboot/ -f</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝完成以后就可以测试了，启动开发板，进入 <code>uboot</code> 命令行模式，然后输入如下命令将<br><code>zImage</code> 和 <code>imx6ull-alientek-emmc.dtb</code> 下载到开发板中：</p>
</li>
</ul>
<p><strong>从tftp启动：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tftp 80800000 zImage</span><br><span class="line">tftp 83000000 imx6ull-alientek-emmc.dtb</span><br><span class="line">bootz 80800000 - 83000000</span><br></pre></td></tr></table></figure>

<p><strong>从EMMC启动：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatload mmc 1:1 80800000 zImage</span><br><span class="line">fatload mmc 1:1 83000000 imx6ull-alientek-emmc.dtb</span><br><span class="line">bootz 80800000 - 83000000</span><br></pre></td></tr></table></figure>
<p>或者在uboot中保存环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenv bootcmd &#x27;mmc dev 1;fatload mmc 1:1 80800000 zImage;fatload mmc 1:1 83000000 imx6ull-alientek-emmc.dtb;bootz 80800000 - 83000000&#x27;</span><br><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>

<br>

<h3 id="从网络启动Linux系统"><a href="#从网络启动Linux系统" class="headerlink" title="从网络启动Linux系统"></a>从网络启动Linux系统</h3><p><a href="https://blog.angustar.com/archives/system-migration-and-rootfs-construction-based-on-i-mx6ull-2.html">移植参考资料</a></p>
<h4 id="使用tftpboot启动传输。"><a href="#使用tftpboot启动传输。" class="headerlink" title="使用tftpboot启动传输。"></a>使用<code>tftpboot</code>启动传输。</h4><ul>
<li>拨码到从<code>SD</code>卡启动，开发板上电&#x2F;<code>RESET</code>，进入<code>uboot</code>。</li>
<li>在<code>uboot</code>配置<code>bootargs</code>和<code>bootcmd</code>参数并保存。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//`root=/dev/mmcblk1p2 rootwait rw` 为使用 eMMC 中已有的根文件系统</span><br><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;	</span><br><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000&#x27;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<ul>
<li>输入<code>boot</code>启动</li>
</ul>
<h4 id="使用nfs挂载rootfs。"><a href="#使用nfs挂载rootfs。" class="headerlink" title="使用nfs挂载rootfs。"></a>使用<code>nfs</code>挂载<code>rootfs</code>。</h4><ul>
<li>拨码到从<code>SD</code>卡启动，开发板上电&#x2F;<code>RESET</code>，进入<code>uboot</code>。</li>
<li>在<code>uboot</code>配置<code>bootargs</code>参数并保存。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.104.129:/home/xuan/linux/nfs/rootfs,proto=tcp rw ip=192.168.104.130:192.168.104.129:192.168.104.1:255.255.240.0::eth0:off&#x27; 		//设置 bootargs</span><br><span class="line">saveenv 				//保存环境变量</span><br></pre></td></tr></table></figure></li>
<li>输入<code>boot</code>启动</li>
</ul>
<br>

<p><strong>Error solving</strong></p>
<p>[参考资料]：<a href="https://blog.csdn.net/weixin_44256228/article/details/113830253">https://blog.csdn.net/weixin_44256228/article/details/113830253</a>)</p>
<ul>
<li>显示挂载失败，一大堆错误，显示没挂载上</li>
<li><code>IMX6ULL</code>通过NFS挂载根文件系统失败的方法<ul>
<li>修改<code>/etc/default/nfs-kernel-server</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/default/nfs-kernel-server</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>nfs-kernel-server</code>文件修改内容如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Number of servers to start up</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">RPCNFSDCOUNT=8</span></span><br><span class="line">RPCNFSDCOUNT=&quot;-V 2 8&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Runtime priority of server (see <span class="built_in">nice</span>(1))</span></span><br><span class="line">RPCNFSDPRIORITY=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Options <span class="keyword">for</span> rpc.mountd.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If you have a port-based firewall, you might want to <span class="built_in">set</span> up</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a fixed port here using the --port option. For more information,</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see rpc.mountd(8) or http://wiki.debian.org/SecuringNFS</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">To <span class="built_in">disable</span> NFSv4 on the server, specify <span class="string">&#x27;--no-nfs-version 4&#x27;</span> here</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">RPCMOUNTDOPTS=<span class="string">&quot;--manage-gids&quot;</span></span></span><br><span class="line">RPCMOUNTDOPTS=&quot;-V 2 --manage-gids&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Do you want to start the svcgssd daemon? It is only required <span class="keyword">for</span> Kerberos</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">exports. Valid alternatives are <span class="string">&quot;yes&quot;</span> and <span class="string">&quot;no&quot;</span>; the default is <span class="string">&quot;no&quot;</span>.</span></span><br><span class="line">NEED_SVCGSSD=&quot;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Options <span class="keyword">for</span> rpc.svcgssd.</span></span><br><span class="line">RPCSVCGSSDOPTS=&quot;--nfs-version 2,3,4 --debug --syslog&quot;</span><br></pre></td></tr></table></figure></li>
<li>重启NFS服务器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service nfs-kernel-server restart</span><br></pre></td></tr></table></figure></li>
<li>重新开机挂载，问题解决。</li>
</ul>
<br>

<h2 id="Linux驱动开发"><a href="#Linux驱动开发" class="headerlink" title="Linux驱动开发"></a>Linux驱动开发</h2><h3 id="老字符驱动开发（手动创建节点）"><a href="#老字符驱动开发（手动创建节点）" class="headerlink" title="老字符驱动开发（手动创建节点）"></a>老字符驱动开发（手动创建节点）</h3><ul>
<li><p><code>led</code>驱动的<code>Makefile</code>文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KERNELDIR := /home/xuan/linux/linux-ga</span><br><span class="line">CURRENT_PATH := $(shell pwd)</span><br><span class="line">obj-m := led.o</span><br><span class="line">build: kernel_modules</span><br><span class="line">kernel_modules:</span><br><span class="line">$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) modules</span><br><span class="line">clean:</span><br><span class="line">$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>make</code>编译, 生成<code>led.ko</code>文件, 这个是内核模块（Kernel Module）文件，很重要。</p>
</li>
<li><p>编译<code>app</code>文件，输入如下命令：<br>arm-linux-gnueabihf-gcc ledApp.c -o ledApp</p>
</li>
<li><p>复制到<code>rootfs</code>中，若没有<code>rootfs/lib/modules/4.1.15/</code>,先建立文件夹，输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/xuan/linux/nfs/rootfs/lib/modules/4.1.15/</span><br><span class="line">sudo cp led.ko led /home/xuan/linux/nfs/rootfs/lib/modules/4.1.15/ -f</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nfs</code>挂载<code>rootfs</code>，进入开发板</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /lib/modules/4.1.15</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">depmod 					//第一次加载驱动的时候需要运行此命令</span><br><span class="line">insmod led.ko</span><br><span class="line">或者</span><br><span class="line">modprobe led.ko 		//加载 led.ko 驱动文件</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/devices		//查看当前系统中有没有 led 这个设备</span><br><span class="line">mknod /dev/led c 200 0		//创建设备节点文件</span><br><span class="line">./ledApp /dev/led 1		//亮灯</span><br><span class="line">./ledApp /dev/led 0		//灭灯</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmmod led.ko</span><br><span class="line">或者</span><br><span class="line">modprobe -r led.ko 		//卸载 led.ko 驱动文件</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="老字符驱动开发（自动创建节点）"><a href="#老字符驱动开发（自动创建节点）" class="headerlink" title="老字符驱动开发（自动创建节点）"></a>老字符驱动开发（自动创建节点）</h3><ul>
<li><p>编写 <code>Makefile</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">KERNELDIR := /home/xuan/linux/linux-ga</span><br><span class="line">CURRENT_PATH := $(shell pwd)</span><br><span class="line"></span><br><span class="line">obj-m := newchrled.o</span><br><span class="line"></span><br><span class="line">build: kernel_modules</span><br><span class="line"></span><br><span class="line">kernel_modules:</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) modules</span></span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译出驱动模块文件,编译成功以后就会生成一个名为<code>newchrled.ko</code>的驱动模块文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/linux/drivers/03_newchrled</span><br><span class="line">make -j32</span><br><span class="line">arm-linux-gnueabihf-gcc ledApp.c -o ledApp</span><br><span class="line">cp ledApp newchrled.ko ~/linux/nfs/rootfs/lib/modules/4.1.15</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新上电运行开发板</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /lib/modules/4.1.15</span><br><span class="line">depmod 						//第一次加载驱动的时候需要运行此命令</span><br><span class="line">modprobe newchrled.ko 		//加载驱动</span><br><span class="line">ls /dev/newchrled -l		//查看/dev/newchrdev 这个设备节点文件是否存在</span><br><span class="line">./ledApp /dev/newchrled 1 	//打开 LED 灯</span><br><span class="line">./ledApp /dev/newchrled 0 	//关闭 LED 灯</span><br><span class="line">rmmod newchrled.ko</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="Linux-设备树"><a href="#Linux-设备树" class="headerlink" title="Linux 设备树"></a>Linux 设备树</h3><p>以LED点灯驱动为例主要步骤：</p>
<ul>
<li>修改设备树(.dts文件),跟根节点下添加设备子节点，子节点添加属性，举例：<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">alphaled</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;atkalpha-led&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt; <span class="number">0X020C406C</span> <span class="number">0X04</span> /* CCM_CCGR1_BASE */</span></span><br><span class="line"><span class="params">	<span class="number">0X020E0068</span> <span class="number">0X04</span> /* SW_MUX_GPIO1_IO03_BASE */</span></span><br><span class="line"><span class="params">	<span class="number">0X020E02F4</span> <span class="number">0X04</span> /* SW_PAD_GPIO1_IO03_BASE */</span></span><br><span class="line"><span class="params">	<span class="number">0X0209C000</span> <span class="number">0X04</span> /* GPIO1_DR_BASE */</span></span><br><span class="line"><span class="params">	<span class="number">0X0209C004</span> <span class="number">0X04</span> &gt;</span><span class="punctuation">;</span> <span class="comment">/* GPIO1_GDIR_BASE */</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure></li>
<li>在<code>linux</code>目录下重新编译设备树：<code>make dtbs</code></li>
<li>编译完成以后得到<code>imx6ull-alientek-emmc.dtb</code>，使用新的 <code>imx6ull-alientek-emmc.dtb</code>启动<code>Linux</code>内核</li>
<li><code>Linux</code>启动成功以后进入到<code>/proc/device-tree/</code>目录中查看是否有<code>alphaled</code>这个节点,若没有则修改失败</li>
<li>编写<code>dtsled.c</code>文件和文件<code>ledApp.c</code>,修改<code>Makefile</code>中的<code>KERNELDIR</code>参数为<code>/home/xuan/linux/linux-ga</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j32</span><br><span class="line">arm-linux-gnueabihf-gcc ledApp.c -o ledApp</span><br></pre></td></tr></table></figure></li>
<li>编译出来的<code>dtsled.ko</code>和<code>ledApp</code>这两个文件拷贝到<code>rootfs/lib/modules/4.1.15</code>目录中，<strong>重启开发板</strong>，进入到目录<code>lib/modules/4.1.15</code>中，输入如下命令加载<code>dtsled.ko</code>驱动模块：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">depmod 				//第一次加载驱动的时候需要运行此命令</span><br><span class="line">modprobe dtsled.ko 		//加载驱动</span><br><span class="line">./ledApp /dev/dtsled 1 		//打开 LED 灯</span><br><span class="line">./ledApp /dev/dtsled 0 		//关闭 LED 灯</span><br><span class="line">rmmod dtsled.ko</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="pinctrl-和-gpio-子系统实验"><a href="#pinctrl-和-gpio-子系统实验" class="headerlink" title="pinctrl 和 gpio 子系统实验"></a>pinctrl 和 gpio 子系统实验</h3><h4 id="pinctrl-子系统介绍"><a href="#pinctrl-子系统介绍" class="headerlink" title="pinctrl 子系统介绍"></a>pinctrl 子系统介绍</h4><p><code>pinctrl</code> 子系统主要工作内容如下：</p>
<ul>
<li>获取设备树中 <code>pin</code> 信息。</li>
<li>根据获取到的 <code>pin</code> 信息来设置 <code>pin</code> 的复用功能</li>
<li>根据获取到的 <code>pin</code> 信息来设置 <code>pin</code> 的电气特性，比如上&#x2F;下拉、速度、驱动能力等。</li>
</ul>
<p>对于我们使用者来讲，只需要在设备树里面设置好某个 <code>pin</code> 的相关属性即可，其他的初始化工作均由 <code>pinctrl</code> 子系统来完成， <code>pinctrl</code> 子系统源码目录为 <code>drivers/pinctrl</code>。</p>
<br>

<h4 id="设备树中添加-pinctrl-节点模板"><a href="#设备树中添加-pinctrl-节点模板" class="headerlink" title="设备树中添加 pinctrl 节点模板"></a>设备树中添加 pinctrl 节点模板</h4><ul>
<li>创建对应的节点，打开 <code>imx6ull-alientek-emmc.dts</code>，在 <code>iomuxc</code> 节点中的 <code>imx6ul-evk</code> 子节点下添加 “<code>pinctrl_test</code>” 节点</li>
<li>添加 “<code>fsl,pins</code>” 属性，名字一定要为“<code>fsl,pins</code>”，因为对于 <code>I.MX</code> 系列 <code>SOC</code> 而言， <code>pinctrl</code> 驱动程序是通过读取“<code>fsl,pins</code>”属性值来获取 <code>PIN</code> 的配置信息</li>
</ul>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pinctrl_test:</span> <span class="title class_">testgrp</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="comment">/* 具体的 PIN 信息 */</span></span><br><span class="line">		<span class="attr">fsl,pins</span> <span class="operator">=</span> <span class="params">&lt;</span></span><br><span class="line"><span class="params">			MX6UL_PAD_GPIO1_IO00__GPIO1_IO00 config 	/*config 是具体设置值*/</span></span><br><span class="line"><span class="params">		&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>至此，我们已经在 <code>imx6ull-alientek-emmc.dts</code> 文件中添加好了 <code>test</code> 设备所使用的 <code>PIN</code> 配置信息。</li>
</ul>
<br>

<h4 id="gpio子系统"><a href="#gpio子系统" class="headerlink" title="gpio子系统"></a>gpio子系统</h4><br>

<h4 id="gpio实验"><a href="#gpio实验" class="headerlink" title="gpio实验"></a>gpio实验</h4><ul>
<li><p>添加 <code>pinctrl</code> 节点, ，打开 <code>imx6ull-alientekemmc.dts</code>，在 <code>iomuxc</code> 节点的 <code>imx6ul-evk</code> 子节点下创建一个名为“<code>pinctrl_led</code>”的子节点</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pinctrl_led:</span> <span class="title class_">ledgrp</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">fsl,pins</span> <span class="operator">=</span> <span class="params">&lt;</span></span><br><span class="line"><span class="params">		MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 <span class="number">0x10B0</span> /* LED0 */</span></span><br><span class="line"><span class="params">	&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 <code>LED</code> 设备节点, 在根节点“<code>/</code>”下创建 <code>LED</code> 灯节点，节点名为“<code>gpioled</code>”</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">gpioled</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;atkalpha-gpioled&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">	pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_led</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">led-gpio</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> <span class="number">3</span> GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 <code>PIN</code> 是否被其他外设使用</p>
<ul>
<li>检查 <code>pinctrl</code> 设置。</li>
<li>如果这个 <code>PIN</code> 配置为 <code>GPIO</code> 的话，检查这个 <code>GPIO</code> 有没有被别的外设使用。</li>
</ul>
</li>
<li><p>在本章实验中 <code>LED</code> 灯使用的 <code>PIN</code> 为 <code>GPIO1_IO03</code>，在 <code>imx6ull-alientek-emmc.dts</code> 中，先检查 <code>GPIO_IO03</code> 这个 <code>PIN</code> 有没有被其他的 <code>pinctrl</code> 节点使用。</p>
</li>
<li><p>如别的模块有使用到<code>GPIO_IO03</code>，需要注释掉。</p>
</li>
</ul>
<br>

<h3 id="Linux-蜂鸣器实验"><a href="#Linux-蜂鸣器实验" class="headerlink" title="Linux 蜂鸣器实验"></a>Linux 蜂鸣器实验</h3><ul>
<li><p>打开<code>imx6ull-alientekemmc.dts</code>，在 <code>iomuxc</code> 节点的 <code>imx6ul-evk</code> 子节点下创建一个名为“<code>pinctrl_beep</code>”的子节点</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pinctrl_beep:</span> <span class="title class_">beepgrp</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">fsl,pins</span> <span class="operator">=</span> <span class="params">&lt;</span></span><br><span class="line"><span class="params">		MX6ULL_PAD_SNVS_TAMPER1__GPIO5_IO01 <span class="number">0x10B0</span> /* beep */</span></span><br><span class="line"><span class="params">	&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在根节点“<code>/</code>”下创建 <code>BEEP</code> 节点，节点名为“<code>beep</code>”</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">beep</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;atkalpha-beep&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">	pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_beep</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">beep-gpio</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio5</span> <span class="number">1</span> GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 <code>PIN</code> 是否被其他外设使用</p>
</li>
<li><p>蜂鸣器驱动程序编写</p>
</li>
<li><p>编写测试 <code>APP</code></p>
</li>
<li><p>编译驱动程序: <code>make -j32</code></p>
</li>
<li><p>编译测试 <code>APP</code>: <code>arm-linux-gnueabihf-gcc beepApp.c -o beepApp</code></p>
</li>
<li><p>开发板运行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">depmod 			//第一次加载驱动的时候需要运行此命令</span><br><span class="line">modprobe beep.ko 	//加载驱动</span><br><span class="line">./beepApp /dev/beep 1 	//打开蜂鸣器</span><br><span class="line">./beepApp /dev/beep 0 	//关闭蜂鸣器</span><br><span class="line">rmmod beep.ko</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

]]></content>
      <categories>
        <category>嵌入式</category>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>I.MX6ULL</tag>
        <tag>NXP</tag>
      </tags>
  </entry>
</search>
