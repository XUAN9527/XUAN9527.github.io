<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ESP32开发小贴士</title>
    <url>/2024/02/22/ESP32%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
    <content><![CDATA[<h2 id="ESP32-ESP-IDF自定义组件"><a href="#ESP32-ESP-IDF自定义组件" class="headerlink" title="ESP32 ESP-IDF自定义组件"></a>ESP32 ESP-IDF自定义组件</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p><a href="https://link.zhihu.com/?target=https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/build-system.html%23component-cmakelists-files">英文官方文档链接</a><br><a href="https://link.zhihu.com/?target=https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-guides/build-system.html%23id21">中文官方文档链接</a></p>
<h4 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h4><p>此示例在《ESP32 smart_config和airkiss配网》<br><a href="https://zhuanlan.zhihu.com/p/440454542">https://zhuanlan.zhihu.com/p/440454542</a><br><a href="https://link.zhihu.com/?target=https://blog.csdn.net/chentuo2000/article/details/121687760">https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/121687760</a><br>基础上，增加连接成功后点亮板载LED功能。<br>实现所需功能后将各功能代码分离，再将分离后的代码构造成组件，使得项目有清晰的结构，方便功能代码移植.</p>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>《Win10启用Linux子系统安装Ubuntu》<br><a href="https://link.zhihu.com/?target=https://blog.csdn.net/chentuo2000/article/details/112131624">https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/112131624</a></p>
<p>《用乐鑫国内Gitee镜像搭建ESP32开发环境》<br><a href="https://link.zhihu.com/?target=https://blog.csdn.net/chentuo2000/article/details/113424934">https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/113424934</a></p>
<h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><h4 id="拷贝-初始化例程"><a href="#拷贝-初始化例程" class="headerlink" title="拷贝 &amp;&amp; 初始化例程"></a>拷贝 &amp;&amp; 初始化例程</h4><p>将例子项目<code>hello_world</code>复制到ESP-IDF开发工具之外,更名为components_demo:</p>
<pre><code>cd ~/esp
cp -r ~/esp/esp-adf/esp-idf/examples/get-started/hello_world ./components_demo
</code></pre>
<p>清空build目录:</p>
<pre><code>cd ~/esp/components_demo
rm -r build/*
</code></pre>
<p>注意，每当添加了新组件就要删除build目录下的全部内容，或者执行下面这条命令：</p>
<pre><code>idf.py fullclean
</code></pre>
<p>清除以前的构建。</p>
<h4 id="添加组件letter-shell"><a href="#添加组件letter-shell" class="headerlink" title="添加组件letter_shell"></a>添加组件letter_shell</h4><pre><code>idf.py -C components create-component letter_shell
</code></pre>
<p>该命令会创建一个新组件,新组件将包含构建组件所需的一组空文件。我们的工作就是在这一组空文件中写上我们的代码。<br>如果熟悉了组件结构，也可以直接在项目中手工创建。</p>
<h4 id="项目树"><a href="#项目树" class="headerlink" title="项目树"></a>项目树</h4><p>构建好的项目结构如下:</p>
<p><img src="/../pictures/component_demo%E8%AE%BE%E5%A4%87%E6%A0%91.png" alt="component_demo设备树"></p>
<p>注意：组件目录components名字不能改，其下的组件名可以随意取。build目录是编译时生成的，编译的结果都放在其中。dependencies.lock是随原来的项目复制过来的不要改。sdkconfig文件可以用idf.py menuconfig命令修改。</p>
<h3 id="代码和说明"><a href="#代码和说明" class="headerlink" title="代码和说明"></a>代码和说明</h3><p>各文件的位置关系很重要，请对照前面的项目树看代码文件。</p>
<h4 id="项目的根CMakeLists-txt文件"><a href="#项目的根CMakeLists-txt文件" class="headerlink" title="项目的根CMakeLists.txt文件"></a>项目的根CMakeLists.txt文件</h4><pre><code># The following lines of boilerplate have to be in your project&#39;s
# CMakeLists in this exact order for cmake to work correctly
cmake_minimum_required(VERSION 3.16)

include($ENV&#123;IDF_PATH&#125;/tools/cmake/project.cmake)
project(components_demo)
</code></pre>
<p>只需要修改<code>project</code>中的项目名称。</p>
<h4 id="main目录"><a href="#main目录" class="headerlink" title="main目录"></a>main目录</h4><p>CMakeLists.txt</p>
<pre><code>idf_component_register(SRCS &quot;main.c&quot;
                INCLUDE_DIRS &quot;.&quot;)
</code></pre>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shell_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *TAG = <span class="string">&quot;sample test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">esp_err_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize NVS.</span></span><br><span class="line">    ret = nvs_flash_init();</span><br><span class="line">    <span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) &#123;</span><br><span class="line">        ESP_ERROR_CHECK(nvs_flash_erase());</span><br><span class="line">        ret = nvs_flash_init();</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_ERROR_CHECK( ret );</span><br><span class="line"></span><br><span class="line">	esp_log_level_set(TAG, ESP_LOG_INFO);</span><br><span class="line">	ESP_LOGI(TAG,<span class="string">&quot;this is a test program&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	userShellInit();</span><br><span class="line"></span><br><span class="line">	logInfo(<span class="string">&quot;log info!&quot;</span>);</span><br><span class="line">	logDebug(<span class="string">&quot;log debug!&quot;</span>);</span><br><span class="line">	logWarning(<span class="string">&quot;log warning!&quot;</span>);</span><br><span class="line">	logError(<span class="string">&quot;log error!&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		logDebug(<span class="string">&quot;log loop!&quot;</span>);</span><br><span class="line">		vTaskDelay(pdMS_TO_TICKS(<span class="number">2000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头文件nvs_flash.h是对系统组件的引用，shell_port.h是对自定义组件的引用。</p>
<h4 id="letter-shell组件"><a href="#letter-shell组件" class="headerlink" title="letter_shell组件"></a>letter_shell组件</h4><p><code>CMakeLists.txt</code>:</p>
<pre><code>idf_component_register(
    SRCS &quot;shell.c&quot;
        &quot;shell_ext.c&quot;
        &quot;log.c&quot;
        &quot;shell_port.c&quot;
    INCLUDE_DIRS &quot;include&quot;
    LDFRAGMENTS &quot;shell.lf&quot;
    # PRIV_REQUIRES led
    REQUIRES esp_driver_uart
)
</code></pre>
<h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><p>1、PRIV_REQUIRES<br>该参数指定对其它自定义组件的依赖，即私有依赖项。</p>
<p><code>PRIV_REQUIRES led</code>表示指出在<code>smart_config</code>组件中要用到自定义的<code>led</code>组件。组件名字可以加引号，也可以不加。多个组件用空格分开。</p>
<p>2、 REQUIRES<br>该参数指定对系统组件的依赖，即公共依赖项。</p>
<p><code>REQUIRES esp_driver_uart</code> 表示在<code>letter_shell</code>组件中要用到系统组件<code>esp_driver_uart</code>。</p>
<p>3、系统组件的确定</p>
<p>对于要依赖的系统组件不像私有依赖项那样一目了然，有时我们并不清楚所要的系统组件名称。比如我们不知道需要组件wpa_supplicant，这时我们可以先编译一次，看看错误信息：</p>
<p><img src="/../pictures/requires_error.png" alt="requires_error"></p>
<p>在<code>CMakeLists.txt</code>中添加依赖组件<code>REQUIRES esp_driver_uart</code>，编译通过。</p>
<h4 id="关于CMakeLists-txt文件"><a href="#关于CMakeLists-txt文件" class="headerlink" title="关于CMakeLists.txt文件"></a>关于CMakeLists.txt文件</h4><p>根和每个目录都有一个<code>CMakeLists.txt</code>文件，开始遇到的问题是不知道目录结构和怎样写<code>CMakeLists.txt</code>文件，要注意每一层目录中<code>CMakeLists.txt</code>文件的写法，本文的例子给出了一个简单的示范。对于复杂的项目还需要更多编写<code>CMakeLists.txt</code>文件的知识，请看简介中给出的官方文档。</p>
<h2 id="ESP32移植Letter-shell问题"><a href="#ESP32移植Letter-shell问题" class="headerlink" title="ESP32移植Letter_shell问题"></a>ESP32移植Letter_shell问题</h2><h3 id="添加shell组件及其log，编译出错"><a href="#添加shell组件及其log，编译出错" class="headerlink" title="添加shell组件及其log，编译出错"></a>添加shell组件及其log，编译出错</h3><h4 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因:"></a>可能原因:</h4><ol>
<li><p>宏使用不正确: 如果 SHELL_FREE 旨在实际释放与 <code>companions</code> 对象关联的内存或资源，则当前定义不正确。它应该调用内存管理函数或执行其他必要的清理任务。</p>
</li>
<li><p>编译器警告被视为错误: <code>-Werror=unused-value</code> 标志已启用，它将警告视为错误。即使宏使用本身可能不是关键问题，这也可能导致编译失败。</p>
</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><h5 id="修复-SHELL-FREE-定义"><a href="#修复-SHELL-FREE-定义" class="headerlink" title="修复 SHELL_FREE 定义:"></a>修复 SHELL_FREE 定义:</h5><ol>
<li>如果 <code>companions</code> 需要内存分配，请更新 <code>shell_cfg.h</code> 中的 SHELL_FREE 宏以调用适当的内存管理函数，例如 <code>free()</code>。</li>
<li>如果 <code>companions</code> 不需要内存管理，请从 <code>shell_companion.c</code> 中的第 57 行删除 <code>SHELL_FREE</code> 调用；或者将<code>shell_cfg.h</code> 中的第 36 行 <code>SHELL_USING_COMPANION</code> 的宏定义改为 0。</li>
</ol>
<h5 id="禁用-Werror-unused-value-如果适用"><a href="#禁用-Werror-unused-value-如果适用" class="headerlink" title="禁用 -Werror&#x3D;unused-value (如果适用):"></a>禁用 -Werror&#x3D;unused-value (如果适用):</h5><p>如果您希望将未使用的值警告视为警告而不是错误，您可以暂时在编译期间禁用 <code>-Werror=unused-value</code> 标志。但是，通常建议修复底层问题以避免潜在的内存泄漏或资源管理问题。</p>
<h5 id="其他提示"><a href="#其他提示" class="headerlink" title="其他提示:"></a>其他提示:</h5><ol>
<li>提供有关您的项目更多信息，例如具体的 ESP-IDF 版本、涉及的组件以及 <code>SHELL_FREE</code> 宏的用途。这将有助于了解根本原因并提供更定制的指导。</li>
<li>分享 <code>shell_cfg.h</code> 头文件和 <code>shell_companion.c</code> 文件的相关部分，以便分析代码结构和上下文。<br>考虑使用调试器逐步执行代码并检查 <code>companions</code> 在 <code>SHELL_FREE</code> 调用之前和之后的 值，以了解其使用情况和潜在的内存管理问题。</li>
<li>通过遵循这些步骤并提供更多信息，我可以帮助您有效地解决编译错误并确保您的 ESP-IDF 项目成功构建。</li>
</ol>
<h4 id="配置shell优先级"><a href="#配置shell优先级" class="headerlink" title="配置shell优先级"></a>配置shell优先级</h4><p>将shell的freertos优先级设置为 <code>tskIDLE_PRIORITY</code>，为0级，跟空闲函数优先级一样，所有其他优先级任务执行完后才会执行 <code>tskIDLE_PRIORITY</code>优先级任务。</p>
<h4 id="源代码例程"><a href="#源代码例程" class="headerlink" title="源代码例程"></a>源代码例程</h4><p><a href="git@github.com:XUAN9527/components_demo.git">ESP32移植letter_shell组件例程</a></p>
]]></content>
      <categories>
        <category>ESP32解决方案</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32开发环境搭建</title>
    <url>/2024/02/19/ESP32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p><a href="https://espressif-docs.readthedocs-hosted.com/projects/esp-adf/zh-cn/latest/get-started/index.html#quick-start">ESP-ADF快速上手连接</a><br><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32/get-started/linux-macos-setup.html#get-started-linux-macos-first-steps">ESP-IDF快速上手连接</a></p>
<h3 id="获取ESP-ADF"><a href="#获取ESP-ADF" class="headerlink" title="获取ESP-ADF"></a>获取ESP-ADF</h3><p>打开Linux or macOS终端,新建搭建环境所需文件夹。</p>
<pre><code>mkdir ~/esp
cd ~/esp
</code></pre>
<p>编译 ESP-IDF 需要以下软件包。请根据使用的 Linux 发行版本，选择合适的安装：<br>Ubuntu 和 Debian:</p>
<pre><code>sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0
</code></pre>
<p>CentOS 7 &amp; 8:</p>
<pre><code>sudo yum -y update &amp;&amp; sudo yum install git wget flex bison gperf python3 python3-setuptools cmake ninja-build ccache dfu-util libusbx
</code></pre>
<p>Arch:</p>
<pre><code>sudo pacman -S --needed gcc git make flex bison gperf python cmake ninja ccache dfu-util libusb
</code></pre>
<p>克隆最新版ESP-ADF：</p>
<pre><code>git clone --recursive https://github.com/espressif/esp-adf.git
</code></pre>
<p>若克隆失败，尝试以下指令：</p>
<pre><code>git clone --recursive git@github.com:espressif/esp-adf.git
</code></pre>
<p>若子模块拉取失败，尝试手动逐个拉取子模块：</p>
<pre><code>cd ~/esp/esp-adf/components
git clone git@github.com:espressif/esp-adf-libs.git

cd ~/esp/esp-adf/components
git clone git@github.com:espressif/esp-sr.git

cd ~/esp/esp-adf
git clone git@github.com:espressif/esp-idf.git
</code></pre>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>按自己实际路径，可按自己喜好设置，也可不配置，手动敲指令也可。</p>
<p><code>vi ~/.bashrc</code><br>在后面加上以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启ESP32编译环境</span></span><br><span class="line"><span class="built_in">alias</span> get-idf=<span class="string">&#x27;. $HOME/esp/esp-adf/esp-idf/export.sh&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> get-adf=<span class="string">&#x27;. $HOME/esp/esp-adf/export.sh&#x27;</span></span><br><span class="line"><span class="comment">#打开本地文件夹（wsl）</span></span><br><span class="line"><span class="built_in">alias</span> open-file=<span class="string">&#x27;explorer.exe .&#x27;</span></span><br><span class="line"><span class="comment">#烧录到设备，并打开监视器，/dev/ttyS15为USB挂载端口，需测试后填写，115200为监视器波特率，与设备UART0波特率对应</span></span><br><span class="line"><span class="built_in">alias</span> esp-download=<span class="string">&#x27;idf.py -p /dev/ttyS15 -b 115200 flash monitor&#x27;</span></span><br><span class="line"><span class="built_in">export</span> PATH=/home/qx_song/esp/esp-adf/esp-idf/tools:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> IDF_PATH=/home/qx_song/esp/esp-adf/esp-idf</span><br><span class="line"><span class="built_in">export</span> ADF_PATH=/home/qx_song/esp/esp-adf</span><br></pre></td></tr></table></figure>
<p>保存退出 <code>:wq</code></p>
<h3 id="设置工具"><a href="#设置工具" class="headerlink" title="设置工具"></a>设置工具</h3><p>除了 ESP-IDF 本身，还需要为支持 ESP32 的项目安装 ESP-IDF 使用的各种工具，比如编译器、调试器、Python 包等。</p>
<pre><code>cd ~/esp/esp-adf/esp-idf
</code></pre>
<p>安装esp32，esp32s2工具，运行以下指令：（按需求安装）</p>
<pre><code>./install.sh esp32,esp32s2
</code></pre>
<p>若需要安装所有工具，运行以下指令：</p>
<pre><code>./install.sh all
</code></pre>
<p>以下为ESP-IDF编译所需环境，请在需要运行ESP-IDF的终端窗口运行以下命令：</p>
<pre><code>. $HOME/esp/esp-adf/esp-idf/export.sh   
</code></pre>
<p>或者使用快捷指令：</p>
<pre><code>get-idf
</code></pre>
<h2 id="ESP32工程示例"><a href="#ESP32工程示例" class="headerlink" title="ESP32工程示例"></a>ESP32工程示例</h2><h3 id="开始创建工程"><a href="#开始创建工程" class="headerlink" title="开始创建工程"></a>开始创建工程</h3><p>现在，可以准备开发 ESP32 应用程序了。<br>从 ESP-IDF 中 examples 目录下的 <code>get-started/hello_world</code> 工程开始，将 <code>get-started/hello_world</code> 工程复制至本地的 ~&#x2F;esp 目录下：</p>
<pre><code>cd ~/esp
get-idf
cp -r $IDF_PATH/examples/get-started/hello_world .
</code></pre>
<h3 id="配置工程"><a href="#配置工程" class="headerlink" title="配置工程"></a>配置工程</h3><pre><code>cd ~/esp/hello_world
idf.py set-target esp32
</code></pre>
<p>由于ESP32是单核，默认配置是双核模式，需要配置参数：</p>
<pre><code>idf.py menuconfig
Component config -&gt; FreeRTOS -&gt;  [*]Run FreeRTOS only on first core
</code></pre>
<p>保存退出</p>
<h3 id="编译工程"><a href="#编译工程" class="headerlink" title="编译工程"></a>编译工程</h3><pre><code>idf.py build
</code></pre>
<h3 id="烧录工程"><a href="#烧录工程" class="headerlink" title="烧录工程"></a>烧录工程</h3><pre><code>idf.py -p PORT flash
</code></pre>
<p>请将 PORT 替换为 ESP32 开发板的串口名称。如果 PORT 未经定义，<code>idf.py</code> 将尝试使用可用的串口自动连接。</p>
<h3 id="合并执行构建、烧录和监视过程："><a href="#合并执行构建、烧录和监视过程：" class="headerlink" title="合并执行构建、烧录和监视过程："></a>合并执行构建、烧录和监视过程：</h3><pre><code>idf.py -p PORT [-b BAUD] flash monitor
</code></pre>
<p>注：[-b BAUD] 和 monitor 配合使用，BAUD为程序中UART0的波特率	</p>
<pre><code>idf.py -p /dev/ttyS15 -b  115200  flash monitor	
idf.py -p [挂载端口]   -b [波特率] flash monitor
</code></pre>
<h3 id="擦除flash"><a href="#擦除flash" class="headerlink" title="擦除flash"></a>擦除flash</h3><pre><code>idf.py -p PORT erase-flash
</code></pre>
<p>若存在需要擦除的 OTA 数据，请运行以下命令：</p>
<pre><code>idf.py -p PORT erase-otadata
</code></pre>
<h3 id="挂载端口"><a href="#挂载端口" class="headerlink" title="挂载端口"></a>挂载端口</h3><h4 id="windows-子系统-wsl"><a href="#windows-子系统-wsl" class="headerlink" title="windows 子系统 wsl"></a>windows 子系统 wsl</h4><p>输入烧录指令：</p>
<pre><code>idf.py flash
</code></pre>
<p>观察终端设备是挂载在哪个端口上，有ERROR忽略，选择端口例如 <code>/dev/ttyS15</code>，程序中<code>UART0</code>的波特率115200，下次就可以直接输此端口就可以烧录啦。</p>
<pre><code>idf.py -p /dev/ttyS15 -b 115200 flash monitor	
</code></pre>
<p>如果 ESP-IDF 监视器在烧录后很快发生错误，或打印信息全是乱码（如下），很有可能是因为开发板采用了 26 MHz 晶振，而 ESP-IDF 默认支持大多数开发板使用的 40 MHz 晶振。</p>
<pre><code>x���ff�f�����`�~�~���f���x��f�f�����ff��`���f����`��~x������ff�f�����`�~�~�f����f����f`���x��f�f�����ff��`���f
</code></pre>
<p>此时，可以：<br>1、退出监视器。<br>2、返回 idf.py menuconfig。<br>3、进入 Component config –&gt; Hardware Settings –&gt; Main XTAL Config –&gt; Main XTAL frequency 进行配置，将 CONFIG_XTAL_FREQ_SEL 设置为 26 MHz。<br>4、重新编译和烧录应用程序。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>启动终端ESP32编译只需要进行以下步骤：</p>
<pre><code>. $HOME/esp/esp-adf/esp-idf/export.sh	//开启编译环境
idf.py set-target esp32			//首次搭建项目时配置
idf.py menuconfig   			//选择需要的配置
idf.py build
idf.py flash
</code></pre>
<p>快捷方式：</p>
<pre><code>get-idf
idf.py set-target esp32
idf.py menuconfig
idf.py build
esp-download
</code></pre>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>环境搭建</category>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C调试记录</title>
    <url>/2024/03/01/I2C%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="I2C基本原理介绍"><a href="#I2C基本原理介绍" class="headerlink" title="I2C基本原理介绍"></a>I2C基本原理介绍</h2><h3 id="时序介绍"><a href="#时序介绍" class="headerlink" title="时序介绍"></a>时序介绍</h3><p>参考Vishay的i2c时序图：</p>
<p><img src="/../pictures/i2c%E6%97%B6%E5%BA%8F%E5%9B%BE1.png" alt="i2c时序图1"><br><img src="/../pictures/i2c%E6%97%B6%E5%BA%8F%E5%9B%BE2.png" alt="i2c时序图2"></p>
<h3 id="代码实现详解"><a href="#代码实现详解" class="headerlink" title="代码实现详解"></a>代码实现详解</h3><p>I2C协议实现有硬件I2C和软件I2C之分，这里只讲解软件I2C实现的版本。一下列出主要结构体和初始化函数。</p>
<h4 id="I2C协议初始化"><a href="#I2C协议初始化" class="headerlink" title="I2C协议初始化"></a>I2C协议初始化</h4><p>I2C协议的scl和sda配置为开漏输出,需要外部上拉（一般为10K电阻）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define i2c_pin_mode(pin,mode)		drv_pin_mode(pin,mode)</span></span><br><span class="line"><span class="comment">#define i2c_pin_write(pin,level) 	drv_pin_write(pin,level)</span></span><br><span class="line"><span class="comment">#define i2c_pin_read(pin) 		drv_pin_read(pin)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DRV_I2C_WR                      0x00</span></span><br><span class="line"><span class="comment">#define DRV_I2C_RD                      (1u &lt;&lt; 0)</span></span><br><span class="line"><span class="comment">#define DRV_I2C_ADDR_10BIT              (1u &lt;&lt; 2)  /* this is a ten bit chip address */</span></span><br><span class="line"><span class="comment">#define DRV_I2C_NO_START                (1u &lt;&lt; 4)</span></span><br><span class="line"><span class="comment">#define DRV_I2C_IGNORE_NACK             (1u &lt;&lt; 5)</span></span><br><span class="line"><span class="comment">#define DRV_I2C_NO_READ_ACK             (1u &lt;&lt; 6)  /* when I2C reading, we do not ACK */</span></span><br><span class="line"><span class="comment">#define DRV_I2C_NO_STOP                 (1u &lt;&lt; 7)</span></span><br><span class="line"></span><br><span class="line">typedef enum&#123;</span><br><span class="line">	EI2C_DEV_1 = 1,</span><br><span class="line">	EI2C_DEV_2,</span><br><span class="line">	EI2C_DEV_3</span><br><span class="line">&#125;EI2C_DEVICE;</span><br><span class="line"></span><br><span class="line">struct drv_soft_i2c_config</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t scl;</span><br><span class="line">	uint8_t sda;</span><br><span class="line">	uint8_t i2c_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct drv_i2c_msg</span><br><span class="line">&#123;</span><br><span class="line">    uint16_t addr;</span><br><span class="line">    uint16_t flags;</span><br><span class="line">    uint16_t len;</span><br><span class="line">	uint8_t reg_addr;</span><br><span class="line">    uint8_t  *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct drv_i2c_bit_ops</span><br><span class="line">&#123;</span><br><span class="line">    void *data;            /* private data <span class="keyword">for</span> lowlevel routines */</span><br><span class="line">    void (*set_sda)(void *data, int state);</span><br><span class="line">    void (*set_scl)(void *data, int state);</span><br><span class="line">    int (*get_sda)(void *data);</span><br><span class="line">    int (*get_scl)(void *data);</span><br><span class="line"></span><br><span class="line">    void (*udelay)(uint32_t us);</span><br><span class="line"></span><br><span class="line">    uint32_t delay_us;  /* scl and sda line delay */</span><br><span class="line">    uint32_t <span class="built_in">timeout</span>;   /* <span class="keyword">in</span> tick */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct drv_i2c_bus_device</span><br><span class="line">&#123;</span><br><span class="line">	struct drv_i2c_msg msg;</span><br><span class="line">	struct drv_i2c_bit_ops ops;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void drv_i2c_gpio_init(struct drv_soft_i2c_config *i2c)</span><br><span class="line">&#123;</span><br><span class="line">    struct drv_soft_i2c_config* cfg = i2c;</span><br><span class="line"></span><br><span class="line">    i2c_pin_mode(cfg-&gt;scl, I2C_PIN_MODE_OUTPUT_OD);	//PIN_MODE_OUTPUT</span><br><span class="line">    i2c_pin_mode(cfg-&gt;sda, I2C_PIN_MODE_OUTPUT_OD);</span><br><span class="line"></span><br><span class="line">    i2c_pin_write(cfg-&gt;scl, I2C_PIN_HIGH);</span><br><span class="line">    i2c_pin_write(cfg-&gt;sda, I2C_PIN_HIGH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int drv_hw_i2c_init(EI2C_DEVICE dev_e)</span><br><span class="line">&#123;</span><br><span class="line">	int size = sizeof(i2c_pin_config)/sizeof(struct drv_soft_i2c_config);</span><br><span class="line">	struct drv_i2c_bus_device *dev = get_i2c_device(dev_e);</span><br><span class="line">	uint8_t dev_num = (uint8_t)dev_e;</span><br><span class="line">	struct drv_soft_i2c_config *pin_cfg = NULL;</span><br><span class="line">	struct drv_i2c_bit_ops *ops = &amp;dev-&gt;ops;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;size;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i2c_pin_config[i].i2c_num == dev_num)</span><br><span class="line">		&#123;</span><br><span class="line">			pin_cfg = (struct drv_soft_i2c_config *)&amp;i2c_pin_config[i];</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pin_cfg == NULL)</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">    ops-&gt;data  = (void*)pin_cfg;</span><br><span class="line">    ops-&gt;set_sda  = n32_set_sda;</span><br><span class="line">    ops-&gt;set_scl  = n32_set_scl;</span><br><span class="line">    ops-&gt;get_sda  = n32_get_sda;</span><br><span class="line">    ops-&gt;get_scl  = n32_get_scl;</span><br><span class="line">    ops-&gt;udelay   = n32_udelay;</span><br><span class="line">    ops-&gt;delay_us = 1;</span><br><span class="line">    ops-&gt;<span class="built_in">timeout</span>  = 5;</span><br><span class="line">    </span><br><span class="line">    drv_i2c_gpio_init(pin_cfg);</span><br><span class="line">    drv_i2c_bus_unlock(pin_cfg);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int drv_i2c_bit_xfer(struct drv_i2c_bit_ops *bus,</span><br><span class="line">                 struct drv_i2c_msg msgs[],</span><br><span class="line">                 uint32_t num);</span><br><span class="line">struct drv_i2c_bus_device *get_i2c_device(EI2C_DEVICE dev_e);</span><br><span class="line">static uint64_t i2c_tick_get(void);</span><br><span class="line">int drv_hw_i2c_init(EI2C_DEVICE dev_e);</span><br><span class="line">int drv_i2c_send_data(EI2C_DEVICE dev_e,uint16_t addr,uint8_t reg_addr,uint8_t *buf,uint16_t len);</span><br><span class="line">int drv_i2c_recv_data(EI2C_DEVICE dev_e,uint16_t addr,uint8_t reg_addr,uint8_t *buf,uint16_t len);</span><br></pre></td></tr></table></figure>

<h2 id="实战开发问题分析"><a href="#实战开发问题分析" class="headerlink" title="实战开发问题分析"></a>实战开发问题分析</h2><p>实际开发过程中，同样的I2C驱动程序，在不同厂家芯片的使用上出现一些问题，导致部分厂家通信异常，导致数据接收不正确，以下进行分析对比，作证并解决问题。</p>
<h3 id="Vishay-和-亿光-接近传感器模块对比"><a href="#Vishay-和-亿光-接近传感器模块对比" class="headerlink" title="Vishay 和 亿光 接近传感器模块对比"></a>Vishay 和 亿光 接近传感器模块对比</h3><p>Vishay 使用VCNL3682S型号芯片，亿光 使用APM-16D24-U6E型号芯片，I2C协议对比。</p>
<h5 id="Vishay-："><a href="#Vishay-：" class="headerlink" title="Vishay ："></a>Vishay ：</h5><p><img src="/../pictures/Vishay%E5%86%99i2c%E5%8D%8F%E8%AE%AE.png" alt="Vishay写i2c协议"><br><img src="/../pictures/Vishay%E8%AF%BBi2c%E5%8D%8F%E8%AE%AE.png" alt="Vishay读i2c协议"></p>
<h5 id="亿光："><a href="#亿光：" class="headerlink" title="亿光："></a>亿光：</h5><p><img src="/../pictures/%E4%BA%BF%E5%85%89i2c%E5%8D%8F%E8%AE%AE.png" alt="亿光i2c协议"></p>
<h6 id="对比波形"><a href="#对比波形" class="headerlink" title="对比波形"></a>对比波形</h6><p>对比协议来看基本上是一致的，用JI2C工具测的i2c波形也基本上一致，但是我自己写的软件i2c驱动，Vishay可以正常使用，亿光读取的数据就有问题，用逻辑分析仪抓一波波形分析一下。</p>
<p>发现每次读完都会多恢复一个ack，而协议上读完最后一个字节需要恢复nack。</p>
<h6 id="修改了以下代码"><a href="#修改了以下代码" class="headerlink" title="修改了以下代码"></a>修改了以下代码</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static int i2c_send_ack_or_nack(struct drv_i2c_bit_ops *bus, int ack)</span><br><span class="line">&#123;</span><br><span class="line">    struct drv_i2c_bit_ops *ops = bus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ack)				//if(ack &gt;= 0) 改成 <span class="keyword">if</span>(ack)</span><br><span class="line">        SET_SDA(ops, 0);</span><br><span class="line">    i2c_delay(ops);</span><br><span class="line">    <span class="keyword">if</span> (SCL_H(ops) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">//        logVerbose(<span class="string">&quot;ACK or NACK timeout.&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> -2;</span><br><span class="line">    &#125;</span><br><span class="line">    SCL_L(ops);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>static int i2c_send_ack_or_nack(struct drv_i2c_bit_ops *bus, int ack)&#123;&#125;</code><br>函数主要处理响应回复。</p>
<pre><code>if(ack &gt;= 0)表示每次都会回复ack/nack
if(ack)表示除最后一次数据不回复，其他每次都会回复ack/nack
</code></pre>
]]></content>
      <categories>
        <category>硬件调试</category>
      </categories>
      <tags>
        <tag>逻辑分析仪</tag>
        <tag>接近传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机开发问题汇总</title>
    <url>/2024/01/31/MCU%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="内核复位（kernel-reset）"><a href="#内核复位（kernel-reset）" class="headerlink" title="内核复位（kernel reset）"></a>内核复位（kernel reset）</h2><h3 id="常见通用问题"><a href="#常见通用问题" class="headerlink" title="常见通用问题"></a>常见通用问题</h3><ul>
<li><strong>内核复位代码，如ADC：</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kernel_reset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __DSB();</span><br><span class="line">    __disable_irq();							<span class="comment">//close irq</span></span><br><span class="line">	drv_adc_deinit(EADC_DEV1,EDMA_CH6);			<span class="comment">//disable adc data</span></span><br><span class="line">    SCB-&gt;AIRCR = ((<span class="number">0x5FA</span> &lt;&lt; SCB_AIRCR_VECTKEY_Pos)      |</span><br><span class="line">                  (SCB-&gt;AIRCR &amp; SCB_AIRCR_PRIGROUP_Msk) |</span><br><span class="line">                   SCB_AIRCR_VECTRESET_Msk);</span><br><span class="line">    __DSB();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>板级初始化前先要重置状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DMA_DeInit(dma_chx);		<span class="comment">//DMA开启循环接收后会持续接收字节</span></span><br><span class="line">ADC_DeInit(adc_handler);</span><br></pre></td></tr></table></figure>
</li>
<li><p>ADC驱动初始化&#x2F;反初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">drv_adc_init</span><span class="params">(EADC_DEVICE adc_dev,EDMA_CHANNEL dma_ch)</span></span><br><span class="line">&#123;</span><br><span class="line">	drv_adc_configuration(adc_dev);</span><br><span class="line">	drv_dma_configuration(adc_dev,dma_ch);</span><br><span class="line">	drv_adc_enable(adc_dev,DISABLE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">drv_adc_deinit</span><span class="params">(EADC_DEVICE adc_dev,EDMA_CHANNEL dma_ch)</span></span><br><span class="line">&#123;</span><br><span class="line">	ADC_Module *adc_handler = drv_get_adc_device(adc_dev)-&gt;ADC_Handler;</span><br><span class="line">	DMA_ChannelType * dma_chx = drv_get_dma_channel(dma_ch);</span><br><span class="line">	</span><br><span class="line">	drv_adc_enable(adc_dev,DISABLE);</span><br><span class="line">	DMA_EnableChannel(dma_chx,DISABLE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<h3 id="n32g452rc内核复位问题"><a href="#n32g452rc内核复位问题" class="headerlink" title="n32g452rc内核复位问题"></a>n32g452rc内核复位问题</h3><h4 id="bootloader跳转到app"><a href="#bootloader跳转到app" class="headerlink" title="bootloader跳转到app"></a>bootloader跳转到app</h4><ul>
<li>栈大小改变后跳转成功：将ram空间数据uint16_t改为uint32_t。</li>
<li>堆大小改变后跳转成功：将队列申请长度20改为30。</li>
<li>代码大小变化后跳转失败：<ul>
<li>代码段变长，能跑进<code>system_init</code>,跑飞待查。</li>
<li>代码段变短，不能跑进<code>system_init</code>,跑飞待查。</li>
</ul>
</li>
</ul>
<br>

<h2 id="MCU复位后状态"><a href="#MCU复位后状态" class="headerlink" title="MCU复位后状态"></a>MCU复位后状态</h2><ul>
<li>复位期间和刚复位后,复用功能未开启,I&#x2F;O端口被配置成模拟功能模式(PCFGy[1:0]&#x3D;00b, PMODEy[1:0]&#x3D;00b)。<br></li>
<li>但有以下几个例外的信号：BOOT0、 NRST、 OSC_IN、 OSC_OUT 默认无 GPIO 功能：<ul>
<li>BOOT0 引脚默认输入下拉</li>
<li>NRST 上拉输入输出<br></li>
</ul>
</li>
<li>复位后，调试系统相关的引脚默认状态为启动 SWD-JTAG， JTAG 引脚被置于输入上拉或下拉模式：<ul>
<li>PA15:JTDI 置于输入上拉模式 </li>
<li>PA14:JTCK 置于输入下拉模式 </li>
<li>PA13:JTMS 置于输入上拉模式</li>
<li>PB4:NJTRST 置于输入上拉模式</li>
<li>PB3:JTD0 置于推挽输出无上下拉<br></li>
</ul>
</li>
<li>PD0 和 PD1<ul>
<li>PD0 和 PD1 在 80 及以上引脚封装默认为模拟模式</li>
<li>PD0 和 PD1 在 80 以下引脚封装复用到 OSC_IN&#x2F;OUT</li>
</ul>
</li>
<li>PC13、 PC14、 PC15：<ul>
<li>PC13～15 为备电域下的三个 IO， 备份域初次上电默认为模拟模式；<br></li>
</ul>
</li>
<li>PB2&#x2F;BOOT1：<ul>
<li>PB2&#x2F;BOOT1 默认处于下拉输入状态；<br></li>
</ul>
</li>
<li>BOOT0 默认输入下拉，参照下表， 若 BOOT 的引脚未连接，则默认选择 Flash 主存储区。</li>
</ul>
<p><img src="/../pictures/mcu%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E8%A1%A8.png" alt="mcu启动选项表"><br><br></p>
<h2 id="printf重定向"><a href="#printf重定向" class="headerlink" title="printf重定向"></a>printf重定向</h2><ul>
<li>MDK版本，勾选Use MicroLIB选项：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> is_lr_sent = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE* f)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (ch == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       is_lr_sent = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (!is_lr_sent)</span><br><span class="line">   	&#123;</span><br><span class="line">           USART_SendData(USART1, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">           <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET);</span><br><span class="line">   	&#125;</span><br><span class="line">   	is_lr_sent = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">   	is_lr_sent = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   USART_SendData(USART1, ch);</span><br><span class="line">   <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET);</span><br><span class="line">   <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>GCC版本</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _write(<span class="type">int</span> fd, <span class="type">char</span>* pBuffer, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        USART_SendData(USART1, pBuffer[i]);</span><br><span class="line">        <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="RT-THREAD调试问题"><a href="#RT-THREAD调试问题" class="headerlink" title="RT-THREAD调试问题"></a>RT-THREAD调试问题</h2><h3 id="串口通信异常"><a href="#串口通信异常" class="headerlink" title="串口通信异常"></a>串口通信异常</h3><ul>
<li>打开UART7接收为<code>DMA IDLE</code>中断，申请一个超时定时器，发送&#x2F;接受各一个任务，发送&#x2F;接受两个队列,以下是错误信息：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">psr: 0x60000000</span><br><span class="line">r00: 0x00000000</span><br><span class="line">r01: 0x20007978</span><br><span class="line">r02: 0x20007978</span><br><span class="line">r03: 0x00000000</span><br><span class="line">r04: 0x00000000</span><br><span class="line">r05: 0x00000000</span><br><span class="line">r06: 0x00000000</span><br><span class="line">r07: 0x20000920</span><br><span class="line">r08: 0x20005908</span><br><span class="line">r09: 0x20000568</span><br><span class="line">r10: 0xdeadbeef</span><br><span class="line">r11: 0xdeadbeef</span><br><span class="line">r12: 0x00000000</span><br><span class="line"> lr: 0x0801156f</span><br><span class="line"> pc: 0x00000000</span><br><span class="line">hard fault on thread: timer</span><br><span class="line"></span><br><span class="line">E [00:00:07,324] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue) assertion failed at <span class="keyword">function</span>:rt_mq_send_wait, line number:2026 </span><br><span class="line"></span><br><span class="line">E [00:00:00,659] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type(&amp;timer-&gt;parent) == RT_Object_Class_Timer) assertion failed at <span class="keyword">function</span>:rt_timer_control, line number:474 </span><br><span class="line"></span><br><span class="line">E [00:00:39,282] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread) assertion failed at function:rt_thread_resume, line number:<span class="number">760</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>问题定位到指针变量<code>p_srx_mq[0]</code>和<code>&amp;p_srx_mq[0]</code>的区别，代码如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define COMM_MAX_NUM     3</span></span><br><span class="line">static uint8_t *p_srx_mq[COMM_MAX_NUM];</span><br><span class="line">static struct comm_serial_mq srx_mq_data[COMM_MAX_NUM];</span><br><span class="line">static struct rt_timer comm_rx_stimer[COMM_MAX_NUM];</span><br><span class="line"></span><br><span class="line">static void comm_serial_recieve_data_deinit(uint8_t num)</span><br><span class="line">&#123;</span><br><span class="line">	srx_mq_data[num].size = 0;</span><br><span class="line">	p_srx_mq[num] = srx_mq_data[num].data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int usart_key_rx_indicate(ESERIAL_DEV serial_dev, uint16_t size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p_srx_mq[0] - srx_mq_data[0].data + size &gt; sizeof(srx_mq_data[0].data))</span><br><span class="line">	&#123;</span><br><span class="line">		comm_serial_recieve_data_deinit(0);</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	rt_timer_start(&amp;comm_rx_stimer[0]);                   // 启动定时器</span><br><span class="line">	drv_fifo_data_get(serial_dev, (uint8_t *)p_srx_mq[0], size);</span><br><span class="line">	logPrintln(<span class="string">&quot;test = [%p][%p][%p]&quot;</span>,p_srx_mq[0],&amp;p_srx_mq[0],srx_mq_data[0].data);</span><br><span class="line">	p_srx_mq[0] += size;</span><br><span class="line">	srx_mq_data[0].size += size;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针取址符-与取值-的区别"><a href="#指针取址符-与取值-的区别" class="headerlink" title="指针取址符&amp;与取值*的区别"></a>指针取址符&amp;与取值*的区别</h4><p><strong>1. 指针取址符(&amp;)</strong></p>
<pre><code>指针取址符 &amp; 用于获取一个变量的地址，并将该地址存储在一个指针变量中。
</code></pre>
<p><strong>具体来说:</strong></p>
<ul>
<li>&amp; 运算符位于变量名前面。</li>
<li>&amp; 运算符的返回值是一个指针，指向该变量的内存地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num; <span class="comment">// p 指向 num 的地址</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 取值符(*)</strong></p>
<pre><code>取值符 * 用于获取指针变量所指向的变量的值。
</code></pre>
<p><strong>具体来说:</strong></p>
<ul>
<li>运算符位于指针变量名前面。</li>
<li>运算符的返回值是该指针变量所指向变量的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num;</span><br><span class="line"><span class="type">int</span> value = *p;		<span class="comment">// 访问 num 的值</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>指针取址符 &amp; 用于获取变量的地址，并将该地址存储在一个指针变量中。</li>
<li>取值符 * 用于获取指针变量所指向的变量的值。</li>
</ul>
<p><strong>需要注意的是：</strong></p>
<ul>
<li>不能对不存在的变量进行取址。</li>
<li>**<code>不能对指针变量进行取址</code>**。</li>
<li>取址操作可能会产生空指针，需要进行空指针检查。</li>
</ul>
<h4 id="为什么不能对指针变量进行取址"><a href="#为什么不能对指针变量进行取址" class="headerlink" title="为什么不能对指针变量进行取址"></a>为什么不能对指针变量进行取址</h4><p><strong>1. 指针变量本身也是一个变量</strong></p>
<p>指针变量也是一个变量，它存储的是另一个变量的地址。与其他变量一样，**<code>指针变量也存在于内存中，并拥有自己的地址</code>**。</p>
<p><strong>2. 取址操作会产生无限循环</strong></p>
<p>**<code>如果对指针变量进行取址，那么就会得到该指针变量的地址</code>**。但是，该指针变量本身也是一个变量，所以其地址也是存储在另一个变量中的。如此循环往复，就会产生无限循环。</p>
<p><strong>3. 违背了指针的定义</strong></p>
<p>指针的定义是指向另一个变量的地址。如果对指针变量进行取址，那么就意味着指针指向了它自己的地址，这违背了指针的定义。</p>
<p><strong>4. 可能导致程序崩溃</strong></p>
<p>在大多数情况下，对指针变量进行取址会导致程序崩溃。这是因为程序会试图访问一个不存在的内存地址。<br><br></p>
<h2 id="TFT屏ST7735S调试问题"><a href="#TFT屏ST7735S调试问题" class="headerlink" title="TFT屏ST7735S调试问题"></a>TFT屏ST7735S调试问题</h2><h3 id="硬件-软件spi初始化"><a href="#硬件-软件spi初始化" class="headerlink" title="硬件&#x2F;软件spi初始化"></a>硬件&#x2F;软件spi初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HARDWARE_SPI_MODE 1	<span class="comment">//1：hardware；0：software</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_SCLK_Clr() GPIO_ResetBits(GPIOA, GPIO_PIN_5)	<span class="comment">//SCL=SCLK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_SCLK_Set() GPIO_SetBits(GPIOA, GPIO_PIN_5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_MOSI_Clr() GPIO_ResetBits(GPIOA, GPIO_PIN_7)		<span class="comment">//SDA=MOSI</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_MOSI_Set() GPIO_SetBits(GPIOA, GPIO_PIN_7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_RES_Clr()  GPIO_ResetBits(GPIOB, GPIO_PIN_0)		<span class="comment">//RES</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_RES_Set()  GPIO_SetBits(GPIOB, GPIO_PIN_0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_DC_Clr()   GPIO_ResetBits(GPIOB, GPIO_PIN_1)		<span class="comment">//DC</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_DC_Set()   GPIO_SetBits(GPIOB, GPIO_PIN_1)</span></span><br><span class="line"> 		     </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_CS_Clr()   GPIO_ResetBits(GPIOA, GPIO_PIN_4)		<span class="comment">//CS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_CS_Set()   GPIO_SetBits(GPIOA, GPIO_PIN_4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_BLK_Clr()											<span class="comment">//BLK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_BLK_Set()</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitType GPIO_InitStructure;</span><br><span class="line">	RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_GPIOA | RCC_APB2_PERIPH_GPIOB , ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HARDWARE_SPI_MODE</span></span><br><span class="line">	SPI_InitType SPI_InitStructure;</span><br><span class="line">	RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_SPI1 | RCC_APB2_PERIPH_AFIO, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct(&amp;GPIO_InitStructure);</span><br><span class="line">    GPIO_InitStructure.Pin        = GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7;</span><br><span class="line">    GPIO_InitStructure.GPIO_Alternate = GPIO_AF0_SPI1;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitPeripheral(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SPIy Config -------------------------------------------------------------*/</span></span><br><span class="line">    SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_TX;</span><br><span class="line">    SPI_InitStructure.SpiMode       = SPI_MODE_MASTER;</span><br><span class="line">    SPI_InitStructure.DataLen       = SPI_DATA_SIZE_8BITS;</span><br><span class="line">    SPI_InitStructure.CLKPOL        = SPI_CLKPOL_HIGH;</span><br><span class="line">    SPI_InitStructure.CLKPHA        = SPI_CLKPHA_FIRST_EDGE;</span><br><span class="line">    SPI_InitStructure.NSS           = SPI_NSS_HARD;</span><br><span class="line">    SPI_InitStructure.BaudRatePres  = SPI_BR_PRESCALER_2;</span><br><span class="line">    SPI_InitStructure.FirstBit      = SPI_FB_MSB;</span><br><span class="line">    SPI_InitStructure.CRCPoly       = <span class="number">7</span>;</span><br><span class="line">    SPI_Init(SPI1, &amp;SPI_InitStructure);</span><br><span class="line"></span><br><span class="line">	SPI_SSOutputEnable(SPI1, ENABLE);</span><br><span class="line">	SPI_EnableCalculateCrc(SPI1, DISABLE);</span><br><span class="line">    <span class="comment">/* Enable SPIy */</span></span><br><span class="line">    SPI_Enable(SPI1, ENABLE);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	GPIO_InitStruct(&amp;GPIO_InitStructure);</span><br><span class="line">	GPIO_InitStructure.Pin = GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitPeripheral(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(GPIOA, GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	GPIO_InitStruct(&amp;GPIO_InitStructure);</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1;</span><br><span class="line">	GPIO_InitPeripheral(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(GPIOB, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Writ_Bus</span><span class="params">(u8 dat)</span> </span><br><span class="line">&#123;	</span><br><span class="line">	LCD_CS_Clr();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HARDWARE_SPI_MODE</span></span><br><span class="line">	SPI_I2S_TransmitData(SPI1, dat);</span><br><span class="line">	<span class="keyword">while</span> (SPI_I2S_GetStatus(SPI1, SPI_I2S_TE_FLAG) == RESET); <span class="comment">//必须等到SPI数据发完，才能拉高CS片选，发下一次数据，否则数据会出错</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	u8 i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;			  </span><br><span class="line">		LCD_SCLK_Clr();</span><br><span class="line">		<span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		   LCD_MOSI_Set();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		   LCD_MOSI_Clr();</span><br><span class="line">		&#125;</span><br><span class="line">		LCD_SCLK_Set();</span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   LCD_CS_Set();	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_DATA8</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">	LCD_Writ_Bus(dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_DATA</span><span class="params">(u16 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">	LCD_Writ_Bus(dat&gt;&gt;<span class="number">8</span>);</span><br><span class="line">	LCD_Writ_Bus(dat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="Cortex-M系列内核字节对齐汇总"><a href="#Cortex-M系列内核字节对齐汇总" class="headerlink" title="Cortex-M系列内核字节对齐汇总"></a>Cortex-M系列内核字节对齐汇总</h2><ul>
<li><p>4字节对齐的含义就是变量地址对4求余数为0；8字节对齐就是地址对8求余等于0，依次类推，比如：如果让p去访问0x20000001， 0x20000002，0x20000003这都是不对齐访问。</p>
</li>
<li><p>对于<code>M3和M4</code>而言，可以直接访问非对齐地址（注意芯片要在这个地址有对应的内存空间), 因为<code>M3和M4</code>是支持的，而<code>M0/M0+/M1</code>是不支持的，不支持的内核芯片，只要非对齐访问就会触发硬件异常。</p>
</li>
</ul>
<p><strong>综上所述，我们只讨论Cortex-M3&#x2F;M4内核情况。</strong></p>
<h3 id="全局变量对齐问题"><a href="#全局变量对齐问题" class="headerlink" title="全局变量对齐问题"></a>全局变量对齐问题</h3><ul>
<li><code>uint8_t</code>定义变量地址要1字节对齐。</li>
<li><code>uint16_t</code>定义变量地址要2字节对齐。</li>
<li><code>uint32_t</code>定义变量地址要4字节对齐。</li>
<li><code>uint64_t</code>定义变量地址要8字节对齐。</li>
<li><code>指针变量</code>是4字节对齐。</li>
</ul>
<h3 id="结构体成员对齐问题"><a href="#结构体成员对齐问题" class="headerlink" title="结构体成员对齐问题"></a>结构体成员对齐问题</h3><h4 id="自然对界"><a href="#自然对界" class="headerlink" title="自然对界"></a>自然对界</h4><p><strong>例子1</strong>（分析结构各成员的默认字节对界条界条件和结构整体的默认字节对界条件）:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  <span class="type">char</span> x1; <span class="comment">// 成员x1为char型(其起始地址必须1字节对界)，其偏移地址为0 </span></span><br><span class="line">  <span class="type">char</span> x2; <span class="comment">// 成员x2为char型(其起始地址必须1字节对界，其偏移地址为1 </span></span><br><span class="line">  <span class="type">float</span> x3; <span class="comment">// 成员x3为float型(其起始地址必须4字节对界)，编译器在x2和x3之间填充了两个空字节，其偏移地址为4 </span></span><br><span class="line">  <span class="type">char</span> x4; <span class="comment">// 成员x4为char型(其起始地址必须1字节对界)，其偏移地址为8 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Test结构体中，最大的成员为<code>float</code> x3，因此结构体的自然对界条件为4字节对齐。则结构体长度就为12字节，内存布局为<code>1100 1111 1000</code>。</p>
<br>

<h4 id="指令对齐"><a href="#指令对齐" class="headerlink" title="指令对齐"></a>指令对齐</h4><p><strong>1. 伪指令#pragma pack</strong></p>
<p>改变缺省的对界条件(指定对界)</p>
<ul>
<li>使用伪指令<code>#pragma pack (n)</code>，编译器将按照n个字节对齐。</li>
<li>使用伪指令<code>#pragma pack ()</code>，取消自定义字节对齐方式。<ul>
<li>数据成员对齐规则：结构(<code>struct</code>)(或联合(<code>union</code>))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照<code>#pragma pack</code>指定的数值和这个数据成员自身长度中，比较小的那个进行。</li>
<li>结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照<code>#pragma pack</code>指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</li>
</ul>
</li>
</ul>
<p>结合推断：当<code>#pragma pack</code>的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。因此，当使用伪指令<code>#pragma pack (2)</code>时，Test结构体的大小为8，内存布局为<code>1111 1110</code>。</p>
<ul>
<li>需要注意一点，当结构体中包含一个子结构体时，子结构中的成员按照#pragma pack指定的数值和子结构最大数据成员长度中，比较小的那个进行进行对齐。例子如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">short</span> a;</span><br><span class="line">  <span class="type">long</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  s1 d;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
<p><code>sizeof(s2)</code>的结果为24。S1的内存布局为<code>1100 1111</code>，S2的内存布局为<code>1000 1100 1111 0000 1111 1111</code>。</p>
<p><strong>例子2</strong>(按照2个字节对齐时)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> aa1; <span class="comment">//2个字节对齐 1111</span></span><br><span class="line">  <span class="type">char</span> bb1;<span class="comment">//1个字节对齐 1</span></span><br><span class="line">  <span class="type">short</span> cc1;<span class="comment">//2个字节对齐 011</span></span><br><span class="line">  <span class="type">char</span> dd1; <span class="comment">//1个字节对齐 1</span></span><br><span class="line">&#125; testlength1;</span><br><span class="line"><span class="type">int</span> length1 = <span class="keyword">sizeof</span>(testlength1); <span class="comment">//2个字节对齐，占用字节11 11 10 11 10,length = 10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> bb2;<span class="comment">//1个字节对齐 1</span></span><br><span class="line">  <span class="type">int</span> aa2; <span class="comment">//2个字节对齐 01111</span></span><br><span class="line">  <span class="type">short</span> cc2;<span class="comment">//2个字节对齐 11</span></span><br><span class="line">  <span class="type">char</span> dd2; <span class="comment">//1个字节对齐 1</span></span><br><span class="line">&#125; testlength2;</span><br><span class="line"><span class="type">int</span> length2 = <span class="keyword">sizeof</span>(testlength2); <span class="comment">//2个字节对齐，占用字节10 11 11 11 10,length = 10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> bb3; <span class="comment">//1个字节对齐 1</span></span><br><span class="line">  <span class="type">char</span> dd3; <span class="comment">//1个字节对齐 1</span></span><br><span class="line">  <span class="type">int</span> aa3; <span class="comment">//2个字节对齐 11 11</span></span><br><span class="line">  <span class="type">short</span> cc23<span class="comment">//2个字节对齐 11</span></span><br><span class="line"> </span><br><span class="line">&#125; testlength3;</span><br><span class="line"><span class="type">int</span> length3 = <span class="keyword">sizeof</span>(testlength3); <span class="comment">//2个字节对齐，占用字节11 11 11 11,length = 8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> bb4; <span class="comment">//1个字节对齐 1</span></span><br><span class="line">  <span class="type">char</span> dd4; <span class="comment">//1个字节对齐 1</span></span><br><span class="line">  <span class="type">short</span> cc4;<span class="comment">//2个字节对齐 11</span></span><br><span class="line">  <span class="type">int</span> aa4; <span class="comment">//2个字节对齐 11 11</span></span><br><span class="line">&#125; testlength4;</span><br><span class="line"><span class="type">int</span> length4 = <span class="keyword">sizeof</span>(testlength4); <span class="comment">//2个字节对齐，占用字节11 11 11 11,length = 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;length1 = %d.\n&quot;</span>,length1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;length2 = %d.\n&quot;</span>,length2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;length3 = %d.\n&quot;</span>,length3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;length4 = %d.\n&quot;</span>,length4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. <strong>attribute</strong>((<strong>aligned</strong>(n)))</strong></p>
<p><code>__attribute__</code>是GCC里的编译参数，用法有很多种，感兴趣可以阅读一下gcc的相关文档。这里说一下<code>__attribute__</code>对变量和结构体对齐的影响。这里的影响大概分为两个方面，对齐和本身占用的字节数的大小，即sizeof（变量）的值。</p>
<ul>
<li><code>int a attribute((aligned(64))) = 10;</code></li>
</ul>
<p>这个修饰的影响主要是对齐，所谓对齐是存储为值的起始地址。变量a的地址&amp;a,本来是4字节对齐，变成了64字节对齐（有的环境对最大对齐数值有限制）。64字节对齐就是<code>&amp;a</code>的最后6位为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">4</span>; 		<span class="comment">//a 占用的字节数还是4个字节</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>typedef int myint attribute((aligned(64))) ;</code></li>
</ul>
<p>这样说明myint 声明的变量按照64字节对齐，大小是4字节，这样就会有一个问题，这个变量不能定义数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">myint myarray[<span class="number">2</span>]; 	<span class="comment">//这样定义编译器会报err</span></span><br></pre></td></tr></table></figure>
<p>报错的原因是数组的存储在内存中是连续的，而myint只有4字节确要64字节对齐，这样对齐和连续就不能同时保证，就会报错。</p>
<p><strong>例子1</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_tag</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">&#125; ST1;</span><br><span class="line">ST1 myst；</span><br></pre></td></tr></table></figure>

<p>在没有对齐的情况下：<code>sizeof(ST1) = sizeof(myst) = 8;</code><br>结构体对齐的原则可以总结为：</p>
<ul>
<li>结构体起始地址(&amp;myst)按最大变量字节数(sizeof(int))对齐；</li>
<li>结构体内每个变量按照自身字节数对齐；</li>
<li>结构体的大小<code>(sizeof(myst))</code>是最大变量字节数的整数倍（8&#x2F;4&#x3D;2）；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_tag</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">&#125;  __attribute__((__aligned__(<span class="number">64</span>))) ST1;</span><br><span class="line">ST1 myst；</span><br><span class="line"><span class="keyword">sizeof</span>(ST1) = <span class="keyword">sizeof</span>(myst) = <span class="number">64</span>; </span><br></pre></td></tr></table></figure>
<p>对比：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_tag</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">&#125;  ST1 __attribute__((__aligned__(<span class="number">64</span>)));</span><br><span class="line">ST1 myst；</span><br><span class="line"><span class="keyword">sizeof</span>(ST1) = <span class="keyword">sizeof</span>(myst) = <span class="number">8</span> ;</span><br></pre></td></tr></table></figure>

<p>这第二种情况可以理解为<code>__attribute__((aligned(64)))</code>作用于变量ST1 ，只影响对齐，不影响结构的大小。</p>
<p><strong>例子2</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>))</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> comm_version;</span><br><span class="line">    <span class="type">uint8_t</span> comm_lenth;</span><br><span class="line">    <span class="type">uint8_t</span> device_fw_verion[];</span><br><span class="line">&#125;ble_resp_device_info_desc;</span><br></pre></td></tr></table></figure>
<p><code>__attribute__((packed))</code>是GCC编译器提供的一个属性,<code>__attribute__((packed))</code>其中的成员变量不会进行对齐。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>MCU</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown小贴士</title>
    <url>/2024/02/19/Markdown%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
    <content><![CDATA[<h3 id="Markdown-的基本语法"><a href="#Markdown-的基本语法" class="headerlink" title="Markdown 的基本语法"></a>Markdown 的基本语法</h3><p>Markdown 的语法非常简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。以下是一些常用的 Markdown 标记符号：</p>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题	
</code></pre>
<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><pre><code>普通文本
**加粗文本**
*斜体文本*
**~删除线文本~**
</code></pre>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><pre><code>* 无序列表
1. 有序列表
    * 嵌套列表
</code></pre>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><pre><code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h4 id="文本中代码高亮"><a href="#文本中代码高亮" class="headerlink" title="文本中代码高亮"></a>文本中代码高亮</h4><pre><code>使用`printf(&quot;Hello, world!\n&quot;);`函数进行打印
</code></pre>
<p>效果：使用<code>printf(&quot;Hello, world!\n&quot;);</code>函数进行打印</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><strong>链接文本</strong>: <a href="https://www.example.com/">https://www.example.com</a></p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><pre><code>网络地址: ![这是一张示例图片](https://www.example.com/example.png)
本地文件路径：![这是一张示例图片](../pictures/这是一张示例图片.png)
图片链接跳转: ![这是一张示例图片](example.png) &#123;link=https://www.example.com/&#125;
图片标题: ![这是一张示例图片](example.png) &#123;title=这是一张示例图片&#125;
图片居中: ![这是一张示例图片](example.png) &#123;align=center&#125;

示例：
![这是一张示例图片](example.png)
![这是一张 200x100 像素的图片](example.png) &#123;width=200 height=100&#125;
![这是一张居中的图片](example.png) &#123;align=center&#125;
![点击图片跳转到 https://www.example.com/](example.png) &#123;link=https://www.example.com/&#125;
![这是一张示例图片](example.png) &#123;title=这是一张示例图片&#125;
</code></pre>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><table>
<thead>
<tr>
<th>头部1</th>
<th>头部2</th>
<th>头部3</th>
</tr>
</thead>
<tbody><tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
<tr>
<td>内容4</td>
<td>内容5</td>
<td>内容6</td>
</tr>
</tbody></table>
<h3 id="Markdown-的应用"><a href="#Markdown-的应用" class="headerlink" title="Markdown 的应用"></a>Markdown 的应用</h3><pre><code>博客文章
技术文档
README 文件
演示文稿
电子书
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>Markdown 是一种易于学习和使用的标记语言，非常适合编写各种文档。如果您还没有使用过 Markdown，建议您尝试一下。
</code></pre>
<p>以下是 Markdown 官方教学网站：<br><a href="https://markdown.com.cn/basic-syntax/headings.html">Markdown 官方网站</a></p>
]]></content>
      <categories>
        <category>文本编辑工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>CmBacktrace移植</title>
    <url>/2024/04/19/CmBacktrace%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<h2 id="CmBacktrace简介"><a href="#CmBacktrace简介" class="headerlink" title="CmBacktrace简介"></a>CmBacktrace简介</h2><ul>
<li>支持断言（assert）和故障（Hard Fault）</li>
<li>故障原因自动诊断</li>
<li>输出错误现场的 函数调用栈</li>
<li>适配 Cortex-M0&#x2F;M3&#x2F;M4&#x2F;M7 MCU；</li>
<li>支持 IAR、KEIL、GCC 编译器；</li>
</ul>
<h2 id="移植步骤"><a href="#移植步骤" class="headerlink" title="移植步骤"></a>移植步骤</h2><p><strong>1. 下载源码</strong></p>
<p><strong>官方源码地址</strong> : <a href="https://github.com/armink/CmBacktrace">https://github.com/armink/CmBacktrace</a><br><strong>示例项目地址</strong> : <a href="https://github.com/XUAN9527/cmbacktrace-demo">https://github.com/XUAN9527/cmbacktrace-demo</a></p>
<p><strong>2. copy源码文件</strong></p>
<p><img src="/../pictures/cmbacktrace%E7%9B%AE%E5%BD%95.png" alt="cmbacktrace目录"></p>
<ul>
<li>添加头文件<code>cm_backtrace.h</code> <code>cmb_cfg.h</code> <code>cmb_def.h</code></li>
<li>添加源文件<code>cm_backtrace.c</code></li>
<li>添加demos文件 <code>demos/non_os/stm32f10x/app/src/fault_test.c</code></li>
<li>修改添加<code>fault_handler/gcc/cmb_fault.S</code>为<code>fault_handler/gcc/cmb_fault.s</code></li>
</ul>
<p><strong>2.1 添加修改makefile：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ASM_SOURCES =  \</span><br><span class="line">CMSIS/device/startup/startup_n32l40x_gcc.s \</span><br><span class="line">components/cm_backtrace/fault_handler/gcc/cmb_fault.s #添加这一行</span><br></pre></td></tr></table></figure>

<p><strong>2.2 添加printf重定向：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _write(<span class="type">int</span> fd, <span class="type">char</span>* pBuffer, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> drv_serial_dma_write(ESERIAL_1, pBuffer, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.3 修改文件：</strong></p>
<ul>
<li><p><code>cmb_cfg.h</code>文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CMB_CFG_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CMB_CFG_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* print line, must config by user */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cmb_println(...)  printf(__VA_ARGS__);printf(<span class="string">&quot;\r\n&quot;</span>) <span class="comment">/* e.g., printf(__VA_ARGS__);printf(&quot;\r\n&quot;)  or  SEGGER_RTT_printf(0, __VA_ARGS__);SEGGER_RTT_WriteString(0, &quot;\r\n&quot;)  */</span></span></span><br><span class="line"><span class="comment">/* enable bare metal(no OS) platform */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_USING_BARE_METAL_PLATFORM</span></span><br><span class="line"><span class="comment">/* enable OS platform */</span></span><br><span class="line"><span class="comment">/* #define CMB_USING_OS_PLATFORM */</span></span><br><span class="line"><span class="comment">/* OS platform type, must config when CMB_USING_OS_PLATFORM is enable */</span></span><br><span class="line"><span class="comment">/* #define CMB_OS_PLATFORM_TYPE           CMB_OS_PLATFORM_RTT or CMB_OS_PLATFORM_UCOSII or CMB_OS_PLATFORM_UCOSIII or CMB_OS_PLATFORM_FREERTOS or CMB_OS_PLATFORM_RTX5 */</span></span><br><span class="line"><span class="comment">/* cpu platform type, must config by user */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_CPU_PLATFORM_TYPE   CMB_CPU_ARM_CORTEX_M4       <span class="comment">/* CMB_CPU_ARM_CORTEX_M0 or CMB_CPU_ARM_CORTEX_M3 or CMB_CPU_ARM_CORTEX_M4 or CMB_CPU_ARM_CORTEX_M7 */</span></span></span><br><span class="line"><span class="comment">/* enable dump stack information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_USING_DUMP_STACK_INFO</span></span><br><span class="line"><span class="comment">/* language of print information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_PRINT_LANGUAGE    CMB_PRINT_LANGUAGE_ENGLISH        <span class="comment">/* CMB_PRINT_LANGUAGE_ENGLISH(default) or CMB_PRINT_LANGUAGE_CHINESE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _CMB_CFG_H_ */</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改n32l40x_flash.ld链接文件</p>
<ul>
<li>text段开始之前添加 <code>_stext = .;</code> 下面为例程：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Define output sections */</span></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The startup code goes first into FLASH */</span></span><br><span class="line">  .isr_vector :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    KEEP(*(.isr_vector)) <span class="comment">/* Startup code */</span></span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  _stext = .;				<span class="meta"># text段开始之前添加</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The program code and other data goes into FLASH */</span></span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    *(.text)           <span class="comment">/* .text sections (code) */</span></span><br><span class="line">    *(.text*)          <span class="comment">/* .text* sections (code) */</span></span><br><span class="line">    *(.glue_7)         <span class="comment">/* glue arm to thumb code */</span></span><br><span class="line">    *(.glue_7t)        <span class="comment">/* glue thumb to arm code */</span></span><br><span class="line">    *(.eh_frame)</span><br><span class="line"></span><br><span class="line">    KEEP (*(.init))</span><br><span class="line">    KEEP (*(.fini))</span><br></pre></td></tr></table></figure>

<ul>
<li>text段开始之前添加 <code>_sstack = .;</code> 下面为例程：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.bss :</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* This is used by the startup in order to initialize the .bss secion */</span></span><br><span class="line">  _sbss = .;         <span class="comment">/* define a global symbol at bss start */</span></span><br><span class="line">  __bss_start__ = _sbss;</span><br><span class="line">  *(.bss)</span><br><span class="line">  *(.bss*)</span><br><span class="line">  *(COMMON)</span><br><span class="line"></span><br><span class="line">  . = ALIGN(<span class="number">4</span>);</span><br><span class="line">  _ebss = .;         <span class="comment">/* define a global symbol at bss end */</span></span><br><span class="line">  __bss_end__ = _ebss;</span><br><span class="line">&#125; &gt;RAM</span><br><span class="line"></span><br><span class="line">_sstack = .;				<span class="meta"># stack段开始之前添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* User_heap_stack section, used to check that there is enough RAM left */</span></span><br><span class="line">._user_heap_stack :</span><br><span class="line">&#123;</span><br><span class="line">  . = ALIGN(<span class="number">4</span>);</span><br><span class="line">  PROVIDE ( end = . );</span><br><span class="line">  PROVIDE ( _end = . );</span><br><span class="line">  . = . + _Min_Heap_Size;</span><br><span class="line">  . = . + _Min_Stack_Size;</span><br><span class="line">  _estack = .;        <span class="comment">/* end of RAM */</span></span><br><span class="line">  . = ALIGN(<span class="number">4</span>);</span><br><span class="line">&#125; &gt;RAM</span><br></pre></td></tr></table></figure>

<p><strong>2.4 main函数例程：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cm_backtrace.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HARDWARE_VERSION               <span class="string">&quot;V1.0.0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOFTWARE_VERSION               <span class="string">&quot;V0.1.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fault_test_by_unalign</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fault_test_by_div0</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    main_system_init();</span><br><span class="line">	cm_backtrace_init(<span class="string">&quot;CmBacktrace&quot;</span>, HARDWARE_VERSION, SOFTWARE_VERSION);</span><br><span class="line">	</span><br><span class="line">	fault_test_by_unalign();</span><br><span class="line">    fault_test_by_div0();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译出错后代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Firmware name: CmBacktrace, hardware version: V1<span class="number">.0</span><span class="number">.0</span>, software version: V0<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">Fault on interrupt or bare <span class="title function_">metal</span><span class="params">(no OS)</span> environment</span><br><span class="line">===== Thread <span class="built_in">stack</span> information =====</span><br><span class="line">  addr: <span class="number">20004</span>ec8    data: <span class="number">5</span>a6d79ca</span><br><span class="line">  addr: <span class="number">20004</span>ecc    data: f758b4b7</span><br><span class="line">  addr: <span class="number">20004</span>ed0    data: <span class="number">94</span>cfc3fd</span><br><span class="line">  addr: <span class="number">20004</span>ed4    data: a8ccaa51</span><br><span class="line">  addr: <span class="number">20004</span>ed8    data: <span class="number">61049</span>ca6</span><br><span class="line">  addr: <span class="number">20004</span>edc    data: e4e1b169</span><br><span class="line">  addr: <span class="number">20004</span>ee0    data: b48e100d</span><br><span class="line">  addr: <span class="number">20004</span>ee4    data: c44eb7ea</span><br><span class="line">  addr: <span class="number">20004</span>ee8    data: <span class="number">23</span>d4e51e</span><br><span class="line">  addr: <span class="number">20004</span>eec    data: <span class="number">8527b</span>7c0</span><br><span class="line">  addr: <span class="number">20004</span>ef0    data: fd9d41f7</span><br><span class="line">  addr: <span class="number">20004</span>ef4    data: f539e421</span><br><span class="line">  addr: <span class="number">20004</span>ef8    data: <span class="number">4</span>ad52963</span><br><span class="line">  addr: <span class="number">20004</span>efc    data: <span class="number">4587b</span>423</span><br><span class="line">  addr: <span class="number">20004f</span>00    data: e000ed00</span><br><span class="line">  addr: <span class="number">20004f</span>04    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>08    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>0c    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>10    data: <span class="number">200022</span>cc</span><br><span class="line">  addr: <span class="number">20004f</span>14    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>18    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>1c    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>20    data: <span class="number">00000000</span></span><br><span class="line">  addr: <span class="number">20004f</span>24    data: <span class="number">08009093</span></span><br><span class="line">====================================</span><br><span class="line">=================== Registers information ====================</span><br><span class="line">  R0 : <span class="number">20002</span>ee9  R1 : <span class="number">20002e4</span>c  R2 : e000ed14  R3 : <span class="number">2000253</span>c</span><br><span class="line">  R12: <span class="number">0000000</span>a  LR : <span class="number">0800</span>a3b3  PC : <span class="number">080154</span>c2  PSR: <span class="number">61000000</span></span><br><span class="line">==============================================================</span><br><span class="line">Usage fault is caused by attempts to execute an undefined instruction</span><br><span class="line">Show more call <span class="built_in">stack</span> info by run: addr2line -e CmBacktrace.elf -a -f <span class="number">080154</span>c2 <span class="number">0800</span>a3b2 <span class="number">08009092</span></span><br></pre></td></tr></table></figure>

<p><strong>转换为定位代码工具：</strong></p>
<ul>
<li><code>linux</code>环境下输入：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr2line -e app.elf -a -f <span class="number">080154</span>c2 <span class="number">0800</span>a3b2 <span class="number">08009092</span></span><br></pre></td></tr></table></figure>

<p>解释：<code>app.elf</code> 为你的工程编译文件。</p>
<p><strong>数据分析结果：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xuan@DESKTOP-A52B6V9:~/work/n5-mini-s-plus/code/app/build$ addr2line -e app.elf -a -f <span class="number">080154</span>c2 <span class="number">0800</span>a3b2 <span class="number">08009092</span></span><br><span class="line"><span class="number">0x080154c2</span></span><br><span class="line">fault_test_by_unalign</span><br><span class="line">/home/xuan/work/n5-mini-s-plus/code/app/components/cm_backtrace/fault_test.c:<span class="number">18</span></span><br><span class="line"><span class="number">0x0800a3b2</span></span><br><span class="line">main</span><br><span class="line">/home/xuan/work/n5-mini-s-plus/code/app/application/main.c:<span class="number">30</span></span><br><span class="line"><span class="number">0x08009092</span></span><br><span class="line">LoopFillZerobss</span><br><span class="line">/home/xuan/work/n5-mini-s-plus/code/app/CMSIS/device/startup/startup_n32l40x_gcc.s:<span class="number">113</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>错误追踪</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cortex-M</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下开发单片机</title>
    <url>/2024/03/28/Linux%E4%B8%8B%E5%BC%80%E5%8F%91%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="Ubuntu-Wsl环境搭建"><a href="#Ubuntu-Wsl环境搭建" class="headerlink" title="Ubuntu Wsl环境搭建"></a>Ubuntu Wsl环境搭建</h2><h3 id="Windows10系统安装子系统Wsl"><a href="#Windows10系统安装子系统Wsl" class="headerlink" title="Windows10系统安装子系统Wsl"></a>Windows10系统安装子系统Wsl</h3><p><strong>1. 通过 Microsoft Store 安装</strong></p>
<ul>
<li>打开 Microsoft Store。</li>
<li>搜索 “适用于 Linux 的 Windows 子系统”。</li>
<li>选择 “Ubuntu” 或您喜欢的其他 Linux 发行版。</li>
<li>点击 “获取”。</li>
<li>安装完成后，点击 “启动”。</li>
</ul>
<p><strong>2. 通过命令行</strong></p>
<ul>
<li><p>打开 PowerShell 或 命令提示符 以管理员身份运行。</p>
</li>
<li><p>输入以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启您的计算机。</p>
</li>
<li><p>安装完成后，您可以通过以下命令启动 WSL：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ul>
<li>WSL 需要 Windows 10 版本 1709 或更高版本。</li>
<li>您可以通过以下命令检查您的 Windows 版本：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">winver</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果您使用的是 Windows 10 家庭版，您需要启用 “<strong>适用于 Linux 的 Windows 子系统</strong>” 功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">控制面板-&gt;程序和功能-&gt;启用或关闭 Windows 功能-&gt;适用于 Linux 的 Windows 子系统-&gt;确定</span><br></pre></td></tr></table></figure>
</li>
<li><p>您可以通过以下命令启用 “<strong>适用于 Linux 的 Windows 子系统</strong>” 功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启您的计算机后，您就可以通过上述方法安装 WSL 了。</p>
</li>
</ul>
<p>安装 Windows Terminal</p>
<h3 id="编译环境配置"><a href="#编译环境配置" class="headerlink" title="编译环境配置"></a>编译环境配置</h3><ul>
<li><p><code>gcc-arm-none-eabi</code>工具链安装</p>
<ul>
<li>手动安装：<a href="https://developer.arm.com/downloads/-/gnu-rm">官方链接地址</a> 下载所需版本；  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install bzip2</span><br><span class="line">sudo tar -xvf ~/n32_gcc/software_package/gcc-arm-none-eabi-9-2019-q4-major-x86_64-linux.tar.bz2 -C ~/n32_gcc</span><br></pre></td></tr></table></figure></li>
<li>自动安装：<code>sudo apt-get install gcc-arm-none-eabi</code></li>
<li>打开 <code>~/.bashrc</code></li>
<li>添加<code>export PATH=$PATH:~/n32_gcc/gcc-arm-none-eabi-9-2019-q4-major/bin</code></li>
<li>添加<code>alias open-file=&#39;explorer.exe .&#39;</code></li>
<li>使能用户环境变量<code>source ~/.bashrc</code></li>
</ul>
</li>
<li><p>Make</p>
<ul>
<li><code>sudo apt-get install make</code></li>
</ul>
</li>
</ul>
<h3 id="Winodows-Gcc-Make-环境搭建"><a href="#Winodows-Gcc-Make-环境搭建" class="headerlink" title="Winodows Gcc + Make 环境搭建"></a>Winodows Gcc + Make 环境搭建</h3><ul>
<li>安装software_package目录下的<code>gcc-arm-none-eabi-9-2019-q4-major-win32-sha2.exe</code>和<code>make-3.81.exe</code></li>
<li>分别将其安装目录下的 <code>./bin</code>添加到系统环境变量，重启生效</li>
<li>复制裸机工程至Windows下，修改部分Makefile的linux指令以适配Windows即可</li>
</ul>
<h3 id="裸机工程编译"><a href="#裸机工程编译" class="headerlink" title="裸机工程编译"></a>裸机工程编译</h3><ul>
<li>cd n32g452_gcc</li>
<li>make</li>
</ul>
<br>

<h2 id="makefile问题汇总"><a href="#makefile问题汇总" class="headerlink" title="makefile问题汇总"></a>makefile问题汇总</h2><h3 id="修改-h文件没有重新编译"><a href="#修改-h文件没有重新编译" class="headerlink" title="修改.h文件没有重新编译"></a>修改.h文件没有重新编译</h3><ul>
<li><code>$(BUILD_DIR)</code>为编译文件目录，跟进自身makefile修改，原来的编译规则：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-include $(wildcard $(BUILD_DIR)<span class="comment">/*/*.d)	# 包含所有生成的依赖文件，避免重复编译、提高效率</span></span><br></pre></td></tr></table></figure>
<code>/*/*.d</code> 为当前目录下的二级所有文件检索。</li>
</ul>
<br>

<ul>
<li>修改为以下编译规则：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 找到所有的 .d 文件</span><br><span class="line">DEP_FILES := $(shell find $(BUILD_DIR) -type f -name <span class="string">&#x27;*.d&#x27;</span>)# 包含所有生成的依赖文件，避免重复编译、提高效率</span><br><span class="line"></span><br><span class="line"># 包含所有的 .d 文件</span><br><span class="line">-include $(DEP_FILES)</span><br></pre></td></tr></table></figure>
或者：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-include $(wildcard $(BUILD_DIR)<span class="comment">/**/</span>*.d)</span><br><span class="line">-include $(wildcard $(BUILD_DIR)<span class="comment">/*/*/</span>*.d)</span><br></pre></td></tr></table></figure>
<code>/**/*.d</code> 为当前目录下的二级所有文件检索，根据具体情况修改。<br><code>/*/*/*.d</code> 为当前目录下的三级所有文件检索，根据具体情况修改。</li>
</ul>
<br>

<h2 id="windows子系统wsl"><a href="#windows子系统wsl" class="headerlink" title="windows子系统wsl"></a>windows子系统wsl</h2><p>###打开新终端 ~&#x2F;.bashrc不会自动刷新</p>
<p>解决linux每次打开新终端都要重新<code>source ~/.bashrc</code>问题<br>执行以下代码：</p>
<pre><code>vi ~/.bash_profile
</code></pre>
<p>有可能此文件是空白新建的，无所谓。然后在此文件末尾加入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ];then</span><br><span class="line">source ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>然后<code>:wq</code>保存即可。<br>此时打开新终端可以自动执行<code>source ~/.bashrc</code></p>
<br>

<h3 id="arm-none-eabi-gcc工具链问题"><a href="#arm-none-eabi-gcc工具链问题" class="headerlink" title="arm-none-eabi-gcc工具链问题"></a>arm-none-eabi-gcc工具链问题</h3><ul>
<li>arm-none-eabi-gcc工具链需加入用户变量：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">export PATH=/home/xuan/OpenHarmony/install-software/gcc-arm-none-eabi<span class="number">-9</span><span class="number">-2019</span>-q4-major/bin:$PATH</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：需确认路径，否则找不到用户路径会搜索系统自带编译链 <code>/usr/lib/gcc/arm-none-eabi/10.3.1</code></p>
<br>

<h2 id="Linux下编写Python合并脚本"><a href="#Linux下编写Python合并脚本" class="headerlink" title="Linux下编写Python合并脚本"></a>Linux下编写Python合并脚本</h2><h3 id="合并-bootloader-app-mix"><a href="#合并-bootloader-app-mix" class="headerlink" title="合并 bootloader + app  &#x3D; mix"></a>合并 bootloader + app  &#x3D; mix</h3><p><strong>1. 安装 PyInstaller</strong></p>
<pre><code>pip install pyinstaller
</code></pre>
<br>

<p><strong>2. 编写Python合并程序</strong></p>
<p><a href="https://github.com/XUAN9527/script">代码链接</a></p>
<br>

<p><strong>3. 打包 Python 程序</strong></p>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-F</code>：生成单一可执行文件。</li>
<li><code>-D</code>：生成包含所有依赖项的目录。</li>
<li><code>-n</code>：指定可执行文件名。</li>
<li><code>--distpath</code>：指定可执行文件输出目录。</li>
<li><code>--noconfirm</code>：覆盖输出文件时无需确认。</li>
</ul>
<p><strong>以下是一些常用的高级选项：</strong></p>
<ul>
<li><code>--hidden-import</code>：指定要隐藏导入的模块。</li>
<li><code>--exclude-module</code>：指定要排除的模块。</li>
<li><code>--onefile</code>：将所有文件打包成一个可执行文件。</li>
<li><code>--runtime</code>：指定 Python 运行时版本。</li>
</ul>
<p><strong>执行规则:</strong></p>
<pre><code>cd new_file,copy file.py and file.ico
pyinstaller -F -w (-i icofile) 文件名.py
</code></pre>
<p><strong>example:</strong></p>
<pre><code>pyinstaller -F file.py
pyinstaller -F -w -i file.ico file.py
</code></pre>
<br>

<p><strong>4. 运行可执行文件</strong></p>
<pre><code>./dist/file
</code></pre>
<br>

<p><strong>5. 例程</strong></p>
<p><a href="https://github.com/XUAN9527/script">代码链接</a></p>
<br>

<p><strong>6. 实际应用场景</strong></p>
<ul>
<li>单独使用：Linux环境下单独执行使用。</li>
<li>集成在<code>makefile</code>中，使用<code>make</code>编译自动生成文件：<ul>
<li>将<code>papp_up</code>和<code>mix_10K</code>打包至<code>tools</code>文件夹，放在<code>makefile</code>同一目录下。</li>
<li>需要<code>bootloder.bin</code>在<code>../bootloader</code>目录下。</li>
<li>修改makefile生成规则。</li>
<li><code>$(BUILD_DIR)</code>为编译文件目录，跟进自身makefile修改。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.PHONY : clean all</span><br><span class="line"></span><br><span class="line">all: $(TARGET).bin $(TARGET).<span class="built_in">list</span> $(TARGET).hex</span><br><span class="line">	$(SZ) $(TARGET).elf</span><br><span class="line">	@make copy</span><br><span class="line">	@make mix</span><br><span class="line"></span><br><span class="line">.PHONY: copy</span><br><span class="line"></span><br><span class="line">copy: $(TARGET).bin</span><br><span class="line">	cp $(TARGET).bin app.bin</span><br><span class="line">	cp ../bootloader/bootloader.bin bootloader.bin</span><br><span class="line"><span class="meta">#	cp $(TARGET).hex app.hex</span></span><br><span class="line"></span><br><span class="line">mix:</span><br><span class="line">	./tools/papp_up</span><br><span class="line">	./tools/mix_10K</span><br><span class="line">	$(OC) -I binary -O ihex --change-addresses <span class="number">0x8000000</span> mix.bin mix.hex</span><br><span class="line">	rm bootloader.bin</span><br><span class="line">	rm app.bin</span><br><span class="line">	rm mix.bin</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -rf $(BUILD_DIR)</span><br><span class="line">	rm papp.bin</span><br><span class="line">	rm mix.hex</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<br>



]]></content>
      <categories>
        <category>嵌入式</category>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>杂项笔记</title>
    <url>/2024/01/31/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="J-Link-J-Flash"><a href="#J-Link-J-Flash" class="headerlink" title="J-Link&#x2F;J-Flash"></a>J-Link&#x2F;J-Flash</h2><p><strong>J-Flash批处理脚本配置烧录：</strong>当然，前提是要添加J-Link的可执行程序路径到<code>$PATH</code>环境变量中</p>
<ul>
<li><code>program.bat</code>脚本代码如下，参考修改即可：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo start...</span><br><span class="line"></span><br><span class="line">JLink -device N32L406CB -if swd -speed 4000 -CommanderScript &quot;C:\Users\Breo\Desktop\Wireless moxibustion\Software\program.jlink&quot;</span><br></pre></td></tr></table></figure></li>
<li><code>program.jlink</code>文件代码如下，其中目标设备、文件路径、烧录地址等根据需要配置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connect</span><br><span class="line">device N32L406CB</span><br><span class="line">si SWD</span><br><span class="line">speed 4000</span><br><span class="line">h		// halt-停止</span><br><span class="line">r		// 复位，可以考虑去掉</span><br><span class="line">erase		// 或 erase 0x8002800，去掉也行，但可能会出现error fail address 0x00000000错误提示</span><br><span class="line"></span><br><span class="line">loadfile app.bin 0x8002800      // loadfile app.hex 或 loadfile app.bin 0x8000000</span><br><span class="line">verifybin app.bin 0x8002800</span><br><span class="line">r</span><br><span class="line">go		// r go表示reset and run</span><br><span class="line">q		// 退出J-Link命令行工具</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Ubuntu-无法更新问题"><a href="#Ubuntu-无法更新问题" class="headerlink" title="Ubuntu 无法更新问题"></a>Ubuntu 无法更新问题</h2><p>Ubuntu 无法使用<code>apt update</code></p>
<h3 id="更改软件源"><a href="#更改软件源" class="headerlink" title="更改软件源"></a>更改软件源</h3><p>编辑 <code>/etc/apt/sources.list</code> 文件，将以下内容添加到文件末尾</p>
<pre><code>deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse

deb https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse

deb https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
</code></pre>
<h3 id="清除-apt-缓存"><a href="#清除-apt-缓存" class="headerlink" title="清除 apt 缓存"></a>清除 apt 缓存</h3><pre><code>sudo apt clean
sudo apt autoclean
</code></pre>
<h3 id="尝试更新系统"><a href="#尝试更新系统" class="headerlink" title="尝试更新系统"></a>尝试更新系统</h3><pre><code>sudo apt update
</code></pre>
<p>显示 <code>ModuleNotFoundError: No module named &#39;apt_pkg&#39;</code>，重新安装 “<code>apt_pkg</code>“ 模块：</p>
<pre><code>sudo apt install --reinstall python3-apt
</code></pre>
<p>显示 ERROR：</p>
<pre><code>E: Could not read response to hello message from hook [ ! -f /usr/bin/snap ] || /usr/bin/snap advise-snap --from-apt 2&gt;/dev/null || true: Success
</code></pre>
<p>如果问题仍然存在，尝试修复 Python 包：</p>
<pre><code>sudo apt install --fix-broken
</code></pre>
<p>然后就更新系统了：</p>
<pre><code>sudo apt update
sudo apt upgrade
</code></pre>
<p>执行<code>sudo apt upgrade</code>后显示ERROR：</p>
<pre><code>Errors were encountered while processing:
/tmp/apt-dpkg-install-cQBLJW/626-linux-iot-tools-common_5.4.0-1030.31_all.deb
E: Sub-process /usr/bin/dpkg returned an error code (1)
</code></pre>
<p>最后一步，修复损坏的软件包配置：</p>
<pre><code>sudo dpkg --configure -a
sudo apt upgrade
</code></pre>
<h2 id="Breo蓝牙启动异常"><a href="#Breo蓝牙启动异常" class="headerlink" title="Breo蓝牙启动异常"></a>Breo蓝牙启动异常</h2><h3 id="Breo蓝牙初始化"><a href="#Breo蓝牙初始化" class="headerlink" title="Breo蓝牙初始化"></a>Breo蓝牙初始化</h3><p>蓝牙初始化没完成，透传未开启，app就连接蓝牙了。<br>设置透传参数，开启透传的的状态中增加连接蓝牙接受指令。</p>
<h3 id="心跳包回复超时"><a href="#心跳包回复超时" class="headerlink" title="心跳包回复超时"></a>心跳包回复超时</h3><p>现在是接收&#x2F;刷新设备数据200ms超时，延迟太长还可以缩短。</p>
<h2 id="SPI级联led灯调试小助手"><a href="#SPI级联led灯调试小助手" class="headerlink" title="SPI级联led灯调试小助手"></a>SPI级联led灯调试小助手</h2><p>产品名称：1209RGB幻彩雾状<br>产品型号：XTQ-016B.RGB-2307125-20</p>
<h3 id="SPI级联led灯问题汇总"><a href="#SPI级联led灯问题汇总" class="headerlink" title="SPI级联led灯问题汇总"></a>SPI级联led灯问题汇总</h3><h4 id="充电闪灯问题"><a href="#充电闪灯问题" class="headerlink" title="充电闪灯问题"></a>充电闪灯问题</h4><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>充电中拔掉电源，立即再次插入，会闪一下灯；若等两秒再插入则不会出现，初步判断是此款芯片有锁存功能，会保存到寄存器中，未完全掉电再次插入则会继续执行上次的寄存器数据。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>充电中拔掉电源，程序不要立即断电，持续两秒反初始化spi灯珠，即给spi寄存器写全灭数据。</p>
<h4 id="呼吸灯闪烁问题"><a href="#呼吸灯闪烁问题" class="headerlink" title="呼吸灯闪烁问题"></a>呼吸灯闪烁问题</h4><h5 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h5><p>程序中呼吸灯会跑偶尔闪烁，影响显示效果。分析发现，代码中有电机的FG检测，此检测开启了输入捕获功能，会持续中断触发，虽然spi灯的驱动是dma发送，但是也是由CPU来调度的，并不能与中断并行。spi呼吸灯效果需要持续发送数据，且时序要求很高，中断会抢占spi的dma发送，打断spi传输数据，导致数据传输出错，造成闪灯效果。</p>
<h5 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h5><p>1、提高芯片主频，n32l403KB最高主频为64MHz，如果主频提高效果会好一些。<br>2、spi呼吸灯效果持续发送数据，不能与中断频繁的代码一起使用。</p>
<h2 id="某项目充电保护仍充电"><a href="#某项目充电保护仍充电" class="headerlink" title="某项目充电保护仍充电"></a>某项目充电保护仍充电</h2><p>修改代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;-1, 1, PIN_CHARGE_CC_DETECT, PIN_MODE_INPUT&#125;,	//input/output switch</span><br><span class="line"></span><br><span class="line">static void board_charge_cc_set(bool en)</span><br><span class="line">&#123;	</span><br><span class="line">	struct pin_status_desc *pin = pin_handle(PIN_CHARGE_CC_DETECT);</span><br><span class="line">	<span class="keyword">if</span>(en)</span><br><span class="line">	&#123;</span><br><span class="line">		pin-&gt;<span class="built_in">type</span> = PIN_MODE_INPUT;</span><br><span class="line">		drv_pin_mode(pin-&gt;pin_id,pin-&gt;<span class="built_in">type</span>);</span><br><span class="line">		pin-&gt;lvl_rt = -1;			//重置lvl_rt，以防止output出问题</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		pin-&gt;<span class="built_in">type</span> = PIN_MODE_OUTPUT;</span><br><span class="line">		drv_pin_mode(pin-&gt;pin_id,pin-&gt;<span class="built_in">type</span>);</span><br><span class="line">		pin_set_func(pin, PIN_HIGH);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Git小贴士"><a href="#Git小贴士" class="headerlink" title="Git小贴士"></a>Git小贴士</h2><h3 id="执行-git-pull-会覆盖本地的修改吗？"><a href="#执行-git-pull-会覆盖本地的修改吗？" class="headerlink" title="执行 git pull 会覆盖本地的修改吗？"></a>执行 git pull 会覆盖本地的修改吗？</h3><p>没有冲突的情况下，远端会直接更新至本地上，但不会改变本地未提交的变动；如果本地修改已提交，则会执行一个远端分支和本地分支的合并</p>
<h3 id="git-fetch-和-git-pull-的区别与联系"><a href="#git-fetch-和-git-pull-的区别与联系" class="headerlink" title="git fetch 和 git pull 的区别与联系"></a>git fetch 和 git pull 的区别与联系</h3><p><code>git fetch</code>用于从远程仓库获取最新的提交，保存到本地的远程跟踪分支中（<code>FETCH_HEAD</code>），可以通过查看此分支了解远程仓库的更新情况</p>
<ul>
<li><code>git diff FETCH_HEAD</code>比较查看该分支和当前工作分支的内容</li>
</ul>
<br>

<p><code>git pull</code>会自动获取远程仓库的更新，并且合并到当前分支上，相当于<code>git fetch</code> + <code>git merge FETCH_HEAD</code></p>
<ul>
<li>将远程仓库中指定分支的最新提交 ID 保存到本地的 <code>FETCH_HEAD</code> 分支中</li>
<li>将 <code>FETCH_HEAD</code> 分支合并到当前工作分支中</li>
</ul>
<h3 id="基础非典型操作"><a href="#基础非典型操作" class="headerlink" title="基础非典型操作"></a>基础非典型操作</h3><h3 id="本地git配置"><a href="#本地git配置" class="headerlink" title="本地git配置"></a>本地git配置</h3><br>

<p><strong>配置本地与远端的SSH密钥连接流程：</strong></p>
<ul>
<li>本地生成SSH公钥和私钥(如果没有的话，另，linux下公钥通常存放于<code>~/.ssh/*.pub</code>)<ul>
<li><code>ssh-keygen -t rsa -b 4096 -C xxx@xxx.com</code></li>
</ul>
</li>
<li>复制公钥，添加至远端平台的SSH设置上<br></li>
</ul>
<p><strong>查看本地配置：</strong></p>
<ul>
<li><code>git config --list</code>查看当前项目的所有配置</li>
<li><code>git config --global --list</code>查看全局配置<br></li>
</ul>
<p><strong>修改用户名(全局&#x2F;当前项目)</strong></p>
<p>此用户名即提交日志上所展示的用户名称</p>
<ul>
<li>修改全局用户名：<code>git config --global user.name &quot;xxx&quot;</code>，影响用户的所有仓库</li>
<li>修改当前路径项目的用户名：<code>git config user.name &quot;xxx&quot;</code></li>
<li>查看全局用户名：<code>git config user.name</code><br></li>
</ul>
<p><strong>初始化本地工程并与远端已有仓库的main分支关联：</strong></p>
<ul>
<li>进入工程根目录，<code>git init</code>初始化本地仓库</li>
<li>添加远程仓库：<code>git remote add origin &lt;远程仓库地址&gt;</code></li>
<li><code>git branch -M main</code>将当前分支重命名为<code>main</code>，M即<code>--move --force</code>的缩写。（可以分别输入<code>git add --all</code>，<code>git commit -m &quot;first commit&quot;</code>完成对本地分支的首次提交）</li>
<li>使用<code>git pull origin main</code>，将远程仓库的main分支拉取到本地，或者<code>git push -u origin main -f</code>将本地的xxx分支强制推送到远端main分支，其中-u是<code>--set-upstream</code>的缩写，后续会保持这个跟踪关系</li>
</ul>
<br>

<h2 id="可变参数函数详解"><a href="#可变参数函数详解" class="headerlink" title="可变参数函数详解"></a>可变参数函数详解</h2><p>C语言中的可变参数函数允许您定义函数，其参数个数是不确定的，可以根据具体需求接受可变数量的参数。这在处理不定数量参数的情况下非常有用，比如<code>printf</code>和<code>scanf</code>等函数。让我为您详细解释一下可变参数函数的原理和实现。</p>
<p><strong>1. 原理与实现：</strong></p>
<ul>
<li><p>可变参数函数的参数列表是从右往左压入堆栈的。假设堆栈中有以下参数：不可变参数1、不可变参数2、…、不可变参数n、可变参数1、可变参数2、…、可变参数n。</p>
</li>
<li><p>为了获取可变参数，我们需要知道每个可变参数的地址。这是通过前一个不可变参数的地址和类型来实现的。</p>
</li>
<li><p>ANSI标准提供了三个宏来实现这个过程：</p>
<ul>
<li><p><code>va_start(va_list arg_ptr, prev_param)</code>: 初始化可变参数列表，将arg_ptr指向第一个可变参数。</p>
</li>
<li><p><code>va_arg(va_list arg_ptr, type)</code>: 获取当前参数的值，类型由前面的不可变参数传递。例如，printf中的格式化字符串或者可变参数列表的参数类型和第几个不可变参数的相同。</p>
</li>
<li><p><code>va_end(va_list arg_ptr)</code>: 释放资源，结束可变参数列表的访问。</p>
</li>
</ul>
</li>
<li><p>这些宏的实现细节由编译器和标准库提供，我们只需调用它们即可。</p>
</li>
</ul>
<p><strong>2. 可变参数函数：</strong></p>
<ul>
<li>可变参数函数允许在函数定义中接受不定数量的参数。</li>
<li>C语言提供了 <code>stdarg.h</code> 头文件来支持可变参数函数的实现。</li>
<li>下面是一个示例代码，展示了如何实现一个可变参数函数 sum，它接受一个整数参数 count，表示接下来的可变参数的数量：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> count, ...)</span> &#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">        total += num;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = sum(<span class="number">4</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个示例中，我们定义了一个可变参数函数 sum，它计算传入的整数参数的总和。</li>
</ul>
<br>

<p><strong>3. 可变参数宏：</strong></p>
<ul>
<li>可变参数宏允许在宏调用中接受可变数量的参数。</li>
<li>在C语言中，可变参数宏使用 <code>__VA_ARGS__</code> 表示可变参数的部分。</li>
<li>下面是一个示例代码，展示了如何定义一个可变参数宏 <code>PRINT_VALUES</code>，它使用 printf 函数来打印可变数量的值:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_VALUES(...) do &#123; \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;Values: &quot;</span>); \</span></span><br><span class="line"><span class="meta">    printf(__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;\n&quot;</span>); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    PRINT_VALUES(<span class="string">&quot;%d %s %f&quot;</span>, <span class="number">10</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个示例中，我们定义了一个可变参数宏 <code>PRINT_VALUES</code>，它使用 <code>printf</code> 函数来打印多个值。</li>
</ul>
<br>

<p><strong>4. 实现自己的 printf 函数：</strong></p>
<ul>
<li><code>printf</code> 函数接受一个格式字符串作为第一个参数，后面是可变数量的参数，用于替换格式字符串中的格式占位符。</li>
<li>以下是一个简化版的示例代码，展示了一个实现类似于 <code>printf</code> 函数的功能的函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span> &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line">    <span class="keyword">while</span> (*format != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*format == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">            format++; <span class="comment">// 移动到占位符的下一个字符</span></span><br><span class="line">            <span class="keyword">if</span> (*format == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> value = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">double</span> value = va_arg(args, <span class="type">double</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">char</span>* value = va_arg(args, <span class="type">char</span>*);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> value = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Unsupported format specifier: %c&quot;</span>, *format);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *format);</span><br><span class="line">        &#125;</span><br><span class="line">        format++; <span class="comment">// 移动到下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">	<span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">	<span class="type">char</span> str[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	my_printf(<span class="string">&quot;Integer: %d\n&quot;</span>, num);</span><br><span class="line">	my_printf(<span class="string">&quot;Float: %f\n&quot;</span>, pi);</span><br><span class="line">	my_printf(<span class="string">&quot;Float: %s\n&quot;</span>, str);</span><br><span class="line">	my_printf(<span class="string">&quot;Float: %c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><p>参考文档：<a href="https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">汇编语言入门教程</a></p>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序example.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add_a_and_b</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> add_a_and_b(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gcc 将这个程序转成汇编语言。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc -S example.c</span><br></pre></td></tr></table></figure>
<p>example.s经过简化以后，大概是下面的样子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_add_a_and_b:</span><br><span class="line">   push   %ebx</span><br><span class="line">   mov    %eax, [%esp+8] </span><br><span class="line">   mov    %ebx, [%esp+12]</span><br><span class="line">   add    %eax, %ebx </span><br><span class="line">   pop    %ebx </span><br><span class="line">   ret  </span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line">   push   3</span><br><span class="line">   push   2</span><br><span class="line">   call   _add_a_and_b </span><br><span class="line">   add    %esp, 8</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>
<p>可以看到，原程序的两个函数add_a_and_b和main，对应两个标签_add_a_and_b和_main。每个标签里面是该函数所转成的 CPU 运行流程。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux下开发单片机</title>
    <url>/2024/05/06/Linux%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
    <content><![CDATA[<h2 id="tree指令小贴士"><a href="#tree指令小贴士" class="headerlink" title="tree指令小贴士"></a>tree指令小贴士</h2><p><strong>1. 基本用法：</strong><br>显示当前目录下的文件和目录结构。</p>
<pre><code>tree
</code></pre>
<p><strong>2. 限制目录深度：</strong><br>使用 -L 选项后跟数字来限制目录显示的深度。</p>
<pre><code>tree -L 2
</code></pre>
<p>这将显示当前目录及其下最多两级子目录。</p>
<p><strong>3. 显示隐藏文件：</strong><br>默认情况下，隐藏文件（以点 . 开头的文件或目录）不会被显示。要显示这些隐藏文件，可以使用 -a 选项。</p>
<pre><code>tree -a
</code></pre>
<p><strong>4. 递归显示所有文件：</strong><br>使用 -R 选项递归显示所有文件。</p>
<pre><code>tree -R
</code></pre>
<p><strong>5. 指定目录：</strong><br>显示指定目录的树状结构。</p>
<pre><code>tree /path/to/directory
</code></pre>
<p><strong>6. 使用文件系统类型：</strong><br>显示目录结构时，包括文件系统类型。</p>
<pre><code>tree -F
</code></pre>
<p><code>-F</code> 选项会在每个目录名后添加一个斜杠 <code>/</code>。</p>
<p><strong>7. 排序：</strong><br>默认情况下，tree 会按字母顺序排序。使用 -f 选项可以按照文件修改时间排序。</p>
<pre><code>tree -f
</code></pre>
<p><strong>8. 显示文件大小：</strong><br>使用 -h 选项以更易读的格式显示文件大小。</p>
<pre><code>tree -h
</code></pre>
<p><strong>9. 显示目录和文件的权限：</strong><br>使用 <code>-u</code> 选项显示文件所有者，<code>-g</code> 选项显示文件组。</p>
<pre><code>tree -ug
</code></pre>
<p><strong>10. 使用颜色：</strong><br>tree 命令使用颜色来区分不同类型的文件和目录。使用 –no-colour 可以关闭颜色显示。</p>
<pre><code>tree --no-colour
</code></pre>
<p><strong>11. 输出到文件：</strong><br>将树状结构输出到一个文件中。</p>
<pre><code>tree &gt; tree.txt
</code></pre>
<p><strong>12. 执行命令：</strong><br>对每个文件或目录执行命令，例如，获取每个文件的详细信息。</p>
<pre><code>tree -exec ls -l &#123;&#125; \;
</code></pre>
<p><strong>13. 帮助和手册：</strong><br>查看 tree 命令的帮助信息。</p>
<pre><code>tree --help
man tree
</code></pre>
<p><strong>14. 安装 tree 命令（如果尚未安装）通常可以通过你的Linux发行版的包管理器来完成。</strong><br>例如，在Ubuntu上，你可以使用以下命令安装：</p>
<pre><code>sudo apt-get update
sudo apt-get install tree
</code></pre>
<p>使用 tree 可以帮助你更直观地查看目录结构，特别是在处理复杂的文件系统时。</p>
<br>

]]></content>
      <categories>
        <category>小贴士</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake学习笔记</title>
    <url>/2024/05/08/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="CMake学习教程"><a href="#CMake学习教程" class="headerlink" title="CMake学习教程"></a>CMake学习教程</h2><ul>
<li>[参考资料1] : <a href="https://subingwen.cn/cmake/CMake-primer">https://subingwen.cn/cmake/CMake-primer</a></li>
<li>[参考资料2] : <a href="https://subingwen.cn/cmake/CMake-advanced/">https://subingwen.cn/cmake/CMake-advanced/</a></li>
<li>[参考资料3] : <a href="https://zhuanlan.zhihu.com/p/534439206">https://zhuanlan.zhihu.com/p/534439206</a></li>
</ul>
<br>

<h2 id="编写一个简单的CMakeLists-txt文件"><a href="#编写一个简单的CMakeLists-txt文件" class="headerlink" title="编写一个简单的CMakeLists.txt文件"></a>编写一个简单的CMakeLists.txt文件</h2><h3 id="1-示例文件的目录结构如下："><a href="#1-示例文件的目录结构如下：" class="headerlink" title="1. 示例文件的目录结构如下："></a>1. 示例文件的目录结构如下：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-添加-CMakeLists-txt-文件"><a href="#2-添加-CMakeLists-txt-文件" class="headerlink" title="2. 添加 CMakeLists.txt 文件"></a>2. 添加 CMakeLists.txt 文件</h3><p>在上述源文件所在目录下添加一个新文件 CMakeLists.txt，文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.0</span>)</span><br><span class="line">project(CALC)</span><br><span class="line">add_executable(app add.c div.c main.c mult.c sub.c)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>cmake_minimum_required</code>：指定使用的 cmake 的最低版本。</p>
<ul>
<li>可选，非必须，如果不加可能会有警告。</li>
</ul>
</li>
<li><p><code>project</code>：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。</p>
</li>
<li><p><code>add_executable</code>：定义工程会生成一个可执行程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add_executable(可执行程序名 源文件名称)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里的可执行程序名和<code>project</code>中的项目名没有任何关系</p>
</li>
<li><p>源文件名可以是一个也可以是多个，如有多个可用空格或<code>;</code>间隔</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 样式<span class="number">1</span></span><br><span class="line">add_executable(app add.c div.c main.c mult.c sub.c)</span><br><span class="line"># 样式<span class="number">2</span></span><br><span class="line">add_executable(app add.c;div.c;main.c;mult.c;sub.c)</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="3-执行CMake命令"><a href="#3-执行CMake命令" class="headerlink" title="3. 执行CMake命令"></a>3. 执行CMake命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake 命令原型</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake CMakeLists.txt 文件所在路径</span></span><br></pre></td></tr></table></figure>
<p>执行示例 (当前<code>CMakeLists.txt</code>路径) ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake .</span></span><br></pre></td></tr></table></figure>
<p>当执行<code>cmake</code>命令之后，<code>CMakeLists.txt</code> 中的命令就会被执行，所以一定要注意给<code>cmake</code>命令指定路径的时候一定不能出错。</p>
<p>执行命令之后，看一下源文件所在目录中是否多了一些文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── CMakeCache.txt         # new add file</span><br><span class="line">├── CMakeFiles             # new add dir</span><br><span class="line">├── cmake_install.cmake    # new add file</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── Makefile               # new add file</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>

<p>我们可以看到在对应的目录下生成了一个<code>makefile</code>文件，此时再执行<code>make</code>命令，就可以对项目进行构建得到所需的可执行程序了。</p>
<br>

<h3 id="4-头文件及指定宏"><a href="#4-头文件及指定宏" class="headerlink" title="4. 头文件及指定宏"></a>4. 头文件及指定宏</h3><ul>
<li><code>CMakeLists.txt</code> 示例代码文件：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(HOME /home/robin/Linux/calc)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin/)</span><br><span class="line"><span class="meta prompt_">include_directories($</span><span class="language-bash">&#123;PROJECT_SOURCE_DIR&#125;/include)</span></span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)</span><br><span class="line">add_executable(app  $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h4 id="4-1-通过参数-std-c-11指定出要使用c-11标准编译程序-对应宏DCMAKE-CXX-STANDARD"><a href="#4-1-通过参数-std-c-11指定出要使用c-11标准编译程序-对应宏DCMAKE-CXX-STANDARD" class="headerlink" title="4.1 通过参数-std=c++11指定出要使用c++11标准编译程序,对应宏DCMAKE_CXX_STANDARD:"></a>4.1 通过参数<code>-std=c++11</code>指定出要使用c++11标准编译程序,对应宏<code>DCMAKE_CXX_STANDARD</code>:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 增加-std=c++<span class="number">11</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加-std=c++11</span></span><br><span class="line">cmake (CMakeLists.txt文件路径) -DCMAKE_CXX_STANDARD=11</span><br></pre></td></tr></table></figure>

<br>

<h4 id="4-2-指定输出的路径-EXECUTABLE-OUTPUT-PATH-："><a href="#4-2-指定输出的路径-EXECUTABLE-OUTPUT-PATH-：" class="headerlink" title="4.2 指定输出的路径(EXECUTABLE_OUTPUT_PATH)："></a>4.2 指定输出的路径(EXECUTABLE_OUTPUT_PATH)：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set(HOME /home/robin/Linux/Sort)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin)</span><br></pre></td></tr></table></figure>
<p>如果这个路径中的子目录不存在，会自动生成，无需自己手动创建。</p>
<br>

<h4 id="4-3-头文件的路径-include-directories"><a href="#4-3-头文件的路径-include-directories" class="headerlink" title="4.3 头文件的路径(include_directories)"></a>4.3 头文件的路径(include_directories)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include_directories(headpath)</span><br></pre></td></tr></table></figure>
<p>其中，第六行指定就是头文件的路径，PROJECT_SOURCE_DIR宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。</p>
<br>

<h4 id="4-4-搜索文件-aux-source-directory"><a href="#4-4-搜索文件-aux-source-directory" class="headerlink" title="4.4 搜索文件(aux_source_directory)"></a>4.4 搜索文件(aux_source_directory)</h4><ul>
<li><p><code>aux_source_directory(&lt; dir &gt; &lt; variable &gt;)</code> 示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</code>示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CMAKE_CURRENT_SOURCE_DIR</code> 宏表示当前访问的 <code>CMakeLists.txt</code> 文件所在的路径</p>
</li>
</ul>
<br>

<h3 id="5-制作动态库或静态库"><a href="#5-制作动态库或静态库" class="headerlink" title="5. 制作动态库或静态库"></a>5. 制作动态库或静态库</h3><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p>
<h4 id="5-1-静态库："><a href="#5-1-静态库：" class="headerlink" title="5.1 静态库："></a>5.1 静态库：</h4><h5 id="5-1-1-cmake生成规则："><a href="#5-1-1-cmake生成规则：" class="headerlink" title="5.1.1 cmake生成规则："></a>5.1.1 cmake生成规则：</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名称 STATIC 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br></pre></td></tr></table></figure>

<ul>
<li>在Linux中，静态库名字分为三部分：<code>lib + 库名字 + .a</code>，示例：<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>
这样最终就会生成对应的静态库文件 <code>libcalc.a</code></li>
</ul>
<br>

<h5 id="5-1-2-gcc生成规则："><a href="#5-1-2-gcc生成规则：" class="headerlink" title="5.1.2 gcc生成规则："></a>5.1.2 gcc生成规则：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c add.c div.c mult.c sub.c -I ./include/</span><br></pre></td></tr></table></figure>

<ul>
<li>生成 <code>.o</code> 编译文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录中的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── add.o            # 目标文件</span><br><span class="line">├── div.c</span><br><span class="line">├── div.o            # 目标文件</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">├── mult.o           # 目标文件</span><br><span class="line">├── sub.c</span><br><span class="line">└── sub.o            # 目标文件</span><br></pre></td></tr></table></figure>
<ul>
<li>将生成的目标文件通过 ar工具打包生成静态库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将生成的目标文件 .o 打包成静态库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar rcs libcalc.a add.o div.o mult.o sub.o    <span class="comment">#在同一个目录中可以写成 *.o</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录中的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── add.o</span><br><span class="line">├── div.c</span><br><span class="line">├── div.o</span><br><span class="line">├── include</span><br><span class="line">│   └── `head.h  ===&gt; 和静态库一并发布</span><br><span class="line">├── `libcalc.a   ===&gt; 生成的静态库</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">├── mult.o</span><br><span class="line">├── sub.c</span><br><span class="line">└── sub.o</span><br></pre></td></tr></table></figure>

<ul>
<li>将生成的的静态库 libcalc.a和库对应的头文件head.h一并发布给使用者就可以了。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 发布静态库</span></span><br><span class="line">	1. head.h    =&gt; 函数声明</span><br><span class="line">	2. libcalc.a =&gt; 函数定义(二进制格式)</span><br></pre></td></tr></table></figure>
<br>

<h5 id="5-1-3-gcc静态库的使用"><a href="#5-1-3-gcc静态库的使用" class="headerlink" title="5.1.3 gcc静态库的使用:"></a>5.1.3 gcc静态库的使用:</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先拿到了发布的静态库</span></span><br><span class="line">	`head.h` 和 `libcalc.a`</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将静态库, 头文件, 测试程序放到一个目录中准备进行测试</span></span><br><span class="line">.</span><br><span class="line">├── head.h          # 函数声明</span><br><span class="line">├── libcalc.a       # 函数定义（二进制格式）</span><br><span class="line">└── main.c          # 函数测试</span><br></pre></td></tr></table></figure>

<ul>
<li>编译测试程序, 得到可执行文件。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译的时候指定库信息</span></span><br><span class="line"> 	-I: 指定头文件所在的目录(相对或者绝对路径)</span><br><span class="line">	-L: 指定库所在的目录(相对或者绝对路径)</span><br><span class="line">	-l: 指定库的名字, 掐头(lib)去尾(.a) ==&gt; calc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-L -l, 参数和参数值之间可以有空格, 也可以没有  -L./ -lcalc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -o app -I./ -L./ -lcalc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录信息, 发现可执行程序已经生成了</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── app   		# 生成的可执行程序</span><br><span class="line">├── head.h</span><br><span class="line">├── libcalc.a</span><br><span class="line">└── main.c</span><br></pre></td></tr></table></figure>

<br>

<h4 id="5-2-动态库："><a href="#5-2-动态库：" class="headerlink" title="5.2 动态库："></a>5.2 动态库：</h4><h5 id="5-2-1-cmake生成规则："><a href="#5-2-1-cmake生成规则：" class="headerlink" title="5.2.1 cmake生成规则："></a>5.2.1 cmake生成规则：</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名称 SHARED 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...)</span><br></pre></td></tr></table></figure>

<ul>
<li>在Linux中，动态库名字分为三部分：<code>lib + 库名字 + .so</code> ，示例：<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>
这样最终就会生成对应的动态库文件 <code>libcalc.so</code></li>
</ul>
<br>

<h5 id="5-1-2-gcc生成规则：-1"><a href="#5-1-2-gcc生成规则：-1" class="headerlink" title="5.1.2 gcc生成规则："></a>5.1.2 gcc生成规则：</h5><ul>
<li>生成动态链接库是直接使用<code>gcc</code>命令并且需要添加<code>-fPIC(-fpic)</code> 以及<code>-shared</code> 参数。<ul>
<li><code>-fPIC</code> 或 <code>-fpic</code> 参数的作用是使得 <code>gcc</code> 生成的代码是与位置无关的，也就是使用相对位置。</li>
<li><code>-shared</code>参数的作用是告诉编译器生成一个动态链接库。</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 将.c汇编得到.o, 需要额外的参数 -fpic/-fPIC</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c -fpic add.c div.c mult.c sub.c -I ./include/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成 <code>.o</code> 编译文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录文件信息, 检查是否生成了目标文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── add.o                # 生成的目标文件</span><br><span class="line">├── div.c</span><br><span class="line">├── div.o                # 生成的目标文件</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">├── mult.o               # 生成的目标文件</span><br><span class="line">├── sub.c</span><br><span class="line">└── sub.o                # 生成的目标文件</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>gcc</code>将得到的目标文件打包生成动态库, 需要使用参数 <code>-shared</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 将得到 .o 打包成动态库, 使用gcc , 参数 -shared</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -shared add.o div.o mult.o sub.o -o libcalc.so</span>  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查目录中是否生成了动态库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── add.o</span><br><span class="line">├── div.c</span><br><span class="line">├── div.o</span><br><span class="line">├── include</span><br><span class="line">│   └── `head.h   ===&gt; 和动态库一起发布</span><br><span class="line">├── `libcalc.so   ===&gt; 生成的动态库</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">├── mult.o</span><br><span class="line">├── sub.c</span><br><span class="line">└── sub.o</span><br></pre></td></tr></table></figure>

<ul>
<li>将生成的的动态库 libcalc.so和库对应的头文件head.h一并发布给使用者就可以了。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发布库文件和头文件</span></span><br><span class="line">	1. head.h</span><br><span class="line">	2. libcalc.so</span><br></pre></td></tr></table></figure>

<h5 id="5-1-3-gcc静态库的使用-1"><a href="#5-1-3-gcc静态库的使用-1" class="headerlink" title="5.1.3 gcc静态库的使用:"></a>5.1.3 gcc静态库的使用:</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 拿到发布的动态库</span></span><br><span class="line">	`head.h   libcalc.so</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 基于头文件编写测试程序, 测试动态库中提供的接口是否可用</span></span><br><span class="line">	`main.c`</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例目录:</span></span><br><span class="line">.</span><br><span class="line">├── head.h          ==&gt; 函数声明</span><br><span class="line">├── libcalc.so      ==&gt; 函数定义</span><br><span class="line">└── main.c          ==&gt; 函数测试</span><br></pre></td></tr></table></figure>

<ul>
<li>编译测试程序, 得到可执行文件。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在编译的时候指定动态库相关的信息: 头文件路径-I 库的路径 -L, 库的名字 -l</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -o app -I./ -L./ -lcalc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否生成了可执行程序</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── app 			# 生成的可执行程序</span><br><span class="line">├── head.h</span><br><span class="line">├── libcalc.so</span><br><span class="line">└── main.c</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行生成的可执行程序, 错误提示 ==&gt; 可执行程序执行的时候找不到动态库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./app</span> </span><br><span class="line">./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p><strong>修改解决动态库链接编译问题</strong></p>
<p>方案 1: 将库路径添加到环境变量<code>LD_LIBRARY_PATH</code>中</p>
<ol>
<li>找到相关的配置文件</li>
</ol>
<ul>
<li>用户级别: ~&#x2F;.bashrc —&gt; 设置对当前用户有效</li>
<li>系统级别: &#x2F;etc&#x2F;profile —&gt; 设置对所有用户有效</li>
</ul>
<ol start="2">
<li>使用 vim 打开配置文件, 在文件最后添加这样一句话</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自己把路径写进去就行了</span></span><br><span class="line">export LD_LIBRARY_PATH =$LD_LIBRARY_PATH :动态库的绝对路径</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>让修改的配置文件生效</li>
</ol>
<ul>
<li>修改了用户级别的配置文件, 关闭当前终端, 打开一个新的终端配置就生效了</li>
<li>修改了系统级别的配置文件, 注销或关闭系统, 再开机配置就生效了</li>
<li>不想执行上边的操作, 可以执行一个命令让配置重新被加载</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改的是哪一个就执行对应的那个命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">source</span> 可以简写为一个 . , 作用是让文件内容被重新加载</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> ~/.bashrc          (. ~/.bashrc)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> /etc/profile       (. /etc/profile)</span></span><br></pre></td></tr></table></figure>

<p>方案 2: 更新 &#x2F;etc&#x2F;ld.so.cache 文件</p>
<ol>
<li><p>找到动态库所在的绝对路径（不包括库的名字）比如：&#x2F;home&#x2F;robin&#x2F;Library&#x2F;</p>
</li>
<li><p>使用vim 修改 &#x2F;etc&#x2F;ld.so.conf 这个文件, 将上边的路径添加到文件中(独自占一行)</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 打开文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo vim /etc/ld.so.conf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 添加动态库路径, 并保存退出</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>更新 &#x2F;etc&#x2F;ld.so.conf中的数据到 &#x2F;etc&#x2F;ld.so.cache 中</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">必须使用管理员权限执行这个命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ldconfig</span>   </span><br></pre></td></tr></table></figure>

<p>方案 3: 拷贝动态库文件到系统库目录 &#x2F;lib&#x2F; 或者 &#x2F;usr&#x2F;lib 中 (或者将库的软链接文件放进去)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">库拷贝</span></span><br><span class="line">sudo cp /xxx/xxx/libxxx.so /usr/lib</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建软连接</span></span><br><span class="line">sudo ln -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so</span><br></pre></td></tr></table></figure>

<p>验证执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法:</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd 可执行程序名</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例:</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd app</span></span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffe8fbd6000)</span><br><span class="line">    libcalc.so =&gt; /home/robin/Linux/3Day/calc/test/libcalc.so (0x00007f5d85dd4000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5d85a0a000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007f5d85fd6000)  ==&gt; 动态链接器, 操作系统提供</span><br></pre></td></tr></table></figure>

<br>

<h4 id="5-3-指定输出的路径："><a href="#5-3-指定输出的路径：" class="headerlink" title="5.3 指定输出的路径："></a>5.3 指定输出的路径：</h4><ul>
<li><p>方式1 - 适用于动态库</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式2 - 都适用</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h4 id="5-4-包含库文件："><a href="#5-4-包含库文件：" class="headerlink" title="5.4 包含库文件："></a>5.4 包含库文件：</h4><h5 id="5-4-1-链接静态库："><a href="#5-4-1-链接静态库：" class="headerlink" title="5.4.1 链接静态库："></a>5.4.1 链接静态库：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure>
<p>现在我们把上面<code>src</code>目录中的<code>add.cpp</code>、<code>div.cpp</code>、<code>mult.cpp</code>、<code>sub.cpp</code>编译成一个静态库文件<code>libcalc.a</code>。通过命令制作并使用静态链接库。</p>
<p>测试目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span> </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a     # 制作出的静态库的名字</span><br><span class="line">└── src</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 4 files</span><br></pre></td></tr></table></figure>

<p>在cmake中，链接静态库的命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br></pre></td></tr></table></figure>

<ul>
<li>参数1：指定出要链接的静态库的名字<ul>
<li>可以是全名 libxxx.a</li>
<li>也可以是掐头（lib）去尾（.a）之后的名字 xxx</li>
</ul>
</li>
<li>参数2-N：要链接的其它静态库的名字</li>
</ul>
<p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(&lt;lib path&gt;)</span><br></pre></td></tr></table></figure>

<p>这样，修改之后的CMakeLists.txt文件内容如下:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 包含静态库路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>
<br>

<h5 id="5-4-2-链接动态库："><a href="#5-4-2-链接动态库：" class="headerlink" title="5.4.2 链接动态库："></a>5.4.2 链接动态库：</h5><p>动态库的链接和静态库是完全不同的：</p>
<ul>
<li>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。</li>
<li>动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存</li>
</ul>
<p>因此，在<code>cmake</code>中指定要链接的动态库的时候，<code>应该将命令写到生成了可执行文件之后</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 添加并指定最终生成的可执行程序名</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 指定可执行程序要链接的动态库名字</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread)</span><br></pre></td></tr></table></figure>

<p>在<code>target_link_libraries(app pthread)</code>中：</p>
<ul>
<li><code>app</code>: 对应的是最终生成的可执行程序的名字</li>
<li><code>pthread</code>：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为<code>libpthread.so</code>，在指定的时候一般会掐头<code>（lib）</code>去尾<code>（.so）</code>。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread calc)</span><br></pre></td></tr></table></figure>

<p>在第六行中，pthread、calc都是可执行程序app要链接的动态库的名字。当可执行程序app生成之后并执行该文件，会提示有如下错误信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./app</span> </span><br><span class="line">./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>在 <code>CMake</code> 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(path)</span><br></pre></td></tr></table></figure>

<p>所以修改之后的CMakeLists.txt文件应该是这样的：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 指定源文件或者动态库对应的头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 指定要链接的动态库的路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 添加并生成一个可执行程序</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 指定要链接的动态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread calc)</span><br></pre></td></tr></table></figure>

<p>通过link_directories指定了动态库的路径之后，在执行生成的可执行程序的时候，就不会出现找不到动态库的问题了。</p>
<p><strong>温馨提示：使用 target_link_libraries 命令就可以链接动态库，也可以链接静态库文件。</strong></p>
<br>

<h3 id="6-日志"><a href="#6-日志" class="headerlink" title="6. 日志"></a>6. 日志</h3><p>在<code>CMake</code>中可以用用户显示一条消息，该命令的名字为<code>message</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(无)</code> ：重要消息</li>
<li><code>STATUS</code> ：非重要消息</li>
<li><code>WARNING</code>：CMake 警告, 会继续执行</li>
<li><code>AUTHOR_WARNING</code>：CMake 警告 (dev), 会继续执行</li>
<li><code>SEND_ERROR</code>：CMake 错误, 继续执行，但是会跳过生成的步骤</li>
<li><code>FATAL_ERROR</code>：CMake 错误, 终止所有处理过程</li>
</ul>
<p><code>CMake</code>的命令行工具会在<code>stdout</code>上显示S<code>TATUS</code>消息，在<code>stderr</code>上显示其他所有消息。<code>CMake</code>的<code>GUI</code>会在它的<code>log</code>区域显示所有消息。</p>
<p><code>CMake</code>警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出一般日志信息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 输出警告信息</span></span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 输出错误信息</span></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="7-变量操作"><a href="#7-变量操作" class="headerlink" title="7. 变量操作"></a>7. 变量操作</h3><h4 id="7-1-追加"><a href="#7-1-追加" class="headerlink" title="7.1 追加"></a>7.1 追加</h4><p>有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过<code>file</code>命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用<code>set</code>命令也可以使用<code>list</code>命令。</p>
<br>

<h5 id="7-1-1-使用set拼接"><a href="#7-1-1-使用set拼接" class="headerlink" title="7.1.1 使用set拼接"></a>7.1.1 使用set拼接</h5><p>如果使用<code>set</code>进行字符串拼接，对应的命令格式如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(变量名<span class="number">1</span> <span class="variable">$&#123;变量名1&#125;</span> <span class="variable">$&#123;变量名2&#125;</span> ...)</span><br></pre></td></tr></table></figure>

<p>关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"><span class="comment"># 追加(拼接)</span></span><br><span class="line"><span class="keyword">set</span>(SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span> <span class="variable">$&#123;TEMP&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<br>

<h5 id="7-1-2-使用list拼接"><a href="#7-1-2-使用list拼接" class="headerlink" title="7.1.2 使用list拼接"></a>7.1.2 使用list拼接</h5><p><code>list</code>命令的功能比<code>set</code>要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，<code>APPEND</code>表示进行数据追加，后边的参数和<code>set</code>就一样了。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>

<br>

<h4 id="7-2-字符串移除"><a href="#7-2-字符串移除" class="headerlink" title="7.2 字符串移除"></a>7.2 字符串移除</h4><p>使用<code>list</code>命令，<code>REMOVE_ITEM</code>表示对数据进行移除</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 移除前日志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 移除 main.cpp</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/main.cpp)</span><br><span class="line"><span class="comment"># 移除后日志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="8-宏定义"><a href="#8-宏定义" class="headerlink" title="8. 宏定义"></a>8. 宏定义</h3><p>在<code>CMake</code>中，对应的命令叫做<code>add_definitions</code>:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-D宏名称)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="comment"># 自定义 DEBUG 宏</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DDEBUG)</span><br><span class="line"><span class="keyword">add_executable</span>(app ./<span class="keyword">test</span>.c)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="9-预定义宏"><a href="#9-预定义宏" class="headerlink" title="9. 预定义宏"></a>9. 预定义宏</h3><p>下面的列表中为大家整理了一些<code>CMake</code>中常用的宏：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>PROJECT_SOURCE_DIR</td>
<td>使用<code>cmake</code>命令后紧跟的目录，一般是工程的根目录</td>
</tr>
<tr>
<td>PROJECT_BINARY_DIR</td>
<td>执行<code>cmake</code>命令的目录</td>
</tr>
<tr>
<td>CMAKE_CURRENT_SOURCE_DIR</td>
<td>当前处理的<code>CMakeLists.txt</code>所在的路径</td>
</tr>
<tr>
<td>CMAKE_CURRENT_BINARY_DIR</td>
<td><code>target</code> 编译目录</td>
</tr>
<tr>
<td>EXECUTABLE_OUTPUT_PATH</td>
<td>重新定义目标二进制可执行文件的存放位置</td>
</tr>
<tr>
<td>LIBRARY_OUTPUT_PATH</td>
<td>重新定义目标链接库文件的存放位置</td>
</tr>
<tr>
<td>PROJECT_NAME</td>
<td>返回通过<code>PROJECT</code>指令定义的项目名称</td>
</tr>
<tr>
<td>CMAKE_BINARY_DIR</td>
<td>项目实际构建路径，假设在<code>build</code>目录进行的构建，那么得到的就是这个目录的路径</td>
</tr>
</tbody></table>
<br>

<h3 id="10-嵌套的CMake"><a href="#10-嵌套的CMake" class="headerlink" title="10. 嵌套的CMake"></a>10. 嵌套的CMake</h3><p>如果项目很大，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果只使用一个CMakeLists.txt，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个CMakeLists.txt文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。</p>
<p>先来看一下下面的这个的目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── calc</span><br><span class="line">│   ├── add.c</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── div.c</span><br><span class="line">│   ├── mult.c</span><br><span class="line">│   └── sub.c</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   ├── calc.h</span><br><span class="line">│   └── sort.h</span><br><span class="line">├── sort</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── insert.c</span><br><span class="line">│   └── select.c</span><br><span class="line">├── test1</span><br><span class="line">│   ├── calc.cpp</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">└── test2</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── sort.c</span><br><span class="line"></span><br><span class="line">6 directories, 15 files</span><br></pre></td></tr></table></figure>

<ul>
<li><code>include 目录</code>：头文件目录</li>
<li><code>calc 目录</code>：目录中的四个源文件对应的加、减、乘、除算法<ul>
<li>对应的头文件是<code>include</code>中的<code>calc.h</code></li>
</ul>
</li>
<li><code>sort 目录</code> ：目录中的两个源文件对应的是插入排序和选择排序算法<ul>
<li>对应的头文件是i<code>nclude</code>中的<code>sort.h</code></li>
</ul>
</li>
<li><code>test1 目录</code>：测试目录，对加、减、乘、除算法进行测试</li>
<li><code>test2 目录</code>：测试目录，对排序算法进行测试</li>
</ul>
<p>可以看到各个源文件目录所需要的<code>CMakeLists.txt</code>文件现在已经添加完毕了。接下来庖丁解牛，我们依次分析一下各个文件中需要添加的内容。</p>
<br>

<h3 id="10-1-节点关系"><a href="#10-1-节点关系" class="headerlink" title="10.1 节点关系"></a>10.1 节点关系</h3><p>众所周知，<code>Linux</code>的目录是树状结构，所以<code>嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。</code>因此，我们需要了解一些关于 <code>CMakeLists.txt</code> 文件变量作用域的一些信息：</p>
<ul>
<li>根节点<code>CMakeLists.txt</code>中的变量全局有效</li>
<li>父节点<code>CMakeLists.txt</code>中的变量可以在子节点中使用</li>
<li>子节点<code>CMakeLists.txt</code>中的变量只能在当前节点中使用</li>
</ul>
<br>

<h3 id="10-2-添加子目录"><a href="#10-2-添加子目录" class="headerlink" title="10.2 添加子目录"></a>10.2 添加子目录</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>source_dir</code>：指定了<code>CMakeLists.txt</code>源文件和代码文件的位置，其实就是指定子目录</li>
<li><code>binary_dir</code>：指定了输出文件的路径，一般不需要指定，忽略即可。</li>
<li><code>EXCLUDE_FROM_ALL</code>：在子路径下的目标默认不会被包含到父路径的<code>ALL</code>目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。</li>
</ul>
<p>通过这种方式<code>CMakeLists.txt</code>文件之间的父子关系就被构建出来了。</p>
<h3 id="10-3-编写CMakeLists-txt文件"><a href="#10-3-编写CMakeLists-txt文件" class="headerlink" title="10.3 编写CMakeLists.txt文件"></a>10.3 编写CMakeLists.txt文件</h3><h4 id="10-3-1-根目录"><a href="#10-3-1-根目录" class="headerlink" title="10.3.1 根目录"></a>10.3.1 根目录</h4><p>根目录中的 <code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(test)</span><br><span class="line"># 定义变量</span><br><span class="line"># 静态库生成的路径</span><br><span class="line">set(LIB_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)</span><br><span class="line"># 测试程序生成的路径</span><br><span class="line">set(EXEC_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/bin)</span><br><span class="line"># 头文件目录</span><br><span class="line">set(HEAD_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)</span><br><span class="line"># 静态库的名字</span><br><span class="line">set(CALC_LIB calc)</span><br><span class="line">set(SORT_LIB sort)</span><br><span class="line"># 可执行程序的名字</span><br><span class="line">set(APP_NAME_1 test1)</span><br><span class="line">set(APP_NAME_2 test2)</span><br><span class="line"># 添加子目录</span><br><span class="line">add_subdirectory(calc)</span><br><span class="line">add_subdirectory(sort)</span><br><span class="line">add_subdirectory(test1)</span><br><span class="line">add_subdirectory(test2)</span><br></pre></td></tr></table></figure>

<p>在根节点对应的文件中主要做了两件事情：定义全局变量和添加子目录。</p>
<ul>
<li>定义的全局变量主要是给子节点使用，目的是为了提高子节点中的<code>CMakeLists.txt</code>文件的可读性和可维护性，避免冗余并降低出差的概率。</li>
<li>一共添加了四个子目录，每个子目录中都有一个<code>CMakeLists.txt</code>文件，这样它们的父子关系就被确定下来了。</li>
</ul>
<h4 id="10-3-2-calc-目录"><a href="#10-3-2-calc-目录" class="headerlink" title="10.3.2 calc 目录"></a>10.3.2 calc 目录</h4><p><code>calc</code> 目录中的 <code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCLIB)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;CALC_LIB&#125;</span> STATIC <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第3行<code>aux_source_directory</code>：搜索当前目录（calc目录）下的所有源文件</li>
<li>第4行<code>include_directories</code>：包含头文件路径，HEAD_PATH是在根节点文件中定义的</li>
<li>第5行<code>set</code>：设置库的生成的路径，LIB_PATH是在根节点文件中定义的</li>
<li>第6行<code>add_library</code>：生成静态库，静态库名字CALC_LIB是在根节点文件中定义的</li>
</ul>
<h4 id="10-3-2-sort-目录"><a href="#10-3-2-sort-目录" class="headerlink" title="10.3.2 sort 目录"></a>10.3.2 sort 目录</h4><p>sort 目录中的 CMakeLists.txt文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCLIB)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;CALC_LIB&#125;</span> SHARED <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第6行<code>add_library</code>：生成动态库，动态库名字SORT_LIB是在根节点文件中定义的</li>
</ul>
<p>这个文件中的内容和<code>calc</code>节点文件中的内容类似，只不过这次生成的是动态库。</p>
<h4 id="10-3-3-test1-目录"><a href="#10-3-3-test1-目录" class="headerlink" title="10.3.3 test1 目录"></a>10.3.3 test1 目录</h4><p>test1 目录中的 CMakeLists.txt文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCTEST)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="variable">$&#123;CALC_LIB&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;EXEC_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME_1&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第4行include_directories：指定头文件路径，HEAD_PATH变量是在根节点文件中定义的</li>
<li>第6行link_libraries：指定可执行程序要链接的静态库，CALC_LIB变量是在根节点文件中定义的</li>
<li>第7行set：指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的</li>
<li>第8行add_executable：生成可执行程序，APP_NAME_1变量是在根节点文件中定义的</li>
</ul>
<p>此处的可执行程序链接的是静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被加载到内存中了。</p>
<h4 id="10-3-4-test2-目录"><a href="#10-3-4-test2-目录" class="headerlink" title="10.3.4 test2 目录"></a>10.3.4 test2 目录</h4><p>test2 目录中的 CMakeLists.txt文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(SORTTEST)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;EXEC_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME_2&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;APP_NAME_2&#125;</span> <span class="variable">$&#123;SORT_LIB&#125;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第四行<code>include_directories</code>：包含头文件路径，HEAD_PATH变量是在根节点文件中定义的</li>
<li>第五行<code>set</code>：指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的</li>
<li>第六行<code>link_directories</code>：指定可执行程序要链接的动态库的路径，LIB_PATH变量是在根节点文件中定义的</li>
<li>第七行<code>add_executable</code>：生成可执行程序，APP_NAME_2变量是在根节点文件中定义的</li>
<li>第八行<code>target_link_libraries</code>：指定可执行程序要链接的动态库的名字</li>
</ul>
<p>在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库。</p>
<p><strong>注意：引用变量要使用{},不要用成()</strong></p>
<ul>
<li>set(EXECUTABLE_OUTPUT_PATH <code>$&#123;EXEC_PATH&#125;</code>) 写成如下就会出错：</li>
<li>set(EXECUTABLE_OUTPUT_PATH <code>$(EXEC_PATH)</code>) 就会出错</li>
</ul>
<br>

<h4 id="10-3-4-构建项目"><a href="#10-3-4-构建项目" class="headerlink" title="10.3.4 构建项目"></a>10.3.4 构建项目</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xuan@DESKTOP-A52B6V9:~/linux/demos/cpro$ cd build/</span><br><span class="line">xuan@DESKTOP-A52B6V9:~/linux/demos/cpro/build$ cmake ..</span><br><span class="line">-- The C compiler identification is GNU 11.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 11.4.0</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc - skipped</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ - skipped</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/xuan/linux/demos/cpro/build</span><br><span class="line"></span><br><span class="line">xuan@DESKTOP-A52B6V9:~/linux/demos/cpro/build$ make</span><br><span class="line">[  8%] Building C object calc/CMakeFiles/calc.dir/add.c.o</span><br><span class="line">[ 16%] Building C object calc/CMakeFiles/calc.dir/div.c.o</span><br><span class="line">[ 25%] Building C object calc/CMakeFiles/calc.dir/mult.c.o</span><br><span class="line">[ 33%] Building C object calc/CMakeFiles/calc.dir/sub.c.o</span><br><span class="line">[ 41%] Linking C static library ../../lib/libcalc.a</span><br><span class="line">[ 41%] Built target calc</span><br><span class="line">[ 50%] Building C object sort/CMakeFiles/sort.dir/insert.c.o</span><br><span class="line">[ 58%] Building C object sort/CMakeFiles/sort.dir/select.c.o</span><br><span class="line">[ 66%] Linking C shared library ../../lib/libsort.so</span><br><span class="line">[ 66%] Built target sort</span><br><span class="line">[ 75%] Building C object test2/CMakeFiles/test2.dir/sort.c.o</span><br><span class="line">[ 83%] Linking C executable ../../bin/test2</span><br><span class="line">[ 83%] Built target test2</span><br><span class="line">[ 91%] Building C object test1/CMakeFiles/test1.dir/calc.c.o</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Linking C executable ../../bin/test1</span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target test1</span></span><br></pre></td></tr></table></figure>

<p>通过上述<code>log</code>可以得到如下信息：</p>
<ul>
<li>在项目根目录的<code>lib目录</code>中生成了静态库<code>libcalc.a</code></li>
<li>在项目根目录的<code>lib目录</code>中生成了动态库<code>libsort.so</code></li>
<li>在项目根目录的<code>bin目录</code>中生成了可执行程序<code>test1</code></li>
<li>在项目根目录的<code>bin目录</code>中生成了可执行程序<code>test2</code></li>
</ul>
<p>以下是生成的树状图：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree bin/ lib/</span></span><br><span class="line">bin/</span><br><span class="line">├── test1</span><br><span class="line">└── test2</span><br><span class="line">lib/</span><br><span class="line">├── libcalc.a</span><br><span class="line">└── libsort.so</span><br></pre></td></tr></table></figure>

<ul>
<li>在项目中，如果将程序中的某个模块制作成了动态库或者静态库并且在<code>CMakeLists.txt</code> 中指定了库的输出目录，而后其它模块又需要加载这个生成的库文件，此时直接使用就可以了。</li>
<li>如果没有指定库的输出路径或者需要直接加载外部提供的库文件，此时就需要使用<code>link_directories($&#123;LIB_PATH&#125;)</code>将库文件路径指定出来,然后链接库的名字<code>link_libraries($&#123;CALC_LIB&#125;)</code>。</li>
</ul>
<br>

<h3 id="11-流程控制"><a href="#11-流程控制" class="headerlink" title="11. 流程控制"></a>11. 流程控制</h3><h4 id="11-1-条件判断"><a href="#11-1-条件判断" class="headerlink" title="11.1 条件判断"></a>11.1 条件判断</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;condition&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">elseif</span>(&lt;condition&gt;) <span class="comment"># 可选快, 可以重复</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">else</span>()              <span class="comment"># 可选快</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h5 id="11-1-1-基本表达式"><a href="#11-1-1-基本表达式" class="headerlink" title="11.1.1 基本表达式"></a>11.1.1 基本表达式</h5><ul>
<li><p><code>if(&lt;expression&gt;)</code>: <code>expression</code> 有以下三种情况：常量、变量、字符串。</p>
<ul>
<li>如果是<code>1</code>, <code>ON</code>, <code>YES</code>, <code>TRUE</code>, <code>Y</code>, <code>非零值</code>，<code>非空字符串</code>时，条件判断返回<code>True</code></li>
<li>如果是 <code>0</code>, <code>OFF</code>, <code>NO</code>, <code>FALSE</code>, <code>N</code>, <code>IGNORE</code>, <code>NOTFOUND</code>，<code>空字符串</code>时，条件判断返回<code>False</code></li>
</ul>
</li>
</ul>
<br>

<h5 id="11-1-2-逻辑判断"><a href="#11-1-2-逻辑判断" class="headerlink" title="11.1.2 逻辑判断"></a>11.1.2 逻辑判断</h5><ul>
<li>if(NOT <condition>)</li>
<li>if(<cond1> AND <cond2>)</li>
<li>if(<cond1> OR <cond2>)</li>
</ul>
<br>

<h5 id="11-1-3-比较"><a href="#11-1-3-比较" class="headerlink" title="11.1.3 比较"></a>11.1.3 比较</h5><ul>
<li><code>if(&lt;variable|string&gt; &lt;COMMAND&gt; &lt;variable|string&gt;)</code></li>
<li>&lt;<code>COMMAND</code>&gt;为如下值的解释：<ul>
<li><code>LESS</code>：如果左侧数值&#x2F;字符串<code>小于</code>右侧，返回<code>True</code></li>
<li><code>GREATER</code>：如果左侧数值&#x2F;字符串<code>大于</code>右侧，返回<code>True</code></li>
<li><code>EQUAL</code>：如果左侧数值&#x2F;字符串<code>等于</code>右侧，返回<code>True</code></li>
<li><code>LESS_EQUAL</code>：如果左侧数值&#x2F;字符串<code>小于等于</code>右侧，返回<code>True</code></li>
<li><code>GREATER_EQUAL</code>：如果左侧数值&#x2F;字符串<code>大于等于</code>右侧，返回<code>True</code></li>
</ul>
</li>
</ul>
<br>

<h5 id="11-1-4-文件操作"><a href="#11-1-4-文件操作" class="headerlink" title="11.1.4 文件操作"></a>11.1.4 文件操作</h5><p><strong>存在&#x2F;是</strong>返回<code>True</code>，<strong>不存在&#x2F;否</strong>返回<code>False</code></p>
<ul>
<li>判断文件或者目录是否存在：<code>if(EXISTS path-to-file-or-directory)</code></li>
<li>判断是不是目录：<code>if(IS_DIRECTORY path)</code><ul>
<li>此处目录的 <code>path</code> 必须是绝对路径</li>
</ul>
</li>
<li>判断是不是软连接：<code>if(IS_SYMLINK file-name)</code><ul>
<li>此处的 <code>file-name</code> 对应的路径必须是绝对路径</li>
<li>软链接相当于 <code>Windows</code> 里的快捷方式</li>
</ul>
</li>
<li>判断是不是绝对路径：<code>if(IS_ABSOLUTE path)</code><ul>
<li>如果绝对路径是Linux，该路径需要从根目录开始描述</li>
<li>如果绝对路径是Windows，该路径需要从盘符开始描述</li>
</ul>
</li>
</ul>
<br>

<h5 id="11-1-5-其他"><a href="#11-1-5-其他" class="headerlink" title="11.1.5 其他"></a>11.1.5 其他</h5><ul>
<li>判断某个元素是否在列表中：<code>if(&lt;variable|string&gt; IN_LIST &lt;variable&gt;)</code></li>
<li>比较两个路径是否相等：<code>if(&lt;variable|string&gt; PATH_EQUAL &lt;variable|string&gt;)</code></li>
</ul>
<br>

<h4 id="11-2-循环"><a href="#11-2-循环" class="headerlink" title="11.2 循环"></a>11.2 循环</h4><p>在 <code>CMake</code> 中循环有两种方式，分别是：<code>foreach</code>和<code>while</code>。</p>
<h5 id="11-2-1-foreach"><a href="#11-2-1-foreach" class="headerlink" title="11.2.1 foreach"></a>11.2.1 foreach</h5><p>使用 foreach 进行循环，语法格式如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; &lt;items&gt;)</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>foreach(&lt;loop_var&gt; RANGE &lt;stop&gt;)</code><ul>
<li><code>RANGE</code>：关键字，表示要遍历范围</li>
<li><code>stop</code>：这是一个正整数，表示范围的结束值，在遍历的时候从 0 开始，最大值为 <code>stop</code>。</li>
<li><code>loop_var</code>：存储每次循环取出的值</li>
</ul>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>上面例子输出<code>0~10</code></p>
<br>

<ul>
<li><code>foreach(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;])</code><ul>
<li><code>RANGE</code>：关键字，表示要遍历范围</li>
<li><code>start</code>：这是一个正整数，表示范围的起始值，也就是说最小值为 <code>start</code></li>
<li><code>stop</code>：这是一个正整数，表示范围的结束值，也就是说最大值为 <code>stop</code></li>
<li><code>step</code>：控制每次遍历的时候以怎样的步长增长，默认为<code>1</code>，可以不设置<br>  -<code>loop_var</code>：存储每次循环取出的值</li>
</ul>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">10</span> <span class="number">30</span> <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>上面例子输出<code>10~30</code>,从<code>10</code>开始,每次增长<code>2</code>。</p>
<br>

<ul>
<li><code>foreach(&lt;loop_var&gt; IN [LISTS [&lt;lists&gt;]] [ITEMS [&lt;items&gt;]])</code><ul>
<li><code>IN</code>：关键字，表示在 <code>xxx</code> 里边</li>
<li><code>LISTS</code>：关键字，对应的是列表<code>list</code>，通过<code>set</code>、<code>list</code>可以获得</li>
<li><code>ITEMS</code>：关键字，对应的也是列表</li>
<li><code>loop_var</code>：存储每次循环取出的值</li>
</ul>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 创建 list</span></span><br><span class="line"><span class="keyword">set</span>(WORD a b c d)</span><br><span class="line"><span class="keyword">set</span>(NAME ace sabo luffy)</span><br><span class="line"><span class="comment"># 遍历 list</span></span><br><span class="line"><span class="keyword">foreach</span>(item IN LISTS WORD NAME)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，创建了两个 <code>list</code> 列表，在遍历的时候对它们两个都进行了遍历（可以根据实际需求选择同时遍历多个或者只遍历一个）</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(WORD a b c <span class="string">&quot;d e f&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(NAME ace sabo luffy)</span><br><span class="line"><span class="keyword">foreach</span>(item IN ITEMS <span class="variable">$&#123;WORD&#125;</span> <span class="variable">$&#123;NAME&#125;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，遍历过程中将关键字<code>LISTS</code>改成了<code>ITEMS</code>，后边跟的还是一个或者多个列表，只不过此时需要通过<code>$&#123;&#125;</code>将列表中的值取出。其输出的信息和上一个例子是一样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: a</span><br><span class="line">-- 当前遍历的值为: b</span><br><span class="line">-- 当前遍历的值为: c</span><br><span class="line">-- 当前遍历的值为: d e f</span><br><span class="line">-- 当前遍历的值为: ace</span><br><span class="line">-- 当前遍历的值为: sabo</span><br><span class="line">-- 当前遍历的值为: luffy</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure>

<p>小细节：在通过 set 组织列表的时候，如果某个字符串中有空格，可以通过双引号将其包裹起来，具体的操作方法可以参考上面的例子。</p>
<br>

<ul>
<li><code>foreach(&lt;loop_var&gt;... IN ZIP_LISTS &lt;lists&gt;)</code><ul>
<li><code>loop_var</code>：存储每次循环取出的值，可以根据要遍历的列表的数量指定多个变量，用于存储对应的列表当前取出的那个值。<ul>
<li>如果指定了多个变量名，它们的数量应该和列表的数量相等</li>
<li>如果只给出了一个 <code>loop_var</code>，那么它将一系列的 <code>loop_var_N</code> 变量来存储对应列表中的当前项，也就是说 <code>loop_var_0</code> 对应第一个列表，<code>loop_var_1</code> 对应第二个列表，以此类推……</li>
<li>如果遍历的多个列表中一个列表较短，当它遍历完成之后将不会再参与后续的遍历（因为其它列表还没有遍历完）。</li>
</ul>
</li>
<li><code>IN</code>：关键字，表示在 <code>xxx</code> 里边</li>
<li><code>ZIP_LISTS</code>：关键字，对应的是列表<code>list</code>，通过<code>set</code> 、<code>list</code>可以获得</li>
</ul>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 通过list给列表添加数据</span></span><br><span class="line"><span class="keyword">list</span>(APPEND WORD hello world <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">list</span>(APPEND NAME ace sabo luffy zoro sanji)</span><br><span class="line"><span class="comment"># 遍历列表</span></span><br><span class="line"><span class="keyword">foreach</span>(item1 item2 IN ZIP_LISTS WORD NAME)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: item1 = $&#123;item1&#125;, item2=$&#123;item2&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;=============================&quot;</span>)</span><br><span class="line"><span class="comment"># 遍历列表</span></span><br><span class="line"><span class="keyword">foreach</span>(item  IN ZIP_LISTS WORD NAME)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: item1 = $&#123;item_0&#125;, item2=$&#123;item_1&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>在这个例子中关于列表数据的添加是通过<code>list</code>来实现的。在遍历列表的时候一共使用了两种方式，一种提供了多个变量来存储当前列表中的值，另一种只有一个变量，但是实际取值的时候需要通过<code>变量名_0、变量名_1、变量名_N</code> 的方式来操作，<code>注意事项：第一个列表对应的编号是0，第一个列表对应的编号是0，第一个列表对应的编号是0。</code></p>
<p>上面的例子输出的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: item1 = hello, item2=ace</span><br><span class="line">-- 当前遍历的值为: item1 = world, item2=sabo</span><br><span class="line">-- 当前遍历的值为: item1 = hello world, item2=luffy</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=zoro</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=sanji</span><br><span class="line">=============================</span><br><span class="line">-- 当前遍历的值为: item1 = hello, item2=ace</span><br><span class="line">-- 当前遍历的值为: item1 = world, item2=sabo</span><br><span class="line">-- 当前遍历的值为: item1 = hello world, item2=luffy</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=zoro</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=sanji</span><br><span class="line">-- Configuring done (0.0s)</span><br><span class="line">-- Generating done (0.0s)</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure>

<br>

<h5 id="11-2-2-while"><a href="#11-2-2-while" class="headerlink" title="11.2.2 while"></a>11.2.2 while</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(&lt;condition&gt;)</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure>
<p><code>while</code> 比较简单就不做描述了。</p>
<br>

<h3 id="12-cmake设置编译器"><a href="#12-cmake设置编译器" class="headerlink" title="12. cmake设置编译器"></a>12. cmake设置编译器</h3><h4 id="12-1-命令行"><a href="#12-1-命令行" class="headerlink" title="12.1 命令行"></a>12.1 命令行</h4><p>在命令行中指定编译器，你可以在调用 <code>cmake</code> 命令时使用 <code>-DCMAKE_C_COMPILER</code> 和 <code>-DCMAKE_CXX_COMPILER</code> 选项来分别为<code>C</code>和<code>C++</code>设置编译器。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ /path/to/source</span><br></pre></td></tr></table></figure>

<br>

<h4 id="12-2-CMakeLists-txt"><a href="#12-2-CMakeLists-txt" class="headerlink" title="12.2 CMakeLists.txt"></a>12.2 CMakeLists.txt</h4><p>在项目的 <code>CMakeLists.txt</code> 文件中，你可以使用 <code>set</code> 命令来指定编译器：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER /user/bin/gcc)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER /user/bin/g++)</span><br></pre></td></tr></table></figure>

<br>

<h4 id="12-3-工具链文件"><a href="#12-3-工具链文件" class="headerlink" title="12.3 工具链文件"></a>12.3 工具链文件</h4><p><code>CMake</code>允许使用所谓的“工具链文件”（toolchain file）来指定编译器和工具链设置。这在跨平台构建时非常有用。工具链文件是一个普通的<code>CMake</code>脚本，它设置了构建系统所需的编译器和工具链选项。例如，创建一个名为 <code>toolchain.cmake</code> 的文件，并在其中设置编译器：</p>
<pre><code>set(CMAKE_C_COMPILER gcc)
set(CMAKE_CXX_COMPILER g++)
</code></pre>
<p>然后在调用 <code>cmake</code> 命令时指定工具链文件：</p>
<pre><code>cmake -DCMAKE_TOOLCHAIN_FILE=path/to/toolchain.cmake /path/to/source
</code></pre>
<p>请记住，一旦<code>CMake</code>缓存生成，更改编译器的设置就需要清理<code>CMake</code>缓存并重新运行<code>CMake</code>配置。这是因为<code>CMake</code>在第一次运行时会将编译器和工具链的信息缓存起来，以便后续构建使用。</p>
]]></content>
      <categories>
        <category>自动编译工具工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt5学习笔记</title>
    <url>/2024/04/30/Qt5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><strong>Qt官方下载地址</strong>: <a href="https://download.qt.io/archive/qt/">https://download.qt.io/archive/qt/</a></li>
<li><strong>参考教程文档</strong>: <a href="https://subingwen.cn/qt/qt-primer/">https://subingwen.cn/qt/qt-primer/</a></li>
</ul>
<br>

<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="打印问题"><a href="#打印问题" class="headerlink" title="打印问题"></a>打印问题</h3><p><strong>问题现象：</strong></p>
<ul>
<li>在Qt Creater中，使用<code>qDebug()</code>打印信息时，在调试界面中，<code>qDebug()</code>的输出信息会显示在调试终端，当直接运行<code>.exe</code>文件时，<code>qDebug()</code>的输出信息会丢失。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;这是测试打印程序&quot;</span> &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<ul>
<li>在<code>qt.pro</code>工程文件中中，添加如下代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CONFIG += c++<span class="number">17</span> console			<span class="comment">//添加console</span></span><br></pre></td></tr></table></figure></li>
<li>勾选以下选项：</li>
</ul>
<p><img src="/../pictures/qt_terminal%E9%85%8D%E7%BD%AE.png" alt="qt_terminal配置"></p>
<p><strong>总结：</strong></p>
<ul>
<li>需要重新编译代码，<code>.exe</code>文件更新后生效。</li>
<li>再次编译运行时,会弹出<code>terminal</code>。</li>
</ul>
]]></content>
      <categories>
        <category>图形界面</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
</search>
