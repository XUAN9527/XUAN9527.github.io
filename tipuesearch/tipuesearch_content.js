var tipuesearch = {"pages":[{"title":"CMake学习笔记","url":"/2024/05/08/CMake学习笔记/","text":"CMake学习教程 [参考资料1] : https://subingwen.cn/cmake/CMake-primer [参考资料2] : https://subingwen.cn/cmake/CMake-advanced/ [参考资料3] : https://zhuanlan.zhihu.com/p/534439206 编写一个简单的CMakeLists.txt文件1. 示例文件的目录结构如下：12345678$ tree.├── add.c├── div.c├── head.h├── main.c├── mult.c└── sub.c 2. 添加 CMakeLists.txt 文件在上述源文件所在目录下添加一个新文件 CMakeLists.txt，文件内容如下： 123cmake_minimum_required(VERSION 3.0)project(CALC)add_executable(app add.c div.c main.c mult.c sub.c) cmake_minimum_required：指定使用的 cmake 的最低版本。 可选，非必须，如果不加可能会有警告。 project：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。 add_executable：定义工程会生成一个可执行程序。 1add_executable(可执行程序名 源文件名称) 这里的可执行程序名和project中的项目名没有任何关系 源文件名可以是一个也可以是多个，如有多个可用空格或;间隔 1234# 样式1add_executable(app add.c div.c main.c mult.c sub.c)# 样式2add_executable(app add.c;div.c;main.c;mult.c;sub.c) 3. 执行CMake命令12# cmake 命令原型$ cmake CMakeLists.txt 文件所在路径 执行示例 (当前CMakeLists.txt路径) ： 1$ cmake . 当执行cmake命令之后，CMakeLists.txt 中的命令就会被执行，所以一定要注意给cmake命令指定路径的时候一定不能出错。 执行命令之后，看一下源文件所在目录中是否多了一些文件： 12345678910111213$ tree -L 1.├── add.c├── CMakeCache.txt # new add file├── CMakeFiles # new add dir├── cmake_install.cmake # new add file├── CMakeLists.txt├── div.c├── head.h├── main.c├── Makefile # new add file├── mult.c└── sub.c 我们可以看到在对应的目录下生成了一个makefile文件，此时再执行make命令，就可以对项目进行构建得到所需的可执行程序了。 4. 头文件及指定宏 CMakeLists.txt 示例代码文件：12345678cmake_minimum_required(VERSION 3.0)project(CALC)set(CMAKE_CXX_STANDARD 11)set(HOME /home/robin/Linux/calc)set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin/)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)add_executable(app $&#123;SRC_LIST&#125;) 4.1 通过参数-std=c++11指定出要使用c++11标准编译程序,对应宏DCMAKE_CXX_STANDARD:12# 增加-std=c++11set(CMAKE_CXX_STANDARD 11) 12# 增加-std=c++11cmake (CMakeLists.txt文件路径) -DCMAKE_CXX_STANDARD=11 4.2 指定输出的路径(EXECUTABLE_OUTPUT_PATH)：12set(HOME /home/robin/Linux/Sort)set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin) 如果这个路径中的子目录不存在，会自动生成，无需自己手动创建。 4.3 头文件的路径(include_directories)1include_directories(headpath) 其中，第六行指定就是头文件的路径，PROJECT_SOURCE_DIR宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。 4.4 搜索文件(aux_source_directory) aux_source_directory(&lt; dir &gt; &lt; variable &gt;) 示例： 1aux_source_directory($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src SRC_LIST) file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)示例： 12file(GLOB MAIN_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)file(GLOB MAIN_HEAD $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/*.h) CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径 5. 制作动态库或静态库有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。 5.1 静态库：5.1.1 cmake生成规则：1add_library(库名称 STATIC 源文件1 [源文件2] ...) 在Linux中，静态库名字分为三部分：lib + 库名字 + .a，示例：12345cmake_minimum_required(VERSION 3.0)project(CALC)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)file(GLOB SRC_LIST &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;)add_library(calc STATIC $&#123;SRC_LIST&#125;) 这样最终就会生成对应的静态库文件 libcalc.a 5.1.2 gcc生成规则：1gcc -c add.c div.c mult.c sub.c -I ./include/ 生成 .o 编译文件 1234567891011121314# 查看目录中的文件$ tree.├── add.c├── add.o # 目标文件├── div.c├── div.o # 目标文件├── include│ └── head.h├── main.c├── mult.c├── mult.o # 目标文件├── sub.c└── sub.o # 目标文件 将生成的目标文件通过 ar工具打包生成静态库 123456789101112131415161718# 将生成的目标文件 .o 打包成静态库$ ar rcs libcalc.a add.o div.o mult.o sub.o #在同一个目录中可以写成 *.o# 查看目录中的文件$ tree.├── add.c├── add.o├── div.c├── div.o├── include│ └── `head.h ===&gt; 和静态库一并发布├── `libcalc.a ===&gt; 生成的静态库├── main.c├── mult.c├── mult.o├── sub.c└── sub.o 将生成的的静态库 libcalc.a和库对应的头文件head.h一并发布给使用者就可以了。 123# 3. 发布静态库 1. head.h =&gt; 函数声明 2. libcalc.a =&gt; 函数定义(二进制格式) 5.1.3 gcc静态库的使用:12345678# 首先拿到了发布的静态库 `head.h` 和 `libcalc.a` # 将静态库, 头文件, 测试程序放到一个目录中准备进行测试.├── head.h # 函数声明├── libcalc.a # 函数定义（二进制格式）└── main.c # 函数测试 编译测试程序, 得到可执行文件。 1234567891011121314# 编译的时候指定库信息 -I: 指定头文件所在的目录(相对或者绝对路径) -L: 指定库所在的目录(相对或者绝对路径) -l: 指定库的名字, 掐头(lib)去尾(.a) ==&gt; calc# -L -l, 参数和参数值之间可以有空格, 也可以没有 -L./ -lcalc$ gcc main.c -o app -I./ -L./ -lcalc# 查看目录信息, 发现可执行程序已经生成了$ tree.├── app # 生成的可执行程序├── head.h├── libcalc.a└── main.c 5.2 动态库：5.2.1 cmake生成规则：1add_library(库名称 SHARED 源文件1 [源文件2] ...) 在Linux中，动态库名字分为三部分：lib + 库名字 + .so ，示例：1add_library(calc SHARED $&#123;SRC_LIST&#125;) 这样最终就会生成对应的动态库文件 libcalc.so 5.1.2 gcc生成规则： 生成动态链接库是直接使用gcc命令并且需要添加-fPIC(-fpic) 以及-shared 参数。 -fPIC 或 -fpic 参数的作用是使得 gcc 生成的代码是与位置无关的，也就是使用相对位置。 -shared参数的作用是告诉编译器生成一个动态链接库。 12# 1. 将.c汇编得到.o, 需要额外的参数 -fpic/-fPIC$ gcc -c -fpic add.c div.c mult.c sub.c -I ./include/ 生成 .o 编译文件 1234567891011121314# 查看目录文件信息, 检查是否生成了目标文件$ tree.├── add.c├── add.o # 生成的目标文件├── div.c├── div.o # 生成的目标文件├── include│ └── head.h├── main.c├── mult.c├── mult.o # 生成的目标文件├── sub.c└── sub.o # 生成的目标文件 使用gcc将得到的目标文件打包生成动态库, 需要使用参数 -shared 123456789101112131415161718# 2. 将得到 .o 打包成动态库, 使用gcc , 参数 -shared$ gcc -shared add.o div.o mult.o sub.o -o libcalc.so # 检查目录中是否生成了动态库$ tree.├── add.c├── add.o├── div.c├── div.o├── include│ └── `head.h ===&gt; 和动态库一起发布├── `libcalc.so ===&gt; 生成的动态库├── main.c├── mult.c├── mult.o├── sub.c└── sub.o 将生成的的动态库 libcalc.so和库对应的头文件head.h一并发布给使用者就可以了。 123# 发布库文件和头文件 1. head.h 2. libcalc.so 5.1.3 gcc静态库的使用:123456789# 1. 拿到发布的动态库 `head.h libcalc.so# 2. 基于头文件编写测试程序, 测试动态库中提供的接口是否可用 `main.c`# 示例目录:.├── head.h ==&gt; 函数声明├── libcalc.so ==&gt; 函数定义└── main.c ==&gt; 函数测试 编译测试程序, 得到可执行文件。 1234567891011121314# 在编译的时候指定动态库相关的信息: 头文件路径-I 库的路径 -L, 库的名字 -l$ gcc main.c -o app -I./ -L./ -lcalc# 查看是否生成了可执行程序$ tree.├── app # 生成的可执行程序├── head.h├── libcalc.so└── main.c# 执行生成的可执行程序, 错误提示 ==&gt; 可执行程序执行的时候找不到动态库$ ./app ./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory 修改解决动态库链接编译问题 方案 1: 将库路径添加到环境变量LD_LIBRARY_PATH中 找到相关的配置文件 用户级别: ~&#x2F;.bashrc —&gt; 设置对当前用户有效 系统级别: &#x2F;etc&#x2F;profile —&gt; 设置对所有用户有效 使用 vim 打开配置文件, 在文件最后添加这样一句话 12# 自己把路径写进去就行了export LD_LIBRARY_PATH =$LD_LIBRARY_PATH :动态库的绝对路径 让修改的配置文件生效 修改了用户级别的配置文件, 关闭当前终端, 打开一个新的终端配置就生效了 修改了系统级别的配置文件, 注销或关闭系统, 再开机配置就生效了 不想执行上边的操作, 可以执行一个命令让配置重新被加载 1234# 修改的是哪一个就执行对应的那个命令# source 可以简写为一个 . , 作用是让文件内容被重新加载$ source ~/.bashrc (. ~/.bashrc)$ source /etc/profile (. /etc/profile) 方案 2: 更新 &#x2F;etc&#x2F;ld.so.cache 文件 找到动态库所在的绝对路径（不包括库的名字）比如：&#x2F;home&#x2F;robin&#x2F;Library&#x2F; 使用vim 修改 &#x2F;etc&#x2F;ld.so.conf 这个文件, 将上边的路径添加到文件中(独自占一行) 1234# 1. 打开文件$ sudo vim /etc/ld.so.conf# 2. 添加动态库路径, 并保存退出 更新 &#x2F;etc&#x2F;ld.so.conf中的数据到 &#x2F;etc&#x2F;ld.so.cache 中 12# 必须使用管理员权限执行这个命令$ sudo ldconfig 方案 3: 拷贝动态库文件到系统库目录 &#x2F;lib&#x2F; 或者 &#x2F;usr&#x2F;lib 中 (或者将库的软链接文件放进去) 12345# 库拷贝sudo cp /xxx/xxx/libxxx.so /usr/lib# 创建软连接sudo ln -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so 验证执行命令： 123456789# 语法:$ ldd 可执行程序名# 举例:$ ldd app linux-vdso.so.1 =&gt; (0x00007ffe8fbd6000) libcalc.so =&gt; /home/robin/Linux/3Day/calc/test/libcalc.so (0x00007f5d85dd4000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5d85a0a000) /lib64/ld-linux-x86-64.so.2 (0x00007f5d85fd6000) ==&gt; 动态链接器, 操作系统提供 5.3 指定输出的路径： 方式1 - 适用于动态库 1set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib) 方式2 - 都适用 12# 设置动态库/静态库生成路径set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib) 5.4 包含库文件：5.4.1 链接静态库：123456src├── add.cpp├── div.cpp├── main.cpp├── mult.cpp└── sub.cpp 现在我们把上面src目录中的add.cpp、div.cpp、mult.cpp、sub.cpp编译成一个静态库文件libcalc.a。通过命令制作并使用静态链接库。 测试目录结构如下： 123456789101112$ tree .├── build├── CMakeLists.txt├── include│ └── head.h├── lib│ └── libcalc.a # 制作出的静态库的名字└── src └── main.cpp4 directories, 4 files 在cmake中，链接静态库的命令如下： 1link_libraries(&lt;static lib&gt; [&lt;static lib&gt;...]) 参数1：指定出要链接的静态库的名字 可以是全名 libxxx.a 也可以是掐头（lib）去尾（.a）之后的名字 xxx 参数2-N：要链接的其它静态库的名字 如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来： 1link_directories(&lt;lib path&gt;) 这样，修改之后的CMakeLists.txt文件内容如下: 1234567891011cmake_minimum_required(VERSION 3.0)project(CALC)# 搜索指定目录下源文件file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)# 包含头文件路径include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)# 包含静态库路径link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)# 链接静态库link_libraries(calc)add_executable(app $&#123;SRC_LIST&#125;) 5.4.2 链接动态库：动态库的链接和静态库是完全不同的： 静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。 动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存 因此，在cmake中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后： 1234567cmake_minimum_required(VERSION 3.0)project(TEST)file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)# 添加并指定最终生成的可执行程序名add_executable(app $&#123;SRC_LIST&#125;)# 指定可执行程序要链接的动态库名字target_link_libraries(app pthread) 在target_link_libraries(app pthread)中： app: 对应的是最终生成的可执行程序的名字 pthread：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为libpthread.so，在指定的时候一般会掐头（lib）去尾（.so）。 123456cmake_minimum_required(VERSION 3.0)project(TEST)file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)add_executable(app $&#123;SRC_LIST&#125;)target_link_libraries(app pthread calc) 在第六行中，pthread、calc都是可执行程序app要链接的动态库的名字。当可执行程序app生成之后并执行该文件，会提示有如下错误信息： 12$ ./app ./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory 在 CMake 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令： 1link_directories(path) 所以修改之后的CMakeLists.txt文件应该是这样的： 1234567891011cmake_minimum_required(VERSION 3.0)project(TEST)file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)# 指定源文件或者动态库对应的头文件路径include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)# 指定要链接的动态库的路径link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)# 添加并生成一个可执行程序add_executable(app $&#123;SRC_LIST&#125;)# 指定要链接的动态库target_link_libraries(app pthread calc) 通过link_directories指定了动态库的路径之后，在执行生成的可执行程序的时候，就不会出现找不到动态库的问题了。 温馨提示：使用 target_link_libraries 命令就可以链接动态库，也可以链接静态库文件。 6. 日志在CMake中可以用用户显示一条消息，该命令的名字为message： 1message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] &quot;message to display&quot; ...) (无) ：重要消息 STATUS ：非重要消息 WARNING：CMake 警告, 会继续执行 AUTHOR_WARNING：CMake 警告 (dev), 会继续执行 SEND_ERROR：CMake 错误, 继续执行，但是会跳过生成的步骤 FATAL_ERROR：CMake 错误, 终止所有处理过程 CMake的命令行工具会在stdout上显示STATUS消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。 CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。 123456# 输出一般日志信息message(STATUS &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)# 输出警告信息message(WARNING &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)# 输出错误信息message(FATAL_ERROR &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;) 7. 变量操作7.1 追加有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过file命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用set命令也可以使用list命令。 7.1.1 使用set拼接如果使用set进行字符串拼接，对应的命令格式如下： 1set(变量名1 $&#123;变量名1&#125; $&#123;变量名2&#125; ...) 关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。 12345678cmake_minimum_required(VERSION 3.0)project(TEST)set(TEMP &quot;hello,world&quot;)file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/src1/*.cpp)file(GLOB SRC_2 $&#123;PROJECT_SOURCE_DIR&#125;/src2/*.cpp)# 追加(拼接)set(SRC_1 $&#123;SRC_1&#125; $&#123;SRC_2&#125; $&#123;TEMP&#125;)message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;) 7.1.2 使用list拼接list命令的功能比set要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，APPEND表示进行数据追加，后边的参数和set就一样了。 1list(APPEND &lt;list&gt; [&lt;element&gt; ...]) 7.2 字符串移除使用list命令，REMOVE_ITEM表示对数据进行移除 1list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...]) 例子： 12345678910cmake_minimum_required(VERSION 3.0)project(TEST)set(TEMP &quot;hello,world&quot;)file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/*.cpp)# 移除前日志message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;)# 移除 main.cpplist(REMOVE_ITEM SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/main.cpp)# 移除后日志message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;) 8. 宏定义在CMake中，对应的命令叫做add_definitions: 1add_definitions(-D宏名称) 例子： 12345cmake_minimum_required(VERSION 3.0)project(TEST)# 自定义 DEBUG 宏add_definitions(-DDEBUG)add_executable(app ./test.c) 9. 预定义宏下面的列表中为大家整理了一些CMake中常用的宏： 宏 功能 PROJECT_SOURCE_DIR 使用cmake命令后紧跟的目录，一般是工程的根目录 PROJECT_BINARY_DIR 执行cmake命令的目录 CMAKE_CURRENT_SOURCE_DIR 当前处理的CMakeLists.txt所在的路径 CMAKE_CURRENT_BINARY_DIR target 编译目录 EXECUTABLE_OUTPUT_PATH 重新定义目标二进制可执行文件的存放位置 LIBRARY_OUTPUT_PATH 重新定义目标链接库文件的存放位置 PROJECT_NAME 返回通过PROJECT指令定义的项目名称 CMAKE_BINARY_DIR 项目实际构建路径，假设在build目录进行的构建，那么得到的就是这个目录的路径 10. 嵌套的CMake如果项目很大，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果只使用一个CMakeLists.txt，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个CMakeLists.txt文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。 先来看一下下面的这个的目录结构： 12345678910111213141516171819202122232425$ tree.├── build├── calc│ ├── add.c│ ├── CMakeLists.txt│ ├── div.c│ ├── mult.c│ └── sub.c├── CMakeLists.txt├── include│ ├── calc.h│ └── sort.h├── sort│ ├── CMakeLists.txt│ ├── insert.c│ └── select.c├── test1│ ├── calc.cpp│ └── CMakeLists.txt└── test2 ├── CMakeLists.txt └── sort.c6 directories, 15 files include 目录：头文件目录 calc 目录：目录中的四个源文件对应的加、减、乘、除算法 对应的头文件是include中的calc.h sort 目录 ：目录中的两个源文件对应的是插入排序和选择排序算法 对应的头文件是include中的sort.h test1 目录：测试目录，对加、减、乘、除算法进行测试 test2 目录：测试目录，对排序算法进行测试 可以看到各个源文件目录所需要的CMakeLists.txt文件现在已经添加完毕了。接下来庖丁解牛，我们依次分析一下各个文件中需要添加的内容。 10.1 节点关系众所周知，Linux的目录是树状结构，所以嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。因此，我们需要了解一些关于 CMakeLists.txt 文件变量作用域的一些信息： 根节点CMakeLists.txt中的变量全局有效 父节点CMakeLists.txt中的变量可以在子节点中使用 子节点CMakeLists.txt中的变量只能在当前节点中使用 10.2 添加子目录1add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) source_dir：指定了CMakeLists.txt源文件和代码文件的位置，其实就是指定子目录 binary_dir：指定了输出文件的路径，一般不需要指定，忽略即可。 EXCLUDE_FROM_ALL：在子路径下的目标默认不会被包含到父路径的ALL目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。 通过这种方式CMakeLists.txt文件之间的父子关系就被构建出来了。 10.3 编写CMakeLists.txt文件10.3.1 根目录根目录中的 CMakeLists.txt文件内容如下： 1234567891011121314151617181920cmake_minimum_required(VERSION 3.0)project(test)# 定义变量# 静态库生成的路径set(LIB_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)# 测试程序生成的路径set(EXEC_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/bin)# 头文件目录set(HEAD_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)# 静态库的名字set(CALC_LIB calc)set(SORT_LIB sort)# 可执行程序的名字set(APP_NAME_1 test1)set(APP_NAME_2 test2)# 添加子目录add_subdirectory(calc)add_subdirectory(sort)add_subdirectory(test1)add_subdirectory(test2) 在根节点对应的文件中主要做了两件事情：定义全局变量和添加子目录。 定义的全局变量主要是给子节点使用，目的是为了提高子节点中的CMakeLists.txt文件的可读性和可维护性，避免冗余并降低出差的概率。 一共添加了四个子目录，每个子目录中都有一个CMakeLists.txt文件，这样它们的父子关系就被确定下来了。 10.3.2 calc 目录calc 目录中的 CMakeLists.txt文件内容如下： 123456cmake_minimum_required(VERSION 3.0)project(CALCLIB)aux_source_directory(./ SRC)include_directories($&#123;HEAD_PATH&#125;)set(LIBRARY_OUTPUT_PATH $&#123;LIB_PATH&#125;)add_library($&#123;CALC_LIB&#125; STATIC $&#123;SRC&#125;) 第3行aux_source_directory：搜索当前目录（calc目录）下的所有源文件 第4行include_directories：包含头文件路径，HEAD_PATH是在根节点文件中定义的 第5行set：设置库的生成的路径，LIB_PATH是在根节点文件中定义的 第6行add_library：生成静态库，静态库名字CALC_LIB是在根节点文件中定义的 10.3.2 sort 目录sort 目录中的 CMakeLists.txt文件内容如下： 123456cmake_minimum_required(VERSION 3.0)project(CALCLIB)aux_source_directory(./ SRC)include_directories($&#123;HEAD_PATH&#125;)set(LIBRARY_OUTPUT_PATH $&#123;LIB_PATH&#125;)add_library($&#123;CALC_LIB&#125; SHARED $&#123;SRC&#125;) 第6行add_library：生成动态库，动态库名字SORT_LIB是在根节点文件中定义的 这个文件中的内容和calc节点文件中的内容类似，只不过这次生成的是动态库。 10.3.3 test1 目录test1 目录中的 CMakeLists.txt文件内容如下： 12345678cmake_minimum_required(VERSION 3.0)project(CALCTEST)aux_source_directory(./ SRC)include_directories($&#123;HEAD_PATH&#125;)link_directories($&#123;LIB_PATH&#125;)link_libraries($&#123;CALC_LIB&#125;)set(EXECUTABLE_OUTPUT_PATH $&#123;EXEC_PATH&#125;)add_executable($&#123;APP_NAME_1&#125; $&#123;SRC&#125;) 第4行include_directories：指定头文件路径，HEAD_PATH变量是在根节点文件中定义的 第6行link_libraries：指定可执行程序要链接的静态库，CALC_LIB变量是在根节点文件中定义的 第7行set：指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的 第8行add_executable：生成可执行程序，APP_NAME_1变量是在根节点文件中定义的 此处的可执行程序链接的是静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被加载到内存中了。 10.3.4 test2 目录test2 目录中的 CMakeLists.txt文件内容如下： 12345678cmake_minimum_required(VERSION 3.0)project(SORTTEST)aux_source_directory(./ SRC)include_directories($&#123;HEAD_PATH&#125;)set(EXECUTABLE_OUTPUT_PATH $&#123;EXEC_PATH&#125;)link_directories($&#123;LIB_PATH&#125;)add_executable($&#123;APP_NAME_2&#125; $&#123;SRC&#125;)target_link_libraries($&#123;APP_NAME_2&#125; $&#123;SORT_LIB&#125;) 第四行include_directories：包含头文件路径，HEAD_PATH变量是在根节点文件中定义的 第五行set：指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的 第六行link_directories：指定可执行程序要链接的动态库的路径，LIB_PATH变量是在根节点文件中定义的 第七行add_executable：生成可执行程序，APP_NAME_2变量是在根节点文件中定义的 第八行target_link_libraries：指定可执行程序要链接的动态库的名字 在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库。 注意：引用变量要使用{},不要用成() set(EXECUTABLE_OUTPUT_PATH $&#123;EXEC_PATH&#125;) 写成如下就会出错： set(EXECUTABLE_OUTPUT_PATH $(EXEC_PATH)) 就会出错 10.3.4 构建项目1234567891011121314151617181920212223242526272829303132333435xuan@DESKTOP-A52B6V9:~/linux/demos/cpro$ cd build/xuan@DESKTOP-A52B6V9:~/linux/demos/cpro/build$ cmake ..-- The C compiler identification is GNU 11.4.0-- The CXX compiler identification is GNU 11.4.0-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working C compiler: /usr/bin/cc - skipped-- Detecting C compile features-- Detecting C compile features - done-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: /usr/bin/c++ - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- Configuring done-- Generating done-- Build files have been written to: /home/xuan/linux/demos/cpro/buildxuan@DESKTOP-A52B6V9:~/linux/demos/cpro/build$ make[ 8%] Building C object calc/CMakeFiles/calc.dir/add.c.o[ 16%] Building C object calc/CMakeFiles/calc.dir/div.c.o[ 25%] Building C object calc/CMakeFiles/calc.dir/mult.c.o[ 33%] Building C object calc/CMakeFiles/calc.dir/sub.c.o[ 41%] Linking C static library ../../lib/libcalc.a[ 41%] Built target calc[ 50%] Building C object sort/CMakeFiles/sort.dir/insert.c.o[ 58%] Building C object sort/CMakeFiles/sort.dir/select.c.o[ 66%] Linking C shared library ../../lib/libsort.so[ 66%] Built target sort[ 75%] Building C object test2/CMakeFiles/test2.dir/sort.c.o[ 83%] Linking C executable ../../bin/test2[ 83%] Built target test2[ 91%] Building C object test1/CMakeFiles/test1.dir/calc.c.o[100%] Linking C executable ../../bin/test1[100%] Built target test1 通过上述log可以得到如下信息： 在项目根目录的lib目录中生成了静态库libcalc.a 在项目根目录的lib目录中生成了动态库libsort.so 在项目根目录的bin目录中生成了可执行程序test1 在项目根目录的bin目录中生成了可执行程序test2 以下是生成的树状图： 1234567$ tree bin/ lib/bin/├── test1└── test2lib/├── libcalc.a└── libsort.so 在项目中，如果将程序中的某个模块制作成了动态库或者静态库并且在CMakeLists.txt 中指定了库的输出目录，而后其它模块又需要加载这个生成的库文件，此时直接使用就可以了。 如果没有指定库的输出路径或者需要直接加载外部提供的库文件，此时就需要使用link_directories($&#123;LIB_PATH&#125;)将库文件路径指定出来,然后链接库的名字link_libraries($&#123;CALC_LIB&#125;)。 11. 流程控制11.1 条件判断1234567if(&lt;condition&gt;) &lt;commands&gt;elseif(&lt;condition&gt;) # 可选快, 可以重复 &lt;commands&gt;else() # 可选快 &lt;commands&gt;endif() 11.1.1 基本表达式 if(&lt;expression&gt;): expression 有以下三种情况：常量、变量、字符串。 如果是1, ON, YES, TRUE, Y, 非零值，非空字符串时，条件判断返回True 如果是 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND，空字符串时，条件判断返回False 11.1.2 逻辑判断 if(NOT ) if( AND ) if( OR ) 11.1.3 比较 if(&lt;variable|string&gt; &lt;COMMAND&gt; &lt;variable|string&gt;) &lt;COMMAND&gt;为如下值的解释： LESS：如果左侧数值&#x2F;字符串小于右侧，返回True GREATER：如果左侧数值&#x2F;字符串大于右侧，返回True EQUAL：如果左侧数值&#x2F;字符串等于右侧，返回True LESS_EQUAL：如果左侧数值&#x2F;字符串小于等于右侧，返回True GREATER_EQUAL：如果左侧数值&#x2F;字符串大于等于右侧，返回True 11.1.4 文件操作存在&#x2F;是返回True，不存在&#x2F;否返回False 判断文件或者目录是否存在：if(EXISTS path-to-file-or-directory) 判断是不是目录：if(IS_DIRECTORY path) 此处目录的 path 必须是绝对路径 判断是不是软连接：if(IS_SYMLINK file-name) 此处的 file-name 对应的路径必须是绝对路径 软链接相当于 Windows 里的快捷方式 判断是不是绝对路径：if(IS_ABSOLUTE path) 如果绝对路径是Linux，该路径需要从根目录开始描述 如果绝对路径是Windows，该路径需要从盘符开始描述 11.1.5 其他 判断某个元素是否在列表中：if(&lt;variable|string&gt; IN_LIST &lt;variable&gt;) 比较两个路径是否相等：if(&lt;variable|string&gt; PATH_EQUAL &lt;variable|string&gt;) 11.2 循环在 CMake 中循环有两种方式，分别是：foreach和while。 11.2.1 foreach使用 foreach 进行循环，语法格式如下： 123foreach(&lt;loop_var&gt; &lt;items&gt;) &lt;commands&gt;endforeach() foreach(&lt;loop_var&gt; RANGE &lt;stop&gt;) RANGE：关键字，表示要遍历范围 stop：这是一个正整数，表示范围的结束值，在遍历的时候从 0 开始，最大值为 stop。 loop_var：存储每次循环取出的值 123456cmake_minimum_required(VERSION 3.2)project(test)# 循环foreach(item RANGE 10) message(STATUS &quot;当前遍历的值为: $&#123;item&#125;&quot; )endforeach() 上面例子输出0~10 foreach(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;]) RANGE：关键字，表示要遍历范围 start：这是一个正整数，表示范围的起始值，也就是说最小值为 start stop：这是一个正整数，表示范围的结束值，也就是说最大值为 stop step：控制每次遍历的时候以怎样的步长增长，默认为1，可以不设置 -loop_var：存储每次循环取出的值 123456cmake_minimum_required(VERSION 3.2)project(test)foreach(item RANGE 10 30 2) message(STATUS &quot;当前遍历的值为: $&#123;item&#125;&quot; )endforeach() 上面例子输出10~30,从10开始,每次增长2。 foreach(&lt;loop_var&gt; IN [LISTS [&lt;lists&gt;]] [ITEMS [&lt;items&gt;]]) IN：关键字，表示在 xxx 里边 LISTS：关键字，对应的是列表list，通过set、list可以获得 ITEMS：关键字，对应的也是列表 loop_var：存储每次循环取出的值 123456789cmake_minimum_required(VERSION 3.2)project(test)# 创建 listset(WORD a b c d)set(NAME ace sabo luffy)# 遍历 listforeach(item IN LISTS WORD NAME) message(STATUS &quot;当前遍历的值为: $&#123;item&#125;&quot; )endforeach() 在上面的例子中，创建了两个 list 列表，在遍历的时候对它们两个都进行了遍历（可以根据实际需求选择同时遍历多个或者只遍历一个） 12345678cmake_minimum_required(VERSION 3.2)project(test)set(WORD a b c &quot;d e f&quot;)set(NAME ace sabo luffy)foreach(item IN ITEMS $&#123;WORD&#125; $&#123;NAME&#125;) message(STATUS &quot;当前遍历的值为: $&#123;item&#125;&quot; )endforeach() 在上面的例子中，遍历过程中将关键字LISTS改成了ITEMS，后边跟的还是一个或者多个列表，只不过此时需要通过$&#123;&#125;将列表中的值取出。其输出的信息和上一个例子是一样的： 123456789101112$ cd build/$ cmake ..-- 当前遍历的值为: a-- 当前遍历的值为: b-- 当前遍历的值为: c-- 当前遍历的值为: d e f-- 当前遍历的值为: ace-- 当前遍历的值为: sabo-- 当前遍历的值为: luffy-- Configuring done-- Generating done-- Build files have been written to: /home/robin/abc/a/build 小细节：在通过 set 组织列表的时候，如果某个字符串中有空格，可以通过双引号将其包裹起来，具体的操作方法可以参考上面的例子。 foreach(&lt;loop_var&gt;... IN ZIP_LISTS &lt;lists&gt;) loop_var：存储每次循环取出的值，可以根据要遍历的列表的数量指定多个变量，用于存储对应的列表当前取出的那个值。 如果指定了多个变量名，它们的数量应该和列表的数量相等 如果只给出了一个 loop_var，那么它将一系列的 loop_var_N 变量来存储对应列表中的当前项，也就是说 loop_var_0 对应第一个列表，loop_var_1 对应第二个列表，以此类推…… 如果遍历的多个列表中一个列表较短，当它遍历完成之后将不会再参与后续的遍历（因为其它列表还没有遍历完）。 IN：关键字，表示在 xxx 里边 ZIP_LISTS：关键字，对应的是列表list，通过set 、list可以获得 123456789101112131415cmake_minimum_required(VERSION 3.17)project(test)# 通过list给列表添加数据list(APPEND WORD hello world &quot;hello world&quot;)list(APPEND NAME ace sabo luffy zoro sanji)# 遍历列表foreach(item1 item2 IN ZIP_LISTS WORD NAME) message(STATUS &quot;当前遍历的值为: item1 = $&#123;item1&#125;, item2=$&#123;item2&#125;&quot; )endforeach()message(&quot;=============================&quot;)# 遍历列表foreach(item IN ZIP_LISTS WORD NAME) message(STATUS &quot;当前遍历的值为: item1 = $&#123;item_0&#125;, item2=$&#123;item_1&#125;&quot; )endforeach() 在这个例子中关于列表数据的添加是通过list来实现的。在遍历列表的时候一共使用了两种方式，一种提供了多个变量来存储当前列表中的值，另一种只有一个变量，但是实际取值的时候需要通过变量名_0、变量名_1、变量名_N 的方式来操作，注意事项：第一个列表对应的编号是0，第一个列表对应的编号是0，第一个列表对应的编号是0。 上面的例子输出的结果如下： 12345678910111213141516$ cd build/$ cmake ..-- 当前遍历的值为: item1 = hello, item2=ace-- 当前遍历的值为: item1 = world, item2=sabo-- 当前遍历的值为: item1 = hello world, item2=luffy-- 当前遍历的值为: item1 = , item2=zoro-- 当前遍历的值为: item1 = , item2=sanji=============================-- 当前遍历的值为: item1 = hello, item2=ace-- 当前遍历的值为: item1 = world, item2=sabo-- 当前遍历的值为: item1 = hello world, item2=luffy-- 当前遍历的值为: item1 = , item2=zoro-- 当前遍历的值为: item1 = , item2=sanji-- Configuring done (0.0s)-- Generating done (0.0s)-- Build files have been written to: /home/robin/abc/a/build 11.2.2 while123while(&lt;condition&gt;) &lt;commands&gt;endwhile() while 比较简单就不做描述了。 12. cmake设置编译器12.1 命令行在命令行中指定编译器，你可以在调用 cmake 命令时使用 -DCMAKE_C_COMPILER 和 -DCMAKE_CXX_COMPILER 选项来分别为C和C++设置编译器。例如： 1cmake -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ /path/to/source 12.2 CMakeLists.txt在项目的 CMakeLists.txt 文件中，你可以使用 set 命令来指定编译器： 12set(CMAKE_C_COMPILER /user/bin/gcc)set(CMAKE_CXX_COMPILER /user/bin/g++) 12.3 工具链文件CMake允许使用所谓的“工具链文件”（toolchain file）来指定编译器和工具链设置。这在跨平台构建时非常有用。工具链文件是一个普通的CMake脚本，它设置了构建系统所需的编译器和工具链选项。例如，创建一个名为 toolchain.cmake 的文件，并在其中设置编译器： set(CMAKE_C_COMPILER gcc) set(CMAKE_CXX_COMPILER g++) 然后在调用 cmake 命令时指定工具链文件： cmake -DCMAKE_TOOLCHAIN_FILE=path/to/toolchain.cmake /path/to/source 请记住，一旦CMake缓存生成，更改编译器的设置就需要清理CMake缓存并重新运行CMake配置。这是因为CMake在第一次运行时会将编译器和工具链的信息缓存起来，以便后续构建使用。","tags":"linux cmake"},{"title":"Linux下开发单片机","url":"/2024/05/06/Linux小贴士/","text":"tree指令小贴士1. 基本用法：显示当前目录下的文件和目录结构。 tree 2. 限制目录深度：使用 -L 选项后跟数字来限制目录显示的深度。 tree -L 2 这将显示当前目录及其下最多两级子目录。 3. 显示隐藏文件：默认情况下，隐藏文件（以点 . 开头的文件或目录）不会被显示。要显示这些隐藏文件，可以使用 -a 选项。 tree -a 4. 递归显示所有文件：使用 -R 选项递归显示所有文件。 tree -R 5. 指定目录：显示指定目录的树状结构。 tree /path/to/directory 6. 使用文件系统类型：显示目录结构时，包括文件系统类型。 tree -F -F 选项会在每个目录名后添加一个斜杠 /。 7. 排序：默认情况下，tree 会按字母顺序排序。使用 -f 选项可以按照文件修改时间排序。 tree -f 8. 显示文件大小：使用 -h 选项以更易读的格式显示文件大小。 tree -h 9. 显示目录和文件的权限：使用 -u 选项显示文件所有者，-g 选项显示文件组。 tree -ug 10. 使用颜色：tree 命令使用颜色来区分不同类型的文件和目录。使用 –no-colour 可以关闭颜色显示。 tree --no-colour 11. 输出到文件：将树状结构输出到一个文件中。 tree &gt; tree.txt 12. 执行命令：对每个文件或目录执行命令，例如，获取每个文件的详细信息。 tree -exec ls -l &#123;&#125; \\; 13. 帮助和手册：查看 tree 命令的帮助信息。 tree --help man tree 14. 安装 tree 命令（如果尚未安装）通常可以通过你的Linux发行版的包管理器来完成。例如，在Ubuntu上，你可以使用以下命令安装： sudo apt-get update sudo apt-get install tree 使用 tree 可以帮助你更直观地查看目录结构，特别是在处理复杂的文件系统时。","tags":"linux wsl"},{"title":"Qt5学习笔记","url":"/2024/04/30/Qt5学习笔记/","text":"环境搭建 Qt官方下载地址: https://download.qt.io/archive/qt/ 参考教程文档: https://subingwen.cn/qt/qt-primer/ 问题汇总打印问题问题现象： 在Qt Creater中，使用qDebug()打印信息时，在调试界面中，qDebug()的输出信息会显示在调试终端，当直接运行.exe文件时，qDebug()的输出信息会丢失。 1234567MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); qDebug() &lt;&lt; &quot;这是测试打印程序&quot; &lt;&lt; &quot; * &quot; &lt;&lt; 10000;&#125; 解决方法： 在qt.pro工程文件中中，添加如下代码：1CONFIG += c++17 console //添加console 勾选以下选项： 总结： 需要重新编译代码，.exe文件更新后生效。 再次编译运行时,会弹出terminal。","tags":"qt"},{"title":"CmBacktrace移植","url":"/2024/04/19/CmBacktrace移植/","text":"CmBacktrace简介 支持断言（assert）和故障（Hard Fault） 故障原因自动诊断 输出错误现场的 函数调用栈 适配 Cortex-M0&#x2F;M3&#x2F;M4&#x2F;M7 MCU； 支持 IAR、KEIL、GCC 编译器； 移植步骤1. 下载源码 官方源码地址 : https://github.com/armink/CmBacktrace示例项目地址 : https://github.com/XUAN9527/cmbacktrace-demo 2. copy源码文件 添加头文件cm_backtrace.h cmb_cfg.h cmb_def.h 添加源文件cm_backtrace.c 添加demos文件 demos/non_os/stm32f10x/app/src/fault_test.c 修改添加fault_handler/gcc/cmb_fault.S为fault_handler/gcc/cmb_fault.s 2.1 添加修改makefile： 123ASM_SOURCES = \\CMSIS/device/startup/startup_n32l40x_gcc.s \\components/cm_backtrace/fault_handler/gcc/cmb_fault.s #添加这一行 2.2 添加printf重定向： 1234int _write(int fd, char* pBuffer, int size)&#123; return drv_serial_dma_write(ESERIAL_1, pBuffer, size);&#125; 2.3 修改文件： cmb_cfg.h文件 1234567891011121314151617181920#ifndef _CMB_CFG_H_#define _CMB_CFG_H_#include &quot;log.h&quot;/* print line, must config by user */#define cmb_println(...) printf(__VA_ARGS__);printf(&quot;\\r\\n&quot;) /* e.g., printf(__VA_ARGS__);printf(&quot;\\r\\n&quot;) or SEGGER_RTT_printf(0, __VA_ARGS__);SEGGER_RTT_WriteString(0, &quot;\\r\\n&quot;) *//* enable bare metal(no OS) platform */#define CMB_USING_BARE_METAL_PLATFORM/* enable OS platform *//* #define CMB_USING_OS_PLATFORM *//* OS platform type, must config when CMB_USING_OS_PLATFORM is enable *//* #define CMB_OS_PLATFORM_TYPE CMB_OS_PLATFORM_RTT or CMB_OS_PLATFORM_UCOSII or CMB_OS_PLATFORM_UCOSIII or CMB_OS_PLATFORM_FREERTOS or CMB_OS_PLATFORM_RTX5 *//* cpu platform type, must config by user */#define CMB_CPU_PLATFORM_TYPE CMB_CPU_ARM_CORTEX_M4 /* CMB_CPU_ARM_CORTEX_M0 or CMB_CPU_ARM_CORTEX_M3 or CMB_CPU_ARM_CORTEX_M4 or CMB_CPU_ARM_CORTEX_M7 *//* enable dump stack information */#define CMB_USING_DUMP_STACK_INFO/* language of print information */#define CMB_PRINT_LANGUAGE CMB_PRINT_LANGUAGE_ENGLISH /* CMB_PRINT_LANGUAGE_ENGLISH(default) or CMB_PRINT_LANGUAGE_CHINESE */#endif /* _CMB_CFG_H_ */ 修改n32l40x_flash.ld链接文件 text段开始之前添加 _stext = .; 下面为例程： 12345678910111213141516171819202122232425/* Define output sections */SECTIONS&#123; /* The startup code goes first into FLASH */ .isr_vector : &#123; . = ALIGN(4); KEEP(*(.isr_vector)) /* Startup code */ . = ALIGN(4); &#125; &gt;FLASH _stext = .; # text段开始之前添加 /* The program code and other data goes into FLASH */ .text : &#123; . = ALIGN(4); *(.text) /* .text sections (code) */ *(.text*) /* .text* sections (code) */ *(.glue_7) /* glue arm to thumb code */ *(.glue_7t) /* glue thumb to arm code */ *(.eh_frame) KEEP (*(.init)) KEEP (*(.fini)) text段开始之前添加 _sstack = .; 下面为例程： 123456789101112131415161718192021222324252627.bss :&#123; /* This is used by the startup in order to initialize the .bss secion */ _sbss = .; /* define a global symbol at bss start */ __bss_start__ = _sbss; *(.bss) *(.bss*) *(COMMON) . = ALIGN(4); _ebss = .; /* define a global symbol at bss end */ __bss_end__ = _ebss;&#125; &gt;RAM_sstack = .; # stack段开始之前添加/* User_heap_stack section, used to check that there is enough RAM left */._user_heap_stack :&#123; . = ALIGN(4); PROVIDE ( end = . ); PROVIDE ( _end = . ); . = . + _Min_Heap_Size; . = . + _Min_Stack_Size; _estack = .; /* end of RAM */ . = ALIGN(4);&#125; &gt;RAM 2.4 main函数例程： 12345678910111213141516171819#include &quot;cm_backtrace.h&quot;#define HARDWARE_VERSION &quot;V1.0.0&quot;#define SOFTWARE_VERSION &quot;V0.1.0&quot;extern void fault_test_by_unalign(void);extern void fault_test_by_div0(void);int main(void)&#123; main_system_init(); cm_backtrace_init(&quot;CmBacktrace&quot;, HARDWARE_VERSION, SOFTWARE_VERSION); fault_test_by_unalign(); fault_test_by_div0(); while(1) &#123; &#125;&#125; 编译出错后代码： 12345678910111213141516171819202122232425262728293031323334Firmware name: CmBacktrace, hardware version: V1.0.0, software version: V0.1.0Fault on interrupt or bare metal(no OS) environment===== Thread stack information ===== addr: 20004ec8 data: 5a6d79ca addr: 20004ecc data: f758b4b7 addr: 20004ed0 data: 94cfc3fd addr: 20004ed4 data: a8ccaa51 addr: 20004ed8 data: 61049ca6 addr: 20004edc data: e4e1b169 addr: 20004ee0 data: b48e100d addr: 20004ee4 data: c44eb7ea addr: 20004ee8 data: 23d4e51e addr: 20004eec data: 8527b7c0 addr: 20004ef0 data: fd9d41f7 addr: 20004ef4 data: f539e421 addr: 20004ef8 data: 4ad52963 addr: 20004efc data: 4587b423 addr: 20004f00 data: e000ed00 addr: 20004f04 data: 00000000 addr: 20004f08 data: 00000000 addr: 20004f0c data: 00000000 addr: 20004f10 data: 200022cc addr: 20004f14 data: 00000000 addr: 20004f18 data: 00000000 addr: 20004f1c data: 00000000 addr: 20004f20 data: 00000000 addr: 20004f24 data: 08009093======================================================= Registers information ==================== R0 : 20002ee9 R1 : 20002e4c R2 : e000ed14 R3 : 2000253c R12: 0000000a LR : 0800a3b3 PC : 080154c2 PSR: 61000000==============================================================Usage fault is caused by attempts to execute an undefined instructionShow more call stack info by run: addr2line -e CmBacktrace.elf -a -f 080154c2 0800a3b2 08009092 转换为定位代码工具： linux环境下输入： 1addr2line -e app.elf -a -f 080154c2 0800a3b2 08009092 解释：app.elf 为你的工程编译文件。 数据分析结果： 12345678910xuan@DESKTOP-A52B6V9:~/work/n5-mini-s-plus/code/app/build$ addr2line -e app.elf -a -f 080154c2 0800a3b2 080090920x080154c2fault_test_by_unalign/home/xuan/work/n5-mini-s-plus/code/app/components/cm_backtrace/fault_test.c:180x0800a3b2main/home/xuan/work/n5-mini-s-plus/code/app/application/main.c:300x08009092LoopFillZerobss/home/xuan/work/n5-mini-s-plus/code/app/CMSIS/device/startup/startup_n32l40x_gcc.s:113","tags":"linux cortex-m"},{"title":"Linux下开发单片机","url":"/2024/03/28/Linux下开发单片机/","text":"Ubuntu Wsl环境搭建Windows10系统安装子系统Wsl1. 通过 Microsoft Store 安装 打开 Microsoft Store。 搜索 “适用于 Linux 的 Windows 子系统”。 选择 “Ubuntu” 或您喜欢的其他 Linux 发行版。 点击 “获取”。 安装完成后，点击 “启动”。 2. 通过命令行 打开 PowerShell 或 命令提示符 以管理员身份运行。 输入以下命令: 1wsl --install 重启您的计算机。 安装完成后，您可以通过以下命令启动 WSL： 1wsl 注意: WSL 需要 Windows 10 版本 1709 或更高版本。 您可以通过以下命令检查您的 Windows 版本： 1winver 如果您使用的是 Windows 10 家庭版，您需要启用 “适用于 Linux 的 Windows 子系统” 功能： 1控制面板-&gt;程序和功能-&gt;启用或关闭 Windows 功能-&gt;适用于 Linux 的 Windows 子系统-&gt;确定 您可以通过以下命令启用 “适用于 Linux 的 Windows 子系统” 功能： 1dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux 重启您的计算机后，您就可以通过上述方法安装 WSL 了。 安装 Windows Terminal 编译环境配置 gcc-arm-none-eabi工具链安装 手动安装：官方链接地址 下载所需版本； 12sudo apt install bzip2sudo tar -xvf ~/n32_gcc/software_package/gcc-arm-none-eabi-9-2019-q4-major-x86_64-linux.tar.bz2 -C ~/n32_gcc 自动安装：sudo apt-get install gcc-arm-none-eabi 打开 ~/.bashrc 添加export PATH=$PATH:~/n32_gcc/gcc-arm-none-eabi-9-2019-q4-major/bin 添加alias open-file=&#39;explorer.exe .&#39; 使能用户环境变量source ~/.bashrc Make sudo apt-get install make Winodows Gcc + Make 环境搭建 安装software_package目录下的gcc-arm-none-eabi-9-2019-q4-major-win32-sha2.exe和make-3.81.exe 分别将其安装目录下的 ./bin添加到系统环境变量，重启生效 复制裸机工程至Windows下，修改部分Makefile的linux指令以适配Windows即可 裸机工程编译 cd n32g452_gcc make makefile问题汇总修改.h文件没有重新编译 $(BUILD_DIR)为编译文件目录，跟进自身makefile修改，原来的编译规则：1-include $(wildcard $(BUILD_DIR)/*/*.d) # 包含所有生成的依赖文件，避免重复编译、提高效率 /*/*.d 为当前目录下的二级所有文件检索。 修改为以下编译规则：12345# 找到所有的 .d 文件DEP_FILES := $(shell find $(BUILD_DIR) -type f -name &#x27;*.d&#x27;)# 包含所有生成的依赖文件，避免重复编译、提高效率# 包含所有的 .d 文件-include $(DEP_FILES) 或者：12-include $(wildcard $(BUILD_DIR)/**/*.d)-include $(wildcard $(BUILD_DIR)/*/*/*.d) /**/*.d 为当前目录下的二级所有文件检索，根据具体情况修改。/*/*/*.d 为当前目录下的三级所有文件检索，根据具体情况修改。 windows子系统wsl###打开新终端 ~&#x2F;.bashrc不会自动刷新 解决linux每次打开新终端都要重新source ~/.bashrc问题执行以下代码： vi ~/.bash_profile 有可能此文件是空白新建的，无所谓。然后在此文件末尾加入： 123if [ -f ~/.bashrc ];thensource ~/.bashrcfi 然后:wq保存即可。此时打开新终端可以自动执行source ~/.bashrc arm-none-eabi-gcc工具链问题 arm-none-eabi-gcc工具链需加入用户变量：1export PATH=/home/xuan/OpenHarmony/install-software/gcc-arm-none-eabi-9-2019-q4-major/bin:$PATH 注意：需确认路径，否则找不到用户路径会搜索系统自带编译链 /usr/lib/gcc/arm-none-eabi/10.3.1 Linux下编写Python合并脚本合并 bootloader + app &#x3D; mix1. 安装 PyInstaller pip install pyinstaller 2. 编写Python合并程序 代码链接 3. 打包 Python 程序 参数说明： -F：生成单一可执行文件。 -D：生成包含所有依赖项的目录。 -n：指定可执行文件名。 --distpath：指定可执行文件输出目录。 --noconfirm：覆盖输出文件时无需确认。 以下是一些常用的高级选项： --hidden-import：指定要隐藏导入的模块。 --exclude-module：指定要排除的模块。 --onefile：将所有文件打包成一个可执行文件。 --runtime：指定 Python 运行时版本。 执行规则: cd new_file,copy file.py and file.ico pyinstaller -F -w (-i icofile) 文件名.py example: pyinstaller -F file.py pyinstaller -F -w -i file.ico file.py 4. 运行可执行文件 ./dist/file 5. 例程 代码链接 6. 实际应用场景 单独使用：Linux环境下单独执行使用。 集成在makefile中，使用make编译自动生成文件： 将papp_up和mix_10K打包至tools文件夹，放在makefile同一目录下。 需要bootloder.bin在../bootloader目录下。 修改makefile生成规则。 $(BUILD_DIR)为编译文件目录，跟进自身makefile修改。1234567891011121314151617181920212223242526.PHONY : clean allall: $(TARGET).bin $(TARGET).list $(TARGET).hex $(SZ) $(TARGET).elf @make copy @make mix.PHONY: copycopy: $(TARGET).bin cp $(TARGET).bin app.bin cp ../bootloader/bootloader.bin bootloader.bin# cp $(TARGET).hex app.hexmix: ./tools/papp_up ./tools/mix_10K $(OC) -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex rm bootloader.bin rm app.bin rm mix.binclean: rm -rf $(BUILD_DIR) rm papp.bin rm mix.hex","tags":"linux wsl"},{"title":"I2C调试记录","url":"/2024/03/01/I2C调试记录/","text":"I2C基本原理介绍时序介绍参考Vishay的i2c时序图： 代码实现详解I2C协议实现有硬件I2C和软件I2C之分，这里只讲解软件I2C实现的版本。一下列出主要结构体和初始化函数。 I2C协议初始化I2C协议的scl和sda配置为开漏输出,需要外部上拉（一般为10K电阻） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#define i2c_pin_mode(pin,mode) drv_pin_mode(pin,mode)#define i2c_pin_write(pin,level) drv_pin_write(pin,level)#define i2c_pin_read(pin) drv_pin_read(pin)#define DRV_I2C_WR 0x00#define DRV_I2C_RD (1u &lt;&lt; 0)#define DRV_I2C_ADDR_10BIT (1u &lt;&lt; 2) /* this is a ten bit chip address */#define DRV_I2C_NO_START (1u &lt;&lt; 4)#define DRV_I2C_IGNORE_NACK (1u &lt;&lt; 5)#define DRV_I2C_NO_READ_ACK (1u &lt;&lt; 6) /* when I2C reading, we do not ACK */#define DRV_I2C_NO_STOP (1u &lt;&lt; 7)typedef enum&#123; EI2C_DEV_1 = 1, EI2C_DEV_2, EI2C_DEV_3&#125;EI2C_DEVICE;struct drv_soft_i2c_config&#123; uint8_t scl; uint8_t sda; uint8_t i2c_num;&#125;;struct drv_i2c_msg&#123; uint16_t addr; uint16_t flags; uint16_t len; uint8_t reg_addr; uint8_t *buf;&#125;;struct drv_i2c_bit_ops&#123; void *data; /* private data for lowlevel routines */ void (*set_sda)(void *data, int state); void (*set_scl)(void *data, int state); int (*get_sda)(void *data); int (*get_scl)(void *data); void (*udelay)(uint32_t us); uint32_t delay_us; /* scl and sda line delay */ uint32_t timeout; /* in tick */&#125;;struct drv_i2c_bus_device&#123; struct drv_i2c_msg msg; struct drv_i2c_bit_ops ops;&#125;;static void drv_i2c_gpio_init(struct drv_soft_i2c_config *i2c)&#123; struct drv_soft_i2c_config* cfg = i2c; i2c_pin_mode(cfg-&gt;scl, I2C_PIN_MODE_OUTPUT_OD); //PIN_MODE_OUTPUT i2c_pin_mode(cfg-&gt;sda, I2C_PIN_MODE_OUTPUT_OD); i2c_pin_write(cfg-&gt;scl, I2C_PIN_HIGH); i2c_pin_write(cfg-&gt;sda, I2C_PIN_HIGH);&#125;int drv_hw_i2c_init(EI2C_DEVICE dev_e)&#123; int size = sizeof(i2c_pin_config)/sizeof(struct drv_soft_i2c_config); struct drv_i2c_bus_device *dev = get_i2c_device(dev_e); uint8_t dev_num = (uint8_t)dev_e; struct drv_soft_i2c_config *pin_cfg = NULL; struct drv_i2c_bit_ops *ops = &amp;dev-&gt;ops; for(int i=0;i&lt;size;i++) &#123; if(i2c_pin_config[i].i2c_num == dev_num) &#123; pin_cfg = (struct drv_soft_i2c_config *)&amp;i2c_pin_config[i]; break; &#125; &#125; if(pin_cfg == NULL) return -1; ops-&gt;data = (void*)pin_cfg; ops-&gt;set_sda = n32_set_sda; ops-&gt;set_scl = n32_set_scl; ops-&gt;get_sda = n32_get_sda; ops-&gt;get_scl = n32_get_scl; ops-&gt;udelay = n32_udelay; ops-&gt;delay_us = 1; ops-&gt;timeout = 5; drv_i2c_gpio_init(pin_cfg); drv_i2c_bus_unlock(pin_cfg); return 0;&#125; 接口函数12345678int drv_i2c_bit_xfer(struct drv_i2c_bit_ops *bus, struct drv_i2c_msg msgs[], uint32_t num);struct drv_i2c_bus_device *get_i2c_device(EI2C_DEVICE dev_e);static uint64_t i2c_tick_get(void);int drv_hw_i2c_init(EI2C_DEVICE dev_e);int drv_i2c_send_data(EI2C_DEVICE dev_e,uint16_t addr,uint8_t reg_addr,uint8_t *buf,uint16_t len);int drv_i2c_recv_data(EI2C_DEVICE dev_e,uint16_t addr,uint8_t reg_addr,uint8_t *buf,uint16_t len); 实战开发问题分析实际开发过程中，同样的I2C驱动程序，在不同厂家芯片的使用上出现一些问题，导致部分厂家通信异常，导致数据接收不正确，以下进行分析对比，作证并解决问题。 Vishay 和 亿光 接近传感器模块对比Vishay 使用VCNL3682S型号芯片，亿光 使用APM-16D24-U6E型号芯片，I2C协议对比。 Vishay ： 亿光： 对比波形对比协议来看基本上是一致的，用JI2C工具测的i2c波形也基本上一致，但是我自己写的软件i2c驱动，Vishay可以正常使用，亿光读取的数据就有问题，用逻辑分析仪抓一波波形分析一下。 发现每次读完都会多恢复一个ack，而协议上读完最后一个字节需要恢复nack。 修改了以下代码12345678910111213141516static int i2c_send_ack_or_nack(struct drv_i2c_bit_ops *bus, int ack)&#123; struct drv_i2c_bit_ops *ops = bus; if (ack) //if(ack &gt;= 0) 改成 if(ack) SET_SDA(ops, 0); i2c_delay(ops); if (SCL_H(ops) &lt; 0) &#123;// logVerbose(&quot;ACK or NACK timeout.&quot;); return -2; &#125; SCL_L(ops); return 0;&#125; static int i2c_send_ack_or_nack(struct drv_i2c_bit_ops *bus, int ack)&#123;&#125;函数主要处理响应回复。 if(ack &gt;= 0)表示每次都会回复ack/nack if(ack)表示除最后一次数据不回复，其他每次都会回复ack/nack","tags":"逻辑分析仪 接近传感器"},{"title":"ESP32开发小贴士","url":"/2024/02/22/ESP32小贴士/","text":"ESP32 ESP-IDF自定义组件简介官方文档英文官方文档链接中文官方文档链接 示例说明此示例在《ESP32 smart_config和airkiss配网》https://zhuanlan.zhihu.com/p/440454542https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/121687760基础上，增加连接成功后点亮板载LED功能。实现所需功能后将各功能代码分离，再将分离后的代码构造成组件，使得项目有清晰的结构，方便功能代码移植. 开发环境《Win10启用Linux子系统安装Ubuntu》https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/112131624 《用乐鑫国内Gitee镜像搭建ESP32开发环境》https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/113424934 构建项目拷贝 &amp;&amp; 初始化例程将例子项目hello_world复制到ESP-IDF开发工具之外,更名为components_demo: cd ~/esp cp -r ~/esp/esp-adf/esp-idf/examples/get-started/hello_world ./components_demo 清空build目录: cd ~/esp/components_demo rm -r build/* 注意，每当添加了新组件就要删除build目录下的全部内容，或者执行下面这条命令： idf.py fullclean 清除以前的构建。 添加组件letter_shellidf.py -C components create-component letter_shell 该命令会创建一个新组件,新组件将包含构建组件所需的一组空文件。我们的工作就是在这一组空文件中写上我们的代码。如果熟悉了组件结构，也可以直接在项目中手工创建。 项目树构建好的项目结构如下: 注意：组件目录components名字不能改，其下的组件名可以随意取。build目录是编译时生成的，编译的结果都放在其中。dependencies.lock是随原来的项目复制过来的不要改。sdkconfig文件可以用idf.py menuconfig命令修改。 代码和说明各文件的位置关系很重要，请对照前面的项目树看代码文件。 项目的根CMakeLists.txt文件# The following lines of boilerplate have to be in your project&#39;s # CMakeLists in this exact order for cmake to work correctly cmake_minimum_required(VERSION 3.16) include($ENV&#123;IDF_PATH&#125;/tools/cmake/project.cmake) project(components_demo) 只需要修改project中的项目名称。 main目录CMakeLists.txt idf_component_register(SRCS &quot;main.c&quot; INCLUDE_DIRS &quot;.&quot;) main.c 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;freertos/queue.h&quot;#include &quot;esp_log.h&quot;#include &quot;shell_port.h&quot;#include &quot;log.h&quot;#include &quot;nvs_flash.h&quot;static const char *TAG = &quot;sample test&quot;;void app_main(void)&#123; esp_err_t ret; // Initialize NVS. ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) &#123; ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); &#125; ESP_ERROR_CHECK( ret ); esp_log_level_set(TAG, ESP_LOG_INFO); ESP_LOGI(TAG,&quot;this is a test program&quot;); userShellInit(); logInfo(&quot;log info!&quot;); logDebug(&quot;log debug!&quot;); logWarning(&quot;log warning!&quot;); logError(&quot;log error!&quot;); while(1) &#123; logDebug(&quot;log loop!&quot;); vTaskDelay(pdMS_TO_TICKS(2000)); &#125;&#125; 头文件nvs_flash.h是对系统组件的引用，shell_port.h是对自定义组件的引用。 letter_shell组件CMakeLists.txt: idf_component_register( SRCS &quot;shell.c&quot; &quot;shell_ext.c&quot; &quot;log.c&quot; &quot;shell_port.c&quot; INCLUDE_DIRS &quot;include&quot; LDFRAGMENTS &quot;shell.lf&quot; # PRIV_REQUIRES led REQUIRES esp_driver_uart ) 说明：1、PRIV_REQUIRES该参数指定对其它自定义组件的依赖，即私有依赖项。 PRIV_REQUIRES led表示指出在smart_config组件中要用到自定义的led组件。组件名字可以加引号，也可以不加。多个组件用空格分开。 2、 REQUIRES该参数指定对系统组件的依赖，即公共依赖项。 REQUIRES esp_driver_uart 表示在letter_shell组件中要用到系统组件esp_driver_uart。 3、系统组件的确定 对于要依赖的系统组件不像私有依赖项那样一目了然，有时我们并不清楚所要的系统组件名称。比如我们不知道需要组件wpa_supplicant，这时我们可以先编译一次，看看错误信息： 在CMakeLists.txt中添加依赖组件REQUIRES esp_driver_uart，编译通过。 关于CMakeLists.txt文件根和每个目录都有一个CMakeLists.txt文件，开始遇到的问题是不知道目录结构和怎样写CMakeLists.txt文件，要注意每一层目录中CMakeLists.txt文件的写法，本文的例子给出了一个简单的示范。对于复杂的项目还需要更多编写CMakeLists.txt文件的知识，请看简介中给出的官方文档。 ESP32移植Letter_shell问题添加shell组件及其log，编译出错可能原因: 宏使用不正确: 如果 SHELL_FREE 旨在实际释放与 companions 对象关联的内存或资源，则当前定义不正确。它应该调用内存管理函数或执行其他必要的清理任务。 编译器警告被视为错误: -Werror=unused-value 标志已启用，它将警告视为错误。即使宏使用本身可能不是关键问题，这也可能导致编译失败。 解决方案:修复 SHELL_FREE 定义: 如果 companions 需要内存分配，请更新 shell_cfg.h 中的 SHELL_FREE 宏以调用适当的内存管理函数，例如 free()。 如果 companions 不需要内存管理，请从 shell_companion.c 中的第 57 行删除 SHELL_FREE 调用；或者将shell_cfg.h 中的第 36 行 SHELL_USING_COMPANION 的宏定义改为 0。 禁用 -Werror&#x3D;unused-value (如果适用):如果您希望将未使用的值警告视为警告而不是错误，您可以暂时在编译期间禁用 -Werror=unused-value 标志。但是，通常建议修复底层问题以避免潜在的内存泄漏或资源管理问题。 其他提示: 提供有关您的项目更多信息，例如具体的 ESP-IDF 版本、涉及的组件以及 SHELL_FREE 宏的用途。这将有助于了解根本原因并提供更定制的指导。 分享 shell_cfg.h 头文件和 shell_companion.c 文件的相关部分，以便分析代码结构和上下文。考虑使用调试器逐步执行代码并检查 companions 在 SHELL_FREE 调用之前和之后的 值，以了解其使用情况和潜在的内存管理问题。 通过遵循这些步骤并提供更多信息，我可以帮助您有效地解决编译错误并确保您的 ESP-IDF 项目成功构建。 配置shell优先级将shell的freertos优先级设置为 tskIDLE_PRIORITY，为0级，跟空闲函数优先级一样，所有其他优先级任务执行完后才会执行 tskIDLE_PRIORITY优先级任务。 源代码例程ESP32移植letter_shell组件例程","tags":"esp32"},{"title":"ESP32开发环境搭建","url":"/2024/02/19/ESP32环境搭建/","text":"开发环境搭建ESP-ADF快速上手连接ESP-IDF快速上手连接 获取ESP-ADF打开Linux or macOS终端,新建搭建环境所需文件夹。 mkdir ~/esp cd ~/esp 编译 ESP-IDF 需要以下软件包。请根据使用的 Linux 发行版本，选择合适的安装：Ubuntu 和 Debian: sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 CentOS 7 &amp; 8: sudo yum -y update &amp;&amp; sudo yum install git wget flex bison gperf python3 python3-setuptools cmake ninja-build ccache dfu-util libusbx Arch: sudo pacman -S --needed gcc git make flex bison gperf python cmake ninja ccache dfu-util libusb 克隆最新版ESP-ADF： git clone --recursive https://github.com/espressif/esp-adf.git 若克隆失败，尝试以下指令： git clone --recursive git@github.com:espressif/esp-adf.git 若子模块拉取失败，尝试手动逐个拉取子模块： cd ~/esp/esp-adf/components git clone git@github.com:espressif/esp-adf-libs.git cd ~/esp/esp-adf/components git clone git@github.com:espressif/esp-sr.git cd ~/esp/esp-adf git clone git@github.com:espressif/esp-idf.git 设置环境变量按自己实际路径，可按自己喜好设置，也可不配置，手动敲指令也可。 vi ~/.bashrc在后面加上以下代码： 12345678910#开启ESP32编译环境alias get-idf=&#x27;. $HOME/esp/esp-adf/esp-idf/export.sh&#x27;alias get-adf=&#x27;. $HOME/esp/esp-adf/export.sh&#x27;#打开本地文件夹（wsl）alias open-file=&#x27;explorer.exe .&#x27;#烧录到设备，并打开监视器，/dev/ttyS15为USB挂载端口，需测试后填写，115200为监视器波特率，与设备UART0波特率对应alias esp-download=&#x27;idf.py -p /dev/ttyS15 -b 115200 flash monitor&#x27;export PATH=/home/qx_song/esp/esp-adf/esp-idf/tools:$PATHexport IDF_PATH=/home/qx_song/esp/esp-adf/esp-idfexport ADF_PATH=/home/qx_song/esp/esp-adf 保存退出 :wq 设置工具除了 ESP-IDF 本身，还需要为支持 ESP32 的项目安装 ESP-IDF 使用的各种工具，比如编译器、调试器、Python 包等。 cd ~/esp/esp-adf/esp-idf 安装esp32，esp32s2工具，运行以下指令：（按需求安装） ./install.sh esp32,esp32s2 若需要安装所有工具，运行以下指令： ./install.sh all 以下为ESP-IDF编译所需环境，请在需要运行ESP-IDF的终端窗口运行以下命令： . $HOME/esp/esp-adf/esp-idf/export.sh 或者使用快捷指令： get-idf ESP32工程示例开始创建工程现在，可以准备开发 ESP32 应用程序了。从 ESP-IDF 中 examples 目录下的 get-started/hello_world 工程开始，将 get-started/hello_world 工程复制至本地的 ~&#x2F;esp 目录下： cd ~/esp get-idf cp -r $IDF_PATH/examples/get-started/hello_world . 配置工程cd ~/esp/hello_world idf.py set-target esp32 由于ESP32是单核，默认配置是双核模式，需要配置参数： idf.py menuconfig Component config -&gt; FreeRTOS -&gt; [*]Run FreeRTOS only on first core 保存退出 编译工程idf.py build 烧录工程idf.py -p PORT flash 请将 PORT 替换为 ESP32 开发板的串口名称。如果 PORT 未经定义，idf.py 将尝试使用可用的串口自动连接。 合并执行构建、烧录和监视过程：idf.py -p PORT [-b BAUD] flash monitor 注：[-b BAUD] 和 monitor 配合使用，BAUD为程序中UART0的波特率 idf.py -p /dev/ttyS15 -b 115200 flash monitor idf.py -p [挂载端口] -b [波特率] flash monitor 擦除flashidf.py -p PORT erase-flash 若存在需要擦除的 OTA 数据，请运行以下命令： idf.py -p PORT erase-otadata 挂载端口windows 子系统 wsl输入烧录指令： idf.py flash 观察终端设备是挂载在哪个端口上，有ERROR忽略，选择端口例如 /dev/ttyS15，程序中UART0的波特率115200，下次就可以直接输此端口就可以烧录啦。 idf.py -p /dev/ttyS15 -b 115200 flash monitor 如果 ESP-IDF 监视器在烧录后很快发生错误，或打印信息全是乱码（如下），很有可能是因为开发板采用了 26 MHz 晶振，而 ESP-IDF 默认支持大多数开发板使用的 40 MHz 晶振。 x���ff�f�����`�~�~���f���x��f�f�����ff��`���f����`��~x������ff�f�����`�~�~�f����f����f`���x��f�f�����ff��`���f 此时，可以：1、退出监视器。2、返回 idf.py menuconfig。3、进入 Component config –&gt; Hardware Settings –&gt; Main XTAL Config –&gt; Main XTAL frequency 进行配置，将 CONFIG_XTAL_FREQ_SEL 设置为 26 MHz。4、重新编译和烧录应用程序。 总结启动终端ESP32编译只需要进行以下步骤： . $HOME/esp/esp-adf/esp-idf/export.sh //开启编译环境 idf.py set-target esp32 //首次搭建项目时配置 idf.py menuconfig //选择需要的配置 idf.py build idf.py flash 快捷方式： get-idf idf.py set-target esp32 idf.py menuconfig idf.py build esp-download","tags":"esp32 linux"},{"title":"Markdown小贴士","url":"/2024/02/19/Markdown小贴士/","text":"Markdown 的基本语法Markdown 的语法非常简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。以下是一些常用的 Markdown 标记符号： 标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 文本普通文本 **加粗文本** *斜体文本* **~删除线文本~** 列表* 无序列表 1. 有序列表 * 嵌套列表 代码块123456#include &lt;stdio.h&gt;int main() &#123;printf(&quot;Hello, world!\\n&quot;);return 0;&#125; 文本中代码高亮使用`printf(&quot;Hello, world!\\n&quot;);`函数进行打印 效果：使用printf(&quot;Hello, world!\\n&quot;);函数进行打印 链接链接文本: https://www.example.com 图片网络地址: ![这是一张示例图片](https://www.example.com/example.png) 本地文件路径：![这是一张示例图片](../pictures/这是一张示例图片.png) 图片链接跳转: ![这是一张示例图片](example.png) &#123;link=https://www.example.com/&#125; 图片标题: ![这是一张示例图片](example.png) &#123;title=这是一张示例图片&#125; 图片居中: ![这是一张示例图片](example.png) &#123;align=center&#125; 示例： ![这是一张示例图片](example.png) ![这是一张 200x100 像素的图片](example.png) &#123;width=200 height=100&#125; ![这是一张居中的图片](example.png) &#123;align=center&#125; ![点击图片跳转到 https://www.example.com/](example.png) &#123;link=https://www.example.com/&#125; ![这是一张示例图片](example.png) &#123;title=这是一张示例图片&#125; 表格 头部1 头部2 头部3 内容1 内容2 内容3 内容4 内容5 内容6 Markdown 的应用博客文章 技术文档 README 文件 演示文稿 电子书 总结Markdown 是一种易于学习和使用的标记语言，非常适合编写各种文档。如果您还没有使用过 Markdown，建议您尝试一下。 以下是 Markdown 官方教学网站：Markdown 官方网站","tags":"markdown"},{"title":"单片机开发问题汇总","url":"/2024/01/31/MCU开发问题汇总/","text":"内核复位（kernel reset）常见通用问题 内核复位代码，如ADC： 1234567891011void kernel_reset(void)&#123; __DSB(); __disable_irq(); //close irq drv_adc_deinit(EADC_DEV1,EDMA_CH6); //disable adc data SCB-&gt;AIRCR = ((0x5FA &lt;&lt; SCB_AIRCR_VECTKEY_Pos) | (SCB-&gt;AIRCR &amp; SCB_AIRCR_PRIGROUP_Msk) | SCB_AIRCR_VECTRESET_Msk); __DSB(); while(1);&#125; 板级初始化前先要重置状态： 12DMA_DeInit(dma_chx); //DMA开启循环接收后会持续接收字节ADC_DeInit(adc_handler); ADC驱动初始化&#x2F;反初始化: 1234567891011121314151617int drv_adc_init(EADC_DEVICE adc_dev,EDMA_CHANNEL dma_ch)&#123; drv_adc_configuration(adc_dev); drv_dma_configuration(adc_dev,dma_ch); drv_adc_enable(adc_dev,DISABLE); return 0;&#125;int drv_adc_deinit(EADC_DEVICE adc_dev,EDMA_CHANNEL dma_ch)&#123; ADC_Module *adc_handler = drv_get_adc_device(adc_dev)-&gt;ADC_Handler; DMA_ChannelType * dma_chx = drv_get_dma_channel(dma_ch); drv_adc_enable(adc_dev,DISABLE); DMA_EnableChannel(dma_chx,DISABLE); return 0;&#125; n32g452rc内核复位问题bootloader跳转到app 栈大小改变后跳转成功：将ram空间数据uint16_t改为uint32_t。 堆大小改变后跳转成功：将队列申请长度20改为30。 代码大小变化后跳转失败： 代码段变长，能跑进system_init,跑飞待查。 代码段变短，不能跑进system_init,跑飞待查。 MCU复位后状态 复位期间和刚复位后,复用功能未开启,I&#x2F;O端口被配置成模拟功能模式(PCFGy[1:0]&#x3D;00b, PMODEy[1:0]&#x3D;00b)。 但有以下几个例外的信号：BOOT0、 NRST、 OSC_IN、 OSC_OUT 默认无 GPIO 功能： BOOT0 引脚默认输入下拉 NRST 上拉输入输出 复位后，调试系统相关的引脚默认状态为启动 SWD-JTAG， JTAG 引脚被置于输入上拉或下拉模式： PA15:JTDI 置于输入上拉模式 PA14:JTCK 置于输入下拉模式 PA13:JTMS 置于输入上拉模式 PB4:NJTRST 置于输入上拉模式 PB3:JTD0 置于推挽输出无上下拉 PD0 和 PD1 PD0 和 PD1 在 80 及以上引脚封装默认为模拟模式 PD0 和 PD1 在 80 以下引脚封装复用到 OSC_IN&#x2F;OUT PC13、 PC14、 PC15： PC13～15 为备电域下的三个 IO， 备份域初次上电默认为模拟模式； PB2&#x2F;BOOT1： PB2&#x2F;BOOT1 默认处于下拉输入状态； BOOT0 默认输入下拉，参照下表， 若 BOOT 的引脚未连接，则默认选择 Flash 主存储区。 printf重定向 MDK版本，勾选Use MicroLIB选项： 123456789101112131415161718192021222324static int is_lr_sent = 0;int fputc(int ch, FILE* f)&#123; if (ch == &#x27;\\r&#x27;) &#123; is_lr_sent = 1; &#125; else if (ch == &#x27;\\n&#x27;) &#123; if (!is_lr_sent) &#123; USART_SendData(USART1, &#x27;\\r&#x27;); while (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET); &#125; is_lr_sent = 0; &#125; else &#123; is_lr_sent = 0; &#125; USART_SendData(USART1, ch); while (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET); return ch;&#125; GCC版本 123456789int _write(int fd, char* pBuffer, int size)&#123; for (int i = 0; i &lt; size; i++) &#123; USART_SendData(USART1, pBuffer[i]); while (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET); &#125; return size;&#125; RT-THREAD调试问题串口通信异常 打开UART7接收为DMA IDLE中断，申请一个超时定时器，发送&#x2F;接受各一个任务，发送&#x2F;接受两个队列,以下是错误信息： 1234567891011121314151617181920212223psr: 0x60000000r00: 0x00000000r01: 0x20007978r02: 0x20007978r03: 0x00000000r04: 0x00000000r05: 0x00000000r06: 0x00000000r07: 0x20000920r08: 0x20005908r09: 0x20000568r10: 0xdeadbeefr11: 0xdeadbeefr12: 0x00000000 lr: 0x0801156f pc: 0x00000000hard fault on thread: timerE [00:00:07,324] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue) assertion failed at function:rt_mq_send_wait, line number:2026 E [00:00:00,659] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type(&amp;timer-&gt;parent) == RT_Object_Class_Timer) assertion failed at function:rt_timer_control, line number:474 E [00:00:39,282] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread) assertion failed at function:rt_thread_resume, line number:760 问题定位到指针变量p_srx_mq[0]和&amp;p_srx_mq[0]的区别，代码如下： 12345678910111213141516171819202122232425#define COMM_MAX_NUM 3static uint8_t *p_srx_mq[COMM_MAX_NUM];static struct comm_serial_mq srx_mq_data[COMM_MAX_NUM];static struct rt_timer comm_rx_stimer[COMM_MAX_NUM];static void comm_serial_recieve_data_deinit(uint8_t num)&#123; srx_mq_data[num].size = 0; p_srx_mq[num] = srx_mq_data[num].data;&#125;static int usart_key_rx_indicate(ESERIAL_DEV serial_dev, uint16_t size)&#123; if(p_srx_mq[0] - srx_mq_data[0].data + size &gt; sizeof(srx_mq_data[0].data)) &#123; comm_serial_recieve_data_deinit(0); return -1; &#125; rt_timer_start(&amp;comm_rx_stimer[0]); // 启动定时器 drv_fifo_data_get(serial_dev, (uint8_t *)p_srx_mq[0], size); logPrintln(&quot;test = [%p][%p][%p]&quot;,p_srx_mq[0],&amp;p_srx_mq[0],srx_mq_data[0].data); p_srx_mq[0] += size; srx_mq_data[0].size += size; return 0;&#125; 指针取址符&amp;与取值*的区别1. 指针取址符(&amp;) 指针取址符 &amp; 用于获取一个变量的地址，并将该地址存储在一个指针变量中。 具体来说: &amp; 运算符位于变量名前面。 &amp; 运算符的返回值是一个指针，指向该变量的内存地址。 12int num = 10;int *p = &amp;num; // p 指向 num 的地址 2. 取值符(*) 取值符 * 用于获取指针变量所指向的变量的值。 具体来说: 运算符位于指针变量名前面。 运算符的返回值是该指针变量所指向变量的值。 123int num = 10;int *p = &amp;num;int value = *p; // 访问 num 的值 总结： 指针取址符 &amp; 用于获取变量的地址，并将该地址存储在一个指针变量中。 取值符 * 用于获取指针变量所指向的变量的值。 需要注意的是： 不能对不存在的变量进行取址。 **不能对指针变量进行取址**。 取址操作可能会产生空指针，需要进行空指针检查。 为什么不能对指针变量进行取址1. 指针变量本身也是一个变量 指针变量也是一个变量，它存储的是另一个变量的地址。与其他变量一样，**指针变量也存在于内存中，并拥有自己的地址**。 2. 取址操作会产生无限循环 **如果对指针变量进行取址，那么就会得到该指针变量的地址**。但是，该指针变量本身也是一个变量，所以其地址也是存储在另一个变量中的。如此循环往复，就会产生无限循环。 3. 违背了指针的定义 指针的定义是指向另一个变量的地址。如果对指针变量进行取址，那么就意味着指针指向了它自己的地址，这违背了指针的定义。 4. 可能导致程序崩溃 在大多数情况下，对指针变量进行取址会导致程序崩溃。这是因为程序会试图访问一个不存在的内存地址。 TFT屏ST7735S调试问题硬件&#x2F;软件spi初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//头文件定义#define HARDWARE_SPI_MODE 1 //1：hardware；0：software#define LCD_SCLK_Clr() GPIO_ResetBits(GPIOA, GPIO_PIN_5) //SCL=SCLK#define LCD_SCLK_Set() GPIO_SetBits(GPIOA, GPIO_PIN_5)#define LCD_MOSI_Clr() GPIO_ResetBits(GPIOA, GPIO_PIN_7) //SDA=MOSI#define LCD_MOSI_Set() GPIO_SetBits(GPIOA, GPIO_PIN_7)#define LCD_RES_Clr() GPIO_ResetBits(GPIOB, GPIO_PIN_0) //RES#define LCD_RES_Set() GPIO_SetBits(GPIOB, GPIO_PIN_0)#define LCD_DC_Clr() GPIO_ResetBits(GPIOB, GPIO_PIN_1) //DC#define LCD_DC_Set() GPIO_SetBits(GPIOB, GPIO_PIN_1) #define LCD_CS_Clr() GPIO_ResetBits(GPIOA, GPIO_PIN_4) //CS#define LCD_CS_Set() GPIO_SetBits(GPIOA, GPIO_PIN_4)#define LCD_BLK_Clr() //BLK#define LCD_BLK_Set()void LCD_GPIO_Init(void)&#123; GPIO_InitType GPIO_InitStructure; RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_GPIOA | RCC_APB2_PERIPH_GPIOB , ENABLE);#if HARDWARE_SPI_MODE SPI_InitType SPI_InitStructure; RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_SPI1 | RCC_APB2_PERIPH_AFIO, ENABLE); GPIO_InitStruct(&amp;GPIO_InitStructure); GPIO_InitStructure.Pin = GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7; GPIO_InitStructure.GPIO_Alternate = GPIO_AF0_SPI1; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitPeripheral(GPIOA, &amp;GPIO_InitStructure); /* SPIy Config -------------------------------------------------------------*/ SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_TX; SPI_InitStructure.SpiMode = SPI_MODE_MASTER; SPI_InitStructure.DataLen = SPI_DATA_SIZE_8BITS; SPI_InitStructure.CLKPOL = SPI_CLKPOL_HIGH; SPI_InitStructure.CLKPHA = SPI_CLKPHA_FIRST_EDGE; SPI_InitStructure.NSS = SPI_NSS_HARD; SPI_InitStructure.BaudRatePres = SPI_BR_PRESCALER_2; SPI_InitStructure.FirstBit = SPI_FB_MSB; SPI_InitStructure.CRCPoly = 7; SPI_Init(SPI1, &amp;SPI_InitStructure); SPI_SSOutputEnable(SPI1, ENABLE); SPI_EnableCalculateCrc(SPI1, DISABLE); /* Enable SPIy */ SPI_Enable(SPI1, ENABLE);#else GPIO_InitStruct(&amp;GPIO_InitStructure); GPIO_InitStructure.Pin = GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitPeripheral(GPIOA, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOA, GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7);#endif GPIO_InitStruct(&amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1; GPIO_InitPeripheral(GPIOB, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOB, GPIO_PIN_0 | GPIO_PIN_1);&#125;void LCD_Writ_Bus(u8 dat) &#123; LCD_CS_Clr();#if HARDWARE_SPI_MODE SPI_I2S_TransmitData(SPI1, dat); while (SPI_I2S_GetStatus(SPI1, SPI_I2S_TE_FLAG) == RESET); //必须等到SPI数据发完，才能拉高CS片选，发下一次数据，否则数据会出错#else u8 i; for(i=0;i&lt;8;i++) &#123; LCD_SCLK_Clr(); if(dat&amp;0x80) &#123; LCD_MOSI_Set(); &#125; else &#123; LCD_MOSI_Clr(); &#125; LCD_SCLK_Set(); dat&lt;&lt;=1; &#125;#endif LCD_CS_Set(); &#125;void LCD_WR_DATA8(u8 dat)&#123; LCD_Writ_Bus(dat);&#125;void LCD_WR_DATA(u16 dat)&#123; LCD_Writ_Bus(dat&gt;&gt;8); LCD_Writ_Bus(dat);&#125; Cortex-M系列内核字节对齐汇总 4字节对齐的含义就是变量地址对4求余数为0；8字节对齐就是地址对8求余等于0，依次类推，比如：如果让p去访问0x20000001， 0x20000002，0x20000003这都是不对齐访问。 对于M3和M4而言，可以直接访问非对齐地址（注意芯片要在这个地址有对应的内存空间), 因为M3和M4是支持的，而M0/M0+/M1是不支持的，不支持的内核芯片，只要非对齐访问就会触发硬件异常。 综上所述，我们只讨论Cortex-M3&#x2F;M4内核情况。 全局变量对齐问题 uint8_t定义变量地址要1字节对齐。 uint16_t定义变量地址要2字节对齐。 uint32_t定义变量地址要4字节对齐。 uint64_t定义变量地址要8字节对齐。 指针变量是4字节对齐。 结构体成员对齐问题自然对界例子1（分析结构各成员的默认字节对界条界条件和结构整体的默认字节对界条件）: 1234567struct Test&#123; char x1; // 成员x1为char型(其起始地址必须1字节对界)，其偏移地址为0 char x2; // 成员x2为char型(其起始地址必须1字节对界，其偏移地址为1 float x3; // 成员x3为float型(其起始地址必须4字节对界)，编译器在x2和x3之间填充了两个空字节，其偏移地址为4 char x4; // 成员x4为char型(其起始地址必须1字节对界)，其偏移地址为8 &#125;; 在Test结构体中，最大的成员为float x3，因此结构体的自然对界条件为4字节对齐。则结构体长度就为12字节，内存布局为1100 1111 1000。 指令对齐1. 伪指令#pragma pack 改变缺省的对界条件(指定对界) 使用伪指令#pragma pack (n)，编译器将按照n个字节对齐。 使用伪指令#pragma pack ()，取消自定义字节对齐方式。 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。 结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。 结合推断：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。因此，当使用伪指令#pragma pack (2)时，Test结构体的大小为8，内存布局为1111 1110。 需要注意一点，当结构体中包含一个子结构体时，子结构中的成员按照#pragma pack指定的数值和子结构最大数据成员长度中，比较小的那个进行进行对齐。例子如下： 1234567891011121314#pragma pack(8)struct s1&#123; short a; long b;&#125;; struct s2&#123; char c; s1 d; long long e;&#125;;#pragma pack() sizeof(s2)的结果为24。S1的内存布局为1100 1111，S2的内存布局为1000 1100 1111 0000 1111 1111。 例子2(按照2个字节对齐时)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#pragma pack(2)typedef struct&#123; int aa1; //2个字节对齐 1111 char bb1;//1个字节对齐 1 short cc1;//2个字节对齐 011 char dd1; //1个字节对齐 1&#125; testlength1;int length1 = sizeof(testlength1); //2个字节对齐，占用字节11 11 10 11 10,length = 10 typedef struct&#123; char bb2;//1个字节对齐 1 int aa2; //2个字节对齐 01111 short cc2;//2个字节对齐 11 char dd2; //1个字节对齐 1&#125; testlength2;int length2 = sizeof(testlength2); //2个字节对齐，占用字节10 11 11 11 10,length = 10 typedef struct&#123; char bb3; //1个字节对齐 1 char dd3; //1个字节对齐 1 int aa3; //2个字节对齐 11 11 short cc23//2个字节对齐 11 &#125; testlength3;int length3 = sizeof(testlength3); //2个字节对齐，占用字节11 11 11 11,length = 8 typedef struct&#123; char bb4; //1个字节对齐 1 char dd4; //1个字节对齐 1 short cc4;//2个字节对齐 11 int aa4; //2个字节对齐 11 11&#125; testlength4;int length4 = sizeof(testlength4); //2个字节对齐，占用字节11 11 11 11,length = 8#pragma pack()int main(void)&#123; printf(&quot;length1 = %d.\\n&quot;,length1); printf(&quot;length2 = %d.\\n&quot;,length2); printf(&quot;length3 = %d.\\n&quot;,length3); printf(&quot;length4 = %d.\\n&quot;,length4); return 0;&#125; 2. attribute((aligned(n))) __attribute__是GCC里的编译参数，用法有很多种，感兴趣可以阅读一下gcc的相关文档。这里说一下__attribute__对变量和结构体对齐的影响。这里的影响大概分为两个方面，对齐和本身占用的字节数的大小，即sizeof（变量）的值。 int a attribute((aligned(64))) = 10; 这个修饰的影响主要是对齐，所谓对齐是存储为值的起始地址。变量a的地址&amp;a,本来是4字节对齐，变成了64字节对齐（有的环境对最大对齐数值有限制）。64字节对齐就是&amp;a的最后6位为0。 1sizeof(a) = 4; //a 占用的字节数还是4个字节 typedef int myint attribute((aligned(64))) ; 这样说明myint 声明的变量按照64字节对齐，大小是4字节，这样就会有一个问题，这个变量不能定义数组： 1myint myarray[2]; //这样定义编译器会报err 报错的原因是数组的存储在内存中是连续的，而myint只有4字节确要64字节对齐，这样对齐和连续就不能同时保证，就会报错。 例子1： 12345typedef struct st_tag &#123; int a; char b;&#125; ST1;ST1 myst； 在没有对齐的情况下：sizeof(ST1) = sizeof(myst) = 8;结构体对齐的原则可以总结为： 结构体起始地址(&amp;myst)按最大变量字节数(sizeof(int))对齐； 结构体内每个变量按照自身字节数对齐； 结构体的大小(sizeof(myst))是最大变量字节数的整数倍（8&#x2F;4&#x3D;2）； 123456typedef struct st_tag &#123; int a; char b;&#125; __attribute__((__aligned__(64))) ST1;ST1 myst；sizeof(ST1) = sizeof(myst) = 64; 对比： 123456typedef struct st_tag &#123; int a; char b;&#125; ST1 __attribute__((__aligned__(64)));ST1 myst；sizeof(ST1) = sizeof(myst) = 8 ; 这第二种情况可以理解为__attribute__((aligned(64)))作用于变量ST1 ，只影响对齐，不影响结构的大小。 例子2： 123456typedef struct __attribute__((packed))&#123; uint8_t comm_version; uint8_t comm_lenth; uint8_t device_fw_verion[];&#125;ble_resp_device_info_desc; __attribute__((packed))是GCC编译器提供的一个属性,__attribute__((packed))其中的成员变量不会进行对齐。","tags":"mcu"},{"title":"杂项笔记","url":"/2024/01/31/杂项笔记/","text":"J-Link&#x2F;J-FlashJ-Flash批处理脚本配置烧录：当然，前提是要添加J-Link的可执行程序路径到$PATH环境变量中 program.bat脚本代码如下，参考修改即可：123echo start...JLink -device N32L406CB -if swd -speed 4000 -CommanderScript &quot;C:\\Users\\Breo\\Desktop\\Wireless moxibustion\\Software\\program.jlink&quot; program.jlink文件代码如下，其中目标设备、文件路径、烧录地址等根据需要配置：12345678910111213connectdevice N32L406CBsi SWDspeed 4000h // halt-停止r // 复位，可以考虑去掉erase // 或 erase 0x8002800，去掉也行，但可能会出现error fail address 0x00000000错误提示loadfile app.bin 0x8002800 // loadfile app.hex 或 loadfile app.bin 0x8000000verifybin app.bin 0x8002800rgo // r go表示reset and runq // 退出J-Link命令行工具 Ubuntu 无法更新问题Ubuntu 无法使用apt update 更改软件源编辑 /etc/apt/sources.list 文件，将以下内容添加到文件末尾 deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse 清除 apt 缓存sudo apt clean sudo apt autoclean 尝试更新系统sudo apt update 显示 ModuleNotFoundError: No module named &#39;apt_pkg&#39;，重新安装 “apt_pkg“ 模块： sudo apt install --reinstall python3-apt 显示 ERROR： E: Could not read response to hello message from hook [ ! -f /usr/bin/snap ] || /usr/bin/snap advise-snap --from-apt 2&gt;/dev/null || true: Success 如果问题仍然存在，尝试修复 Python 包： sudo apt install --fix-broken 然后就更新系统了： sudo apt update sudo apt upgrade 执行sudo apt upgrade后显示ERROR： Errors were encountered while processing: /tmp/apt-dpkg-install-cQBLJW/626-linux-iot-tools-common_5.4.0-1030.31_all.deb E: Sub-process /usr/bin/dpkg returned an error code (1) 最后一步，修复损坏的软件包配置： sudo dpkg --configure -a sudo apt upgrade Breo蓝牙启动异常Breo蓝牙初始化蓝牙初始化没完成，透传未开启，app就连接蓝牙了。设置透传参数，开启透传的的状态中增加连接蓝牙接受指令。 心跳包回复超时现在是接收&#x2F;刷新设备数据200ms超时，延迟太长还可以缩短。 SPI级联led灯调试小助手产品名称：1209RGB幻彩雾状产品型号：XTQ-016B.RGB-2307125-20 SPI级联led灯问题汇总充电闪灯问题问题分析充电中拔掉电源，立即再次插入，会闪一下灯；若等两秒再插入则不会出现，初步判断是此款芯片有锁存功能，会保存到寄存器中，未完全掉电再次插入则会继续执行上次的寄存器数据。 解决方法充电中拔掉电源，程序不要立即断电，持续两秒反初始化spi灯珠，即给spi寄存器写全灭数据。 呼吸灯闪烁问题问题分析程序中呼吸灯会跑偶尔闪烁，影响显示效果。分析发现，代码中有电机的FG检测，此检测开启了输入捕获功能，会持续中断触发，虽然spi灯的驱动是dma发送，但是也是由CPU来调度的，并不能与中断并行。spi呼吸灯效果需要持续发送数据，且时序要求很高，中断会抢占spi的dma发送，打断spi传输数据，导致数据传输出错，造成闪灯效果。 解决方法1、提高芯片主频，n32l403KB最高主频为64MHz，如果主频提高效果会好一些。2、spi呼吸灯效果持续发送数据，不能与中断频繁的代码一起使用。 某项目充电保护仍充电修改代码： 12345678910111213141516&#123;-1, 1, PIN_CHARGE_CC_DETECT, PIN_MODE_INPUT&#125;, //input/output switchstatic void board_charge_cc_set(bool en)&#123; struct pin_status_desc *pin = pin_handle(PIN_CHARGE_CC_DETECT); if(en) &#123; pin-&gt;type = PIN_MODE_INPUT; drv_pin_mode(pin-&gt;pin_id,pin-&gt;type); pin-&gt;lvl_rt = -1; //重置lvl_rt，以防止output出问题 &#125;else&#123; pin-&gt;type = PIN_MODE_OUTPUT; drv_pin_mode(pin-&gt;pin_id,pin-&gt;type); pin_set_func(pin, PIN_HIGH); &#125;&#125; Git小贴士执行 git pull 会覆盖本地的修改吗？没有冲突的情况下，远端会直接更新至本地上，但不会改变本地未提交的变动；如果本地修改已提交，则会执行一个远端分支和本地分支的合并 git fetch 和 git pull 的区别与联系git fetch用于从远程仓库获取最新的提交，保存到本地的远程跟踪分支中（FETCH_HEAD），可以通过查看此分支了解远程仓库的更新情况 git diff FETCH_HEAD比较查看该分支和当前工作分支的内容 git pull会自动获取远程仓库的更新，并且合并到当前分支上，相当于git fetch + git merge FETCH_HEAD 将远程仓库中指定分支的最新提交 ID 保存到本地的 FETCH_HEAD 分支中 将 FETCH_HEAD 分支合并到当前工作分支中 基础非典型操作本地git配置 配置本地与远端的SSH密钥连接流程： 本地生成SSH公钥和私钥(如果没有的话，另，linux下公钥通常存放于~/.ssh/*.pub) ssh-keygen -t rsa -b 4096 -C xxx@xxx.com 复制公钥，添加至远端平台的SSH设置上 查看本地配置： git config --list查看当前项目的所有配置 git config --global --list查看全局配置 修改用户名(全局&#x2F;当前项目) 此用户名即提交日志上所展示的用户名称 修改全局用户名：git config --global user.name &quot;xxx&quot;，影响用户的所有仓库 修改当前路径项目的用户名：git config user.name &quot;xxx&quot; 查看全局用户名：git config user.name 初始化本地工程并与远端已有仓库的main分支关联： 进入工程根目录，git init初始化本地仓库 添加远程仓库：git remote add origin &lt;远程仓库地址&gt; git branch -M main将当前分支重命名为main，M即--move --force的缩写。（可以分别输入git add --all，git commit -m &quot;first commit&quot;完成对本地分支的首次提交） 使用git pull origin main，将远程仓库的main分支拉取到本地，或者git push -u origin main -f将本地的xxx分支强制推送到远端main分支，其中-u是--set-upstream的缩写，后续会保持这个跟踪关系 可变参数函数详解C语言中的可变参数函数允许您定义函数，其参数个数是不确定的，可以根据具体需求接受可变数量的参数。这在处理不定数量参数的情况下非常有用，比如printf和scanf等函数。让我为您详细解释一下可变参数函数的原理和实现。 1. 原理与实现： 可变参数函数的参数列表是从右往左压入堆栈的。假设堆栈中有以下参数：不可变参数1、不可变参数2、…、不可变参数n、可变参数1、可变参数2、…、可变参数n。 为了获取可变参数，我们需要知道每个可变参数的地址。这是通过前一个不可变参数的地址和类型来实现的。 ANSI标准提供了三个宏来实现这个过程： va_start(va_list arg_ptr, prev_param): 初始化可变参数列表，将arg_ptr指向第一个可变参数。 va_arg(va_list arg_ptr, type): 获取当前参数的值，类型由前面的不可变参数传递。例如，printf中的格式化字符串或者可变参数列表的参数类型和第几个不可变参数的相同。 va_end(va_list arg_ptr): 释放资源，结束可变参数列表的访问。 这些宏的实现细节由编译器和标准库提供，我们只需调用它们即可。 2. 可变参数函数： 可变参数函数允许在函数定义中接受不定数量的参数。 C语言提供了 stdarg.h 头文件来支持可变参数函数的实现。 下面是一个示例代码，展示了如何实现一个可变参数函数 sum，它接受一个整数参数 count，表示接下来的可变参数的数量： 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int sum(int count, ...) &#123; int total = 0; va_list args; va_start(args, count); for (int i = 0; i &lt; count; i++) &#123; int num = va_arg(args, int); total += num; &#125; va_end(args); return total;&#125;int main() &#123; int result = sum(4, 10, 20, 30, 40); printf(&quot;Sum: %d\\n&quot;, result); return 0;&#125; 在这个示例中，我们定义了一个可变参数函数 sum，它计算传入的整数参数的总和。 3. 可变参数宏： 可变参数宏允许在宏调用中接受可变数量的参数。 在C语言中，可变参数宏使用 __VA_ARGS__ 表示可变参数的部分。 下面是一个示例代码，展示了如何定义一个可变参数宏 PRINT_VALUES，它使用 printf 函数来打印可变数量的值: 123456789101112#include &lt;stdio.h&gt;#define PRINT_VALUES(...) do &#123; \\ printf(&quot;Values: &quot;); \\ printf(__VA_ARGS__); \\ printf(&quot;\\n&quot;); \\&#125; while (0)int main() &#123; PRINT_VALUES(&quot;%d %s %f&quot;, 10, &quot;hello&quot;, 3.14); return 0;&#125; 在这个示例中，我们定义了一个可变参数宏 PRINT_VALUES，它使用 printf 函数来打印多个值。 4. 实现自己的 printf 函数： printf 函数接受一个格式字符串作为第一个参数，后面是可变数量的参数，用于替换格式字符串中的格式占位符。 以下是一个简化版的示例代码，展示了一个实现类似于 printf 函数的功能的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;void my_printf(const char* format, ...) &#123; va_list args; va_start(args, format); while (*format != &#x27;\\0&#x27;) &#123; if (*format == &#x27;%&#x27;) &#123; format++; // 移动到占位符的下一个字符 if (*format == &#x27;d&#x27;) &#123; int value = va_arg(args, int); printf(&quot;%d&quot;, value); &#125; else if (*format == &#x27;f&#x27;) &#123; double value = va_arg(args, double); printf(&quot;%f&quot;, value); &#125; else if (*format == &#x27;s&#x27;) &#123; char* value = va_arg(args, char*); printf(&quot;%s&quot;, value); &#125; else if (*format == &#x27;c&#x27;) &#123; int value = va_arg(args, int); printf(&quot;%c&quot;, value); &#125; else &#123; printf(&quot;Unsupported format specifier: %c&quot;, *format); &#125; &#125; else &#123; printf(&quot;%c&quot;, *format); &#125; format++; // 移动到下一个字符 &#125; va_end(args);&#125;int main() &#123; int num = 42; double pi = 3.14159; char str[] = &quot;Hello, world!&quot;; char ch = &#x27;A&#x27;; my_printf(&quot;Integer: %d\\n&quot;, num); my_printf(&quot;Float: %f\\n&quot;, pi); my_printf(&quot;Float: %s\\n&quot;, str); my_printf(&quot;Float: %c\\n&quot;, ch); return 0;&#125; 汇编基础参考文档：汇编语言入门教程 实例分析了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序example.c。 1234567int add_a_and_b(int a, int b) &#123; return a + b;&#125;int main() &#123; return add_a_and_b(2, 3);&#125; gcc 将这个程序转成汇编语言。 1$ gcc -S example.c example.s经过简化以后，大概是下面的样子。 1234567891011121314_add_a_and_b: push %ebx mov %eax, [%esp+8] mov %ebx, [%esp+12] add %eax, %ebx pop %ebx ret _main: push 3 push 2 call _add_a_and_b add %esp, 8 ret 可以看到，原程序的两个函数add_a_and_b和main，对应两个标签_add_a_and_b和_main。每个标签里面是该函数所转成的 CPU 运行流程。","tags":""},{"title":"扎礼","url":"/schedule/notes.html","text":"","tags":""},{"title":"about","url":"/about/index.html","text":"","tags":""},{"title":"schedule","url":"/schedule/index.html","text":"","tags":""},{"title":"categories","url":"/categories/index.html","text":"","tags":""},{"title":"tags","url":"/tags/index.html","text":"","tags":""}]}