var tipuesearch = {"pages":[{"title":"I.MX6ULL开发指南","url":"/2024/07/13/I.MX6ULL开发指南/","text":"开发环境搭建虚拟机安装 下载安装VMware Workstation Pro工具。 下载安装ubuntu 20.04 LTS系统镜像。 快速创建虚拟机。 配置虚拟机环境。 虚拟机-设置(见以下图片)： 网络适配器可按自己需要设置。 启动虚拟机，进入ubuntu系统。 进入系统后会自动弹出DVD, 里面有VMware Tools的压缩包。 复制压缩包到Donwnloads目录下，解压。 执行sudo ./vmware-install.pl安装。 解决Windows和Ubuntu之间复制粘贴问题。 输入安装命令：sudo apt install open-vm-tools 输入命令：sudo apt install open-vm-tools-desktop 注意：输入第一条命令后，等待安装，遇到选择Y/N，选择Y；第一条安装完成后，输入第二条命令，同样遇到选择Y/N，选择Y。安装完毕后，切记：一定要重新启动Linux系统才可以双向复制粘贴。 虚拟机安装配置遇到的问题桥接模式资料(仅供参考) 尝试解决无法使用桥接使用与PC机相同IP上网 虚拟网络编辑器-还原默认设置（该过程会卸载虚拟网卡，重新安装适配器） 桥接模式启动 笔试还不能关闭网络服务，ubuntu内部配置IPv4（先打开PC主机以太网，按下图所示手动填写地址和DNS）,重新启动网络服务。 虚拟机右下角的USB是灰的，不能链接&#x2F;断开。 参考资料 Uboot移植参考资料 I.MX6ULL启动模式 Uboot编译烧录 将uboot压缩文件uboot-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4.tar.bz2放到/home/xuan/linux/目录下。 将uboot文件tar -xjvf uboot-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4.tar.bz2 解压到该目录下。 cd /home/xuan/linux/uboot-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4 编写以下脚本：(mx6ull_14x14_evk_emmc.sh) 1234#!/bin/bashmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distcleanmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_alientek_emmc_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- V=1 -j12 执行脚本：./mx6ull_14x14_evk_emmc.sh Uboot烧录到SD卡 插上SD卡，启动uboot, SD卡和EMMC驱动检查:12345mmc dev 0mmc infommc dev 1mmc info 烧写验证与驱动测试 挂载SD卡，不做描述，挂载上之后ls /dev/sd*显示。 执行以下shell指令。123cd ~/linux/uboot-alientek-v2.4 //进入uboot文件夹 chmod 777 imxdownload //给予 imxdownload 可执行权限./imxdownload u-boot.bin /dev/sdb //烧写到 SD 卡中，不能烧写到/dev/sda 或 sda1 里面 U-Boot 图形化配置 12345sudo apt-get install build-essentialsudo apt-get install libncurses5-devmake mx6ull_alientek_emmc_defconfigmake menuconfig 配置网口的环境变量，开发板上的ENET2,上电进入uboot,打开的USB_TTL对应的串口控制台。1234567env default -a;saveenv //default好像有问题setenv ipaddr 192.168.104.130 //开发板 ip 地址setenv ethaddr b8:ae:1d:01:00:00 //开发板的MAC地址，一定要设置, 如有多块开发板，MAC需不一致setenv gatewayip 192.168.104.1 //网关地址setenv netmask 255.255.240.0 //子网掩码setenv serverip 192.168.104.129 //服务器 IP 地址，也就是 Ubuntu 主机 IP 地址，用于调试代码。saveenv Linux内核移植移植步骤1. Ubuntu下搭建网络传输环境 1.1 搭建网络tftp服务 执行以下指令，安装xinetd: 1sudo apt-get install xinetd 查询/etc/下是否存在 xinetd.conf 文件，没有的话则自己新建一个。 12ls /etc/xinetd.confsudo vi /etc/xinetd.conf 创建出来的文件是空白的， 修改 xinetd.conf 文件内容如下： 12345678910# Simple configuration file for xinetd## Some defaults, and include /etc/xinetd.d/defaults&#123;# Please note that you need a log_type line to be able to use log_on_success# and log_on_failure. The default is the following :# log_type = SYSLOG daemon info&#125;includedir /etc/xinetd.d 新建 TFTP 目录，这里建立在&#x2F;home&#x2F;xuan&#x2F;linux 目录下，目录名为 tftp。将 tftp 目录赋予可读可写可执行权限。 1234mkdir -p /home/xuan/linux/tftpsudo chmod 777 /home/xuan/linux/tftp/cd /home/xuan/linux/ls 执行以下程序安装 tftp-hpa 和 tftpd-hpa 服务程序 12sudo apt-get install tftp-hpa tftpd-hpasudo vi /etc/default/tftpd-hpa 执行以下指令创建/etc/xinetd.d/tftp配置文件。（如果没有 xinetd.d 这个目录，可以先自己手动创建）,注意 server_args = -s 后面要添加自己的 tftp 工作路径。 123456789101112131415server tftp&#123;socket_type = dgramwait = yesdisable = nouser = rootprotocol = udpserver = /usr/sbin/in.tftpdserver_args = -s /home/xuan/linux/tftp -c#log_on_success += PID HOST DURATION#log_on_failure += HOSTper_source = 11cps =100 2flags =IPv4&#125; 修改&#x2F;添加 tftp 文件后， 执行以下指令重启 tftpd-hpa, 重启 xinetd 服务。 12sudo service tftpd-hpa restartsudo service xinetd restart 确保网络环境正常，Ubuntu、Windows和开发板能相互 ping 通。 开发板 IP： 192.168.104.130 虚拟机 IP： 192.168.104.129 电脑网口的 IP： 192.168.104.29 1.2 搭建网络nfs服务 在 Ubuntu 终端执行以下指令安装 NFS 1sudo apt-get install nfs-kernel-server 新建 NFS 共享目录，并给予 NFS 目录可读可写可执行权限。 12sudo mkdir /home/xuan/linux/nfssudo chmod 777 /home/xuan/linux/nfs/ 执行以下指令打开 etc/exports 文件 1sudo vi /etc/exports 进入 etc/exports 文件，在最后添加如下内容 1/home/alientek/linux/nfs *(rw,sync,no_root_squash) /home/alientek/linux/nfs 表示 NFS 共享的目录*表示允许所有的网络段访问rw 表示访问者具有可读写权限sync 表示将缓存写入设备中，可以说是同步缓存的意思no_root_squash 表示访问者具有 root 权限。 执行以下指令重启 NFS 服务器, 查看 NFS 共享目录。 12sudo /etc/init.d/nfs-kernel-server restartshowmount -e 设置 NFS 服务开机自启 12sudo systemctl enable nfs-kernel-serversudo reboot 测试 NFS 服务，执行以下指令设置开发板 IP，创建一个 get 目录，将虚拟机（192.168.104.129） NFS 共享目录挂载到到开发板的 get 目录中。 12mkdir getmount -t nfs -o nolock,nfsvers=3 192.168.104.129:/home/xuan/linux/nfs get/ 查看挂载的 NFS 目录：df, 显示如下： 1192.168.104.129:/home/xuan/linux/nfs 204795392 14416896 179902464 8% /home/root/get 卸载 NFS 目录：umount get 2. 拷贝内核文件 将内核压缩文件linux-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4.tar.bz2放到/home/xuan/linux/linux-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4目录下。 将内核文件tar -xjvf linux-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4.tar.bz2 解压到该目录下。 3. 编译内核文件 按以下步骤进行编译： 123make clean //第一次编译 Linux 内核之前先清理一下make imx_v7_mfg_defconfig //配置 Linux 内核make -j16 //编译 Linux 内核 发现编译报错： 123456 LZO arch/arm/boot/compressed/piggy.lzo/bin/sh: 1: lzop: not foundmake[2]: *** [arch/arm/boot/compressed/Makefile:180：arch/arm/boot/compressed/piggy.lzo] 错误 1make[1]: *** [arch/arm/boot/Makefile:52：arch/arm/boot/compressed/vmlinux] 错误 2make: *** [arch/arm/Makefile:316：zImage] 错误 2make: *** 正在等待未完成的任务.... 解决方法： 安装lzop：sudo apt install lzop 添加lzop到环境变量：export PATH&#x3D;$PATH:&#x2F;usr&#x2F;bin(直接安装的不需要添加环境变量) 重新编译：make -j16 若执行 ./mx6ull_alientek_emmc.sh 发现编译报错： 1&lt;command-line&gt;: fatal error: curses.h: 没有那个文件或目录 解决方法： 执行 make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig 后报错 fatal error:curses.h:没有那个文件或目录，这个是少了某个库，执行如下指令安装库：1sudo apt-get install libncurses* 4. 整理编译后的镜像文件 Linux 内核编译完成以后会在 arch/arm/boot 目录下生成 zImage 镜像文件，如果使用设备树的话还会在 arch/arm/boot/dtb 目录下开发板对应的.dtb(设备树)文件，比如 imx6ull-alientek-emmc.dtb就是 NXP 官方的 I.MX6ULL EVK开发板对应的设备树文件。至此我们得到两个文件： Linux 内核镜像文件： zImage。 NXP官方I.MX6ULL EVK开发板对应的设备树文件： imx6ull-alientek-emmc.dtb。 5. 内核启动测试 修改uboot 中的环境变量 bootargs 1console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw 将上一小节编译出来的 zImage 和 imx6ull-alientek-emmc.dtb 复制到 Ubuntu 中的 tftp 目录下，因为我们要在 uboot 中使用 tftp 命令将其下载到开发板中，拷贝命令如下： 12cp arch/arm/boot/zImage /home/xuan/linux/tftpboot/ -fcp arch/arm/boot/dtb/imx6ull-alientek-emmc.dtb /home/xuan/linux/tftpboot/ -f 拷贝完成以后就可以测试了，启动开发板，进入 uboot 命令行模式，然后输入如下命令将zImage 和 imx6ull-alientek-emmc.dtb 下载到开发板中： 从tftp启动： 123tftp 80800000 zImagetftp 83000000 imx6ull-alientek-emmc.dtbbootz 80800000 - 83000000 从EMMC启动： 123fatload mmc 1:1 80800000 zImagefatload mmc 1:1 83000000 imx6ull-alientek-emmc.dtbbootz 80800000 - 83000000 或者在uboot中保存环境变量： 123setenv bootcmd &#x27;mmc dev 1;fatload mmc 1:1 80800000 zImage;fatload mmc 1:1 83000000 imx6ull-alientek-emmc.dtb;bootz 80800000 - 83000000&#x27;setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;saveenv 从网络启动Linux系统移植参考资料 使用tftpboot启动传输。 拨码到从SD卡启动，开发板上电&#x2F;RESET，进入uboot。 在uboot配置bootargs和bootcmd参数并保存。 1234//`root=/dev/mmcblk1p2 rootwait rw` 为使用 eMMC 中已有的根文件系统setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27; setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000&#x27;saveenv 输入boot启动 使用nfs挂载rootfs。 拨码到从SD卡启动，开发板上电&#x2F;RESET，进入uboot。 在uboot配置bootargs参数并保存。12setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.104.129:/home/xuan/linux/nfs/rootfs,proto=tcp rw ip=192.168.104.130:192.168.104.129:192.168.104.1:255.255.240.0::eth0:off&#x27; //设置 bootargssaveenv //保存环境变量 输入boot启动 Error solving [参考资料]：https://blog.csdn.net/weixin_44256228/article/details/113830253) 显示挂载失败，一大堆错误，显示没挂载上 IMX6ULL通过NFS挂载根文件系统失败的方法 修改/etc/default/nfs-kernel-server1sudo vi /etc/default/nfs-kernel-server nfs-kernel-server文件修改内容如下：123456789101112131415161718192021# Number of servers to start up#RPCNFSDCOUNT=8RPCNFSDCOUNT=&quot;-V 2 8&quot;# Runtime priority of server (see nice(1))RPCNFSDPRIORITY=0# Options for rpc.mountd.# If you have a port-based firewall, you might want to set up# a fixed port here using the --port option. For more information, # see rpc.mountd(8) or http://wiki.debian.org/SecuringNFS# To disable NFSv4 on the server, specify &#x27;--no-nfs-version 4&#x27; here#RPCMOUNTDOPTS=&quot;--manage-gids&quot;RPCMOUNTDOPTS=&quot;-V 2 --manage-gids&quot;# Do you want to start the svcgssd daemon? It is only required for Kerberos# exports. Valid alternatives are &quot;yes&quot; and &quot;no&quot;; the default is &quot;no&quot;.NEED_SVCGSSD=&quot;&quot;# Options for rpc.svcgssd.RPCSVCGSSDOPTS=&quot;--nfs-version 2,3,4 --debug --syslog&quot; 重启NFS服务器1sudo service nfs-kernel-server restart 重新开机挂载，问题解决。 Linux驱动开发老字符驱动开发（手动创建节点） led驱动的Makefile文件如下： 12345678KERNELDIR := /home/xuan/linux/linux-gaCURRENT_PATH := $(shell pwd)obj-m := led.obuild: kernel_moduleskernel_modules:$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) modulesclean:$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean make编译, 生成led.ko文件, 这个是内核模块（Kernel Module）文件，很重要。 编译app文件，输入如下命令：arm-linux-gnueabihf-gcc ledApp.c -o ledApp 复制到rootfs中，若没有rootfs/lib/modules/4.1.15/,先建立文件夹，输入如下命令： 12mkdir -p /home/xuan/linux/nfs/rootfs/lib/modules/4.1.15/sudo cp led.ko led /home/xuan/linux/nfs/rootfs/lib/modules/4.1.15/ -f nfs挂载rootfs，进入开发板 1cd /lib/modules/4.1.15 1234depmod //第一次加载驱动的时候需要运行此命令insmod led.ko或者modprobe led.ko //加载 led.ko 驱动文件 1234cat /proc/devices //查看当前系统中有没有 led 这个设备mknod /dev/led c 200 0 //创建设备节点文件./ledApp /dev/led 1 //亮灯./ledApp /dev/led 0 //灭灯 123rmmod led.ko或者modprobe -r led.ko //卸载 led.ko 驱动文件 老字符驱动开发（自动创建节点） 编写 Makefile 文件 123456789101112KERNELDIR := /home/xuan/linux/linux-gaCURRENT_PATH := $(shell pwd)obj-m := newchrled.obuild: kernel_moduleskernel_modules: $(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) modulesclean: $(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean 编译出驱动模块文件,编译成功以后就会生成一个名为newchrled.ko的驱动模块文件 1234cd ~/linux/drivers/03_newchrledmake -j32arm-linux-gnueabihf-gcc ledApp.c -o ledAppcp ledApp newchrled.ko ~/linux/nfs/rootfs/lib/modules/4.1.15 重新上电运行开发板 1234567cd /lib/modules/4.1.15depmod //第一次加载驱动的时候需要运行此命令modprobe newchrled.ko //加载驱动ls /dev/newchrled -l //查看/dev/newchrdev 这个设备节点文件是否存在./ledApp /dev/newchrled 1 //打开 LED 灯./ledApp /dev/newchrled 0 //关闭 LED 灯rmmod newchrled.ko Linux 设备树以LED点灯驱动为例主要步骤： 修改设备树(.dts文件),跟根节点下添加设备子节点，子节点添加属性，举例：1234567891011alphaled &#123; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; compatible = &quot;atkalpha-led&quot;; status = &quot;okay&quot;; reg = &lt; 0X020C406C 0X04 /* CCM_CCGR1_BASE */ 0X020E0068 0X04 /* SW_MUX_GPIO1_IO03_BASE */ 0X020E02F4 0X04 /* SW_PAD_GPIO1_IO03_BASE */ 0X0209C000 0X04 /* GPIO1_DR_BASE */ 0X0209C004 0X04 &gt;; /* GPIO1_GDIR_BASE */&#125;; 在linux目录下重新编译设备树：make dtbs 编译完成以后得到imx6ull-alientek-emmc.dtb，使用新的 imx6ull-alientek-emmc.dtb启动Linux内核 Linux启动成功以后进入到/proc/device-tree/目录中查看是否有alphaled这个节点,若没有则修改失败 编写dtsled.c文件和文件ledApp.c,修改Makefile中的KERNELDIR参数为/home/xuan/linux/linux-ga12make -j32arm-linux-gnueabihf-gcc ledApp.c -o ledApp 编译出来的dtsled.ko和ledApp这两个文件拷贝到rootfs/lib/modules/4.1.15目录中，重启开发板，进入到目录lib/modules/4.1.15中，输入如下命令加载dtsled.ko驱动模块：12345depmod //第一次加载驱动的时候需要运行此命令modprobe dtsled.ko //加载驱动./ledApp /dev/dtsled 1 //打开 LED 灯./ledApp /dev/dtsled 0 //关闭 LED 灯rmmod dtsled.ko pinctrl 和 gpio 子系统实验pinctrl 子系统介绍pinctrl 子系统主要工作内容如下： 获取设备树中 pin 信息。 根据获取到的 pin 信息来设置 pin 的复用功能 根据获取到的 pin 信息来设置 pin 的电气特性，比如上&#x2F;下拉、速度、驱动能力等。 对于我们使用者来讲，只需要在设备树里面设置好某个 pin 的相关属性即可，其他的初始化工作均由 pinctrl 子系统来完成， pinctrl 子系统源码目录为 drivers/pinctrl。 设备树中添加 pinctrl 节点模板 创建对应的节点，打开 imx6ull-alientek-emmc.dts，在 iomuxc 节点中的 imx6ul-evk 子节点下添加 “pinctrl_test” 节点 添加 “fsl,pins” 属性，名字一定要为“fsl,pins”，因为对于 I.MX 系列 SOC 而言， pinctrl 驱动程序是通过读取“fsl,pins”属性值来获取 PIN 的配置信息 1234567pinctrl_test: testgrp &#123; /* 具体的 PIN 信息 */ fsl,pins = &lt; MX6UL_PAD_GPIO1_IO00__GPIO1_IO00 config /*config 是具体设置值*/ &gt;; &#125;;&#125;; 至此，我们已经在 imx6ull-alientek-emmc.dts 文件中添加好了 test 设备所使用的 PIN 配置信息。 gpio子系统 gpio实验 添加 pinctrl 节点, ，打开 imx6ull-alientekemmc.dts，在 iomuxc 节点的 imx6ul-evk 子节点下创建一个名为“pinctrl_led”的子节点 12345pinctrl_led: ledgrp &#123; fsl,pins = &lt; MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 0x10B0 /* LED0 */ &gt;;&#125;; 添加 LED 设备节点, 在根节点“/”下创建 LED 灯节点，节点名为“gpioled” 123456789gpioled &#123; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; compatible = &quot;atkalpha-gpioled&quot;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;pinctrl_led&gt;; led-gpio = &lt;&amp;gpio1 3 GPIO_ACTIVE_LOW&gt;; status = &quot;okay&quot;;&#125;; 检查 PIN 是否被其他外设使用 检查 pinctrl 设置。 如果这个 PIN 配置为 GPIO 的话，检查这个 GPIO 有没有被别的外设使用。 在本章实验中 LED 灯使用的 PIN 为 GPIO1_IO03，在 imx6ull-alientek-emmc.dts 中，先检查 GPIO_IO03 这个 PIN 有没有被其他的 pinctrl 节点使用。 如别的模块有使用到GPIO_IO03，需要注释掉。 Linux 蜂鸣器实验 打开imx6ull-alientekemmc.dts，在 iomuxc 节点的 imx6ul-evk 子节点下创建一个名为“pinctrl_beep”的子节点 12345pinctrl_beep: beepgrp &#123; fsl,pins = &lt; MX6ULL_PAD_SNVS_TAMPER1__GPIO5_IO01 0x10B0 /* beep */ &gt;;&#125;; 在根节点“/”下创建 BEEP 节点，节点名为“beep” 123456789beep &#123; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; compatible = &quot;atkalpha-beep&quot;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;pinctrl_beep&gt;; beep-gpio = &lt;&amp;gpio5 1 GPIO_ACTIVE_HIGH&gt;; status = &quot;okay&quot;;&#125;; 检查 PIN 是否被其他外设使用 蜂鸣器驱动程序编写 编写测试 APP 编译驱动程序: make -j32 编译测试 APP: arm-linux-gnueabihf-gcc beepApp.c -o beepApp 开发板运行测试 12345depmod //第一次加载驱动的时候需要运行此命令modprobe beep.ko //加载驱动./beepApp /dev/beep 1 //打开蜂鸣器./beepApp /dev/beep 0 //关闭蜂鸣器rmmod beep.ko","tags":"linux i.mx6ull nxp"},{"title":"Cotex-M4启动详解","url":"/2024/05/29/Cotex-M4启动详解/","text":"启动文件startup_n32l40x_gcc.s 文件为例，以下是源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459/** **************************************************************************** Copyright (c) 2019, Nations Technologies Inc. All rights reserved. **************************************************************************** Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: - Redistributions of source code must retain the above copyright notice, this list of conditions and the disclaimer below. Nations&#x27; name may not be used to endorse or promote products derived from this software without specific prior written permission. DISCLAIMER: THIS SOFTWARE IS PROVIDED BY NATIONS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE DISCLAIMED. IN NO EVENT SHALL NATIONS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. **************************************************************************** **/ /** Amount of memory (in bytes) allocated for Stack* Tailor this value to your application needs* &lt;h&gt; Stack Configuration* &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;* &lt;/h&gt;*//********************************************************************************* @file startup_n32l40x_gcc.s*******************************************************************************/ .syntax unified .cpu cortex-m4 .fpu softvfp .thumb.global g_pfnVectors.global Default_Handler/* start address for the initialization values of the .data section. defined in linker script */.word _sidata/* start address for the .data section. defined in linker script */ .word _sdata/* end address for the .data section. defined in linker script */.word _edata/* start address for the .bss section. defined in linker script */.word _sbss/* end address for the .bss section. defined in linker script */.word _ebss/* stack used for SystemInit_ExtMemCtl; always internal RAM used *//** * @brief This is the code that gets called when the processor first * starts execution following a reset event. Only the absolutely * necessary set is performed, after which the application * supplied main() routine is called. * @param None * @retval : None*/ .section .text.Reset_Handler .weak Reset_Handler .type Reset_Handler, %function Reset_Handler: /* Copy the data segment initializers from flash to SRAM */ movs r1, #0 b LoopCopyDataInitCopyDataInit: ldr r3, =_sidata ldr r3, [r3, r1] str r3, [r0, r1] adds r1, r1, #4 LoopCopyDataInit: ldr r0, =_sdata ldr r3, =_edata adds r2, r0, r1 cmp r2, r3 bcc CopyDataInit ldr r2, =_sbss b LoopFillZerobss/* Zero fill the bss segment. */ FillZerobss: movs r3, #0 str r3, [r2], #4 LoopFillZerobss: ldr r3, = _ebss cmp r2, r3 bcc FillZerobss/* Call the clock system intitialization function.*/ bl SystemInit /* Call static constructors */ bl __libc_init_array/* Call the application&#x27;s entry point.*/ bl main bx lr .size Reset_Handler, .-Reset_Handler/** * @brief This is the code that gets called when the processor receives an * unexpected interrupt. This simply enters an infinite loop, preserving * the system state for examination by a debugger. * @param None * @retval None */ .section .text.Default_Handler,&quot;ax&quot;,%progbitsDefault_Handler:Infinite_Loop: b Infinite_Loop .size Default_Handler, .-Default_Handler/******************************************************************************** The minimal vector table for a Cortex M3. Note that the proper constructs* must be placed on this to ensure that it ends up at physical address* 0x0000.0000.* *******************************************************************************/ .section .isr_vector,&quot;a&quot;,%progbits .type g_pfnVectors, %object .size g_pfnVectors, .-g_pfnVectors g_pfnVectors: .word _estack .word Reset_Handler .word NMI_Handler .word HardFault_Handler .word MemManage_Handler .word BusFault_Handler .word UsageFault_Handler .word 0 .word 0 .word 0 .word 0 .word SVC_Handler .word DebugMon_Handler .word 0 .word PendSV_Handler .word SysTick_Handler /* External Interrupts */ .word WWDG_IRQHandler /* Window WatchDog */ .word PVD_IRQHandler /* PVD through EXTI Line detection */ .word TAMPER_IRQHandler /* Tamper */ .word RTC_WKUP_IRQHandler /* RTC Wakeup */ .word FLASH_IRQHandler /* FLASH */ .word RCC_IRQHandler /* RCC */ .word EXTI0_IRQHandler /* EXTI Line0 */ .word EXTI1_IRQHandler /* EXTI Line1 */ .word EXTI2_IRQHandler /* EXTI Line2 */ .word EXTI3_IRQHandler /* EXTI Line3 */ .word EXTI4_IRQHandler /* EXTI Line4 */ .word DMA_Channel1_IRQHandler /* DMA1 Channel 1 */ .word DMA_Channel2_IRQHandler /* DMA1 Channel 2 */ .word DMA_Channel3_IRQHandler /* DMA1 Channel 3 */ .word DMA_Channel4_IRQHandler /* DMA1 Channel 4 */ .word DMA_Channel5_IRQHandler /* DMA1 Channel 5 */ .word DMA_Channel6_IRQHandler /* DMA1 Channel 6 */ .word DMA_Channel7_IRQHandler /* DMA1 Channel 7 */ .word DMA_Channel8_IRQHandler /* DMA1 Channel 8 */ .word ADC_IRQHandler /* ADC */ .word USB_HP_IRQHandler /* USB High Priority */ .word USB_LP_IRQHandler /* USB Low Priority */ .word COMP_1_2_IRQHandler /* COMP1 &amp; COMP2 through EXTI line 21/22 */ .word EXTI9_5_IRQHandler /* EXTI Line 9..5 */ .word TIM1_BRK_IRQHandler /* TIM1 Break */ .word TIM1_UP_IRQHandler /* TIM1 Update */ .word TIM1_TRG_COM_IRQHandler /* TIM1 Trigger and Commutation */ .word TIM1_CC_IRQHandler /* TIM1 Capture Compare */ .word TIM2_IRQHandler /* TIM2 */ .word TIM3_IRQHandler /* TIM3 */ .word TIM4_IRQHandler /* TIM4 */ .word I2C1_EV_IRQHandler /* I2C1 Event */ .word I2C1_ER_IRQHandler /* I2C1 Error */ .word I2C2_EV_IRQHandler /* I2C2 Event */ .word I2C2_ER_IRQHandler /* I2C2 Error */ .word SPI1_IRQHandler /* SPI1 */ .word SPI2_IRQHandler /* SPI2 */ .word USART1_IRQHandler /* USART1 */ .word USART2_IRQHandler /* USART2 */ .word USART3_IRQHandler /* USART3 */ .word EXTI15_10_IRQHandler /* EXTI Line 15..10 */ .word RTCAlarm_IRQHandler /* RTC Alarm through EXTI Line */ .word USBWakeUp_IRQHandler /* USB Wakeup from suspend */ .word TIM8_BRK_IRQHandler /* TIM8 Break */ .word TIM8_UP_IRQHandler /* TIM8 Update */ .word TIM8_TRG_COM_IRQHandler /* TIM8 Trigger and Commutation */ .word TIM8_CC_IRQHandler /* TIM8 Capture Compare */ .word UART4_IRQHandler /* UART4 */ .word UART5_IRQHandler /* UART5 */ .word LPUART_IRQHandler /* LPUART */ .word TIM5_IRQHandler /* TIM5 */ .word TIM6_IRQHandler /* TIM6 */ .word TIM7_IRQHandler /* TIM7 */ .word CAN_TX_IRQHandler /* CAN TX */ .word CAN_RX0_IRQHandler /* CAN RX0 */ .word CAN_RX1_IRQHandler /* CAN RX1 */ .word CAN_SCE_IRQHandler /* CAN SCE */ .word LPUART_WKUP_IRQHandler /* LPUART_WKUP */ .word LPTIM_WKUP_IRQHandler /* LPTIM_WKUP */ .word LCD_IRQHandler /* LCD */ .word SAC_IRQHandler /* SAC */ .word MMU_IRQHandler /* MMU */ .word TSC_IRQHandler /* TSC */ .word RAMC_PERR_IRQHandler /* RAMC ERR */ .word TIM9_IRQHandler /* TIM9 */ .word UCDR_IRQHandler /* UCDR ERR *//********************************************************************************* Provide weak aliases for each Exception handler to the Default_Handler. * As they are weak aliases, any function with the same name will override * this definition.* *******************************************************************************/ .weak NMI_Handler .thumb_set NMI_Handler,Default_Handler .weak HardFault_Handler .thumb_set HardFault_Handler,Default_Handler .weak MemManage_Handler .thumb_set MemManage_Handler,Default_Handler .weak BusFault_Handler .thumb_set BusFault_Handler,Default_Handler .weak UsageFault_Handler .thumb_set UsageFault_Handler,Default_Handler .weak SVC_Handler .thumb_set SVC_Handler,Default_Handler .weak DebugMon_Handler .thumb_set DebugMon_Handler,Default_Handler .weak PendSV_Handler .thumb_set PendSV_Handler,Default_Handler .weak SysTick_Handler .thumb_set SysTick_Handler,Default_Handler .weak WWDG_IRQHandler .thumb_set WWDG_IRQHandler,Default_Handler .weak PVD_IRQHandler .thumb_set PVD_IRQHandler,Default_Handler .weak TAMPER_IRQHandler .thumb_set TAMPER_IRQHandler,Default_Handler .weak RTC_WKUP_IRQHandler .thumb_set RTC_WKUP_IRQHandler,Default_Handler .weak FLASH_IRQHandler .thumb_set FLASH_IRQHandler,Default_Handler .weak RCC_IRQHandler .thumb_set RCC_IRQHandler,Default_Handler .weak EXTI0_IRQHandler .thumb_set EXTI0_IRQHandler,Default_Handler .weak EXTI1_IRQHandler .thumb_set EXTI1_IRQHandler,Default_Handler .weak EXTI2_IRQHandler .thumb_set EXTI2_IRQHandler,Default_Handler .weak EXTI3_IRQHandler .thumb_set EXTI3_IRQHandler,Default_Handler .weak EXTI4_IRQHandler .thumb_set EXTI4_IRQHandler,Default_Handler .weak DMA_Channel1_IRQHandler .thumb_set DMA_Channel1_IRQHandler,Default_Handler .weak DMA_Channel2_IRQHandler .thumb_set DMA_Channel2_IRQHandler,Default_Handler .weak DMA_Channel3_IRQHandler .thumb_set DMA_Channel3_IRQHandler,Default_Handler .weak DMA_Channel4_IRQHandler .thumb_set DMA_Channel4_IRQHandler,Default_Handler .weak DMA_Channel5_IRQHandler .thumb_set DMA_Channel5_IRQHandler,Default_Handler .weak DMA_Channel6_IRQHandler .thumb_set DMA_Channel6_IRQHandler,Default_Handler .weak DMA_Channel7_IRQHandler .thumb_set DMA_Channel7_IRQHandler,Default_Handler .weak DMA_Channel8_IRQHandler .thumb_set DMA_Channel8_IRQHandler,Default_Handler .weak ADC_IRQHandler .thumb_set ADC_IRQHandler,Default_Handler .weak USB_HP_IRQHandler .thumb_set USB_HP_IRQHandler,Default_Handler .weak USB_LP_IRQHandler .thumb_set USB_LP_IRQHandler,Default_Handler .weak COMP_1_2_IRQHandler .thumb_set COMP_1_2_IRQHandler,Default_Handler .weak EXTI9_5_IRQHandler .thumb_set EXTI9_5_IRQHandler,Default_Handler .weak TIM1_BRK_IRQHandler .thumb_set TIM1_BRK_IRQHandler,Default_Handler .weak TIM1_UP_IRQHandler .thumb_set TIM1_UP_IRQHandler,Default_Handler .weak TIM1_TRG_COM_IRQHandler .thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler .weak TIM1_CC_IRQHandler .thumb_set TIM1_CC_IRQHandler,Default_Handler .weak TIM2_IRQHandler .thumb_set TIM2_IRQHandler,Default_Handler .weak TIM3_IRQHandler .thumb_set TIM3_IRQHandler,Default_Handler .weak TIM4_IRQHandler .thumb_set TIM4_IRQHandler,Default_Handler .weak I2C1_EV_IRQHandler .thumb_set I2C1_EV_IRQHandler,Default_Handler .weak I2C1_ER_IRQHandler .thumb_set I2C1_ER_IRQHandler,Default_Handler .weak I2C2_EV_IRQHandler .thumb_set I2C2_EV_IRQHandler,Default_Handler .weak I2C2_ER_IRQHandler .thumb_set I2C2_ER_IRQHandler,Default_Handler .weak SPI1_IRQHandler .thumb_set SPI1_IRQHandler,Default_Handler .weak SPI2_IRQHandler .thumb_set SPI2_IRQHandler,Default_Handler .weak USART1_IRQHandler .thumb_set USART1_IRQHandler,Default_Handler .weak USART2_IRQHandler .thumb_set USART2_IRQHandler,Default_Handler .weak USART3_IRQHandler .thumb_set USART3_IRQHandler,Default_Handler .weak EXTI15_10_IRQHandler .thumb_set EXTI15_10_IRQHandler,Default_Handler .weak RTCAlarm_IRQHandler .thumb_set RTCAlarm_IRQHandler,Default_Handler .weak USBWakeUp_IRQHandler .thumb_set USBWakeUp_IRQHandler,Default_Handler .weak TIM8_BRK_IRQHandler .thumb_set TIM8_BRK_IRQHandler,Default_Handler .weak TIM8_UP_IRQHandler .thumb_set TIM8_UP_IRQHandler,Default_Handler .weak TIM8_TRG_COM_IRQHandler .thumb_set TIM8_TRG_COM_IRQHandler,Default_Handler .weak TIM8_CC_IRQHandler .thumb_set TIM8_CC_IRQHandler,Default_Handler .weak UART4_IRQHandler .thumb_set UART4_IRQHandler,Default_Handler .weak UART5_IRQHandler .thumb_set UART5_IRQHandler,Default_Handler .weak LPUART_IRQHandler .thumb_set LPUART_IRQHandler,Default_Handler .weak TIM5_IRQHandler .thumb_set TIM5_IRQHandler,Default_Handler .weak TIM6_IRQHandler .thumb_set TIM6_IRQHandler,Default_Handler .weak TIM7_IRQHandler .thumb_set TIM7_IRQHandler,Default_Handler .weak CAN_TX_IRQHandler .thumb_set CAN_TX_IRQHandler,Default_Handler .weak CAN_RX0_IRQHandler .thumb_set CAN_RX0_IRQHandler,Default_Handler .weak CAN_RX1_IRQHandler .thumb_set CAN_RX1_IRQHandler,Default_Handler .weak CAN_SCE_IRQHandler .thumb_set CAN_SCE_IRQHandler,Default_Handler .weak LPUART_WKUP_IRQHandler .thumb_set LPUART_WKUP_IRQHandler,Default_Handler .weak LPTIM_WKUP_IRQHandler .thumb_set LPTIM_WKUP_IRQHandler,Default_Handler .weak LCD_IRQHandler .thumb_set LCD_IRQHandler,Default_Handler .weak SAC_IRQHandler .thumb_set SAC_IRQHandler,Default_Handler .weak MMU_IRQHandler .thumb_set MMU_IRQHandler,Default_Handler .weak TSC_IRQHandler .thumb_set TSC_IRQHandler,Default_Handler .weak RAMC_PERR_IRQHandler .thumb_set RAMC_PERR_IRQHandler,Default_Handler .weak TIM9_IRQHandler .thumb_set TIM9_IRQHandler,Default_Handler .weak UCDR_IRQHandler .thumb_set UCDR_IRQHandler,Default_Handler /************************ (C) COPYRIGHT Nations Technologies Inc *****END OF FILE****/ 以下为这段assembly代码的注释： .syntax unified 指定统一的ARM和Thumb指令集语法。 .cpu cortex-m4 .fpu softvfp .thumb 指定目标CPU为Cortex-M4，浮点单元为软件实现（softvfp），并使用Thumb指令集。 .global g_pfnVectors .global Default_Handler 声明全局符号g_pfnVectors和Default_Handler，使其在其他汇编文件或C代码中也可访问。 .section .text.Reset_Handler .weak Reset_Handler .type Reset_Handler, %function 定义了一个名为.text.Reset_Handler的代码段，并声明Reset_Handler函数较弱，意味着如果有其他同名函数，将覆盖此声明。 Reset_Handler: 定义Reset_Handler函数的开始。 movs r1, #0 b LoopCopyDataInit 将寄存器r1清零，并跳转到LoopCopyDataInit标签。 CopyDataInit: ldr r3, =_sidata ldr r3, [r3, r1] str r3, [r0, r1] adds r1, r1, #4 定义CopyDataInit代码块，从_sidata地址开始复制初始化数据到数据段(_sdata至_edata)。 LoopCopyDataInit: ldr r0, =_sdata ldr r3, =_edata adds r2, r0, r1 cmp r2, r3 bcc CopyDataInit 创建一个循环，将初始化数据从_sidata复制到_sdata，直到_edata。 ldr r2, =_sbss b LoopFillZerobss 将r2寄存器加载到BSS段的起始地址，并跳转到LoopFillZerobss。 FillZerobss: movs r3, #0 str r3, [r2], #4 将BSS段的每个位置初始化为0。 LoopFillZerobss: ldr r3, = _ebss cmp r2, r3 bcc FillZerobss 创建一个循环，将BSS段从_sbss到_ebss的所有字节初始化为0。 bl SystemInit bl __libc_init_array bl main bx lr 调用系统初始化函数SystemInit，调用C++静态对象构造函数__libc_init_array，然后调用main函数，并从Reset_Handler返回。 .size Reset_Handler, .-Reset_Handler 指定Reset_Handler函数的大小。 .section .text.Default_Handler,&quot;ax&quot;,%progbits 定义一个新的代码段，用于默认的中断处理函数。 Default_Handler:Infinite_Loop: b Infinite_Loop定义Default_Handler函数，如果处理器接收到未处理的中断，则进入无限循环。 .size Default_Handler, .-Default_Handler 指定Default_Handler函数的大小。 .section .isr_vector,&quot;a&quot;,%progbits 定义中断向量表的代码段。 g_pfnVectors: 定义中断向量表的开始。 .word _estack .word Reset_Handler ... 中断向量表包含了系统堆栈的顶端、重置处理程序的地址和其他中断处理程序的地址。 .weak NMI_Handler .thumb_set NMI_Handler,Default_Handler 声明NMI_Handler为弱引用，并将其默认地址设置为Default_Handler。这段代码的其余部分继续定义中断向量表和提供中断处理程序的弱引用，以便在没有提供特定中断处理程序时使用默认处理程序。","tags":"mcu"},{"title":"CMake学习笔记","url":"/2024/05/08/CMake学习笔记/","text":"CMake学习教程 [参考资料1] : https://subingwen.cn/cmake/CMake-primer [参考资料2] : https://subingwen.cn/cmake/CMake-advanced/ [参考资料3] : https://zhuanlan.zhihu.com/p/534439206 编写一个简单的CMakeLists.txt文件1. 示例文件的目录结构如下：12345678$ tree.├── add.c├── div.c├── head.h├── main.c├── mult.c└── sub.c 2. 添加 CMakeLists.txt 文件在上述源文件所在目录下添加一个新文件 CMakeLists.txt，文件内容如下： 123cmake_minimum_required(VERSION 3.0)project(CALC)add_executable(app add.c div.c main.c mult.c sub.c) cmake_minimum_required：指定使用的 cmake 的最低版本。 可选，非必须，如果不加可能会有警告。 project：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。 add_executable：定义工程会生成一个可执行程序。 1add_executable(可执行程序名 源文件名称) 这里的可执行程序名和project中的项目名没有任何关系 源文件名可以是一个也可以是多个，如有多个可用空格或;间隔 1234# 样式1add_executable(app add.c div.c main.c mult.c sub.c)# 样式2add_executable(app add.c;div.c;main.c;mult.c;sub.c) 3. 执行CMake命令12# cmake 命令原型$ cmake CMakeLists.txt 文件所在路径 执行示例 (当前CMakeLists.txt路径) ： 1$ cmake . 当执行cmake命令之后，CMakeLists.txt 中的命令就会被执行，所以一定要注意给cmake命令指定路径的时候一定不能出错。 执行命令之后，看一下源文件所在目录中是否多了一些文件： 12345678910111213$ tree -L 1.├── add.c├── CMakeCache.txt # new add file├── CMakeFiles # new add dir├── cmake_install.cmake # new add file├── CMakeLists.txt├── div.c├── head.h├── main.c├── Makefile # new add file├── mult.c└── sub.c 我们可以看到在对应的目录下生成了一个makefile文件，此时再执行make命令，就可以对项目进行构建得到所需的可执行程序了。 4. 头文件及指定宏 CMakeLists.txt 示例代码文件：12345678cmake_minimum_required(VERSION 3.0)project(CALC)set(CMAKE_CXX_STANDARD 11)set(HOME /home/robin/Linux/calc)set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin/)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)add_executable(app $&#123;SRC_LIST&#125;) 4.1 通过参数-std=c++11指定出要使用c++11标准编译程序,对应宏DCMAKE_CXX_STANDARD:12# 增加-std=c++11set(CMAKE_CXX_STANDARD 11) 12# 增加-std=c++11cmake (CMakeLists.txt文件路径) -DCMAKE_CXX_STANDARD=11 4.2 指定输出的路径(EXECUTABLE_OUTPUT_PATH)：12set(HOME /home/robin/Linux/Sort)set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin) 如果这个路径中的子目录不存在，会自动生成，无需自己手动创建。 4.3 头文件的路径(include_directories)1include_directories(headpath) 其中，第六行指定就是头文件的路径，PROJECT_SOURCE_DIR宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。 4.4 搜索文件(aux_source_directory) aux_source_directory(&lt; dir &gt; &lt; variable &gt;) 示例： 1aux_source_directory($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src SRC_LIST) file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)示例： 12file(GLOB MAIN_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)file(GLOB MAIN_HEAD $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/*.h) CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径 5. 制作动态库或静态库有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。 5.1 静态库：5.1.1 cmake生成规则：1add_library(库名称 STATIC 源文件1 [源文件2] ...) 在Linux中，静态库名字分为三部分：lib + 库名字 + .a，示例：12345cmake_minimum_required(VERSION 3.0)project(CALC)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)file(GLOB SRC_LIST &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;)add_library(calc STATIC $&#123;SRC_LIST&#125;) 这样最终就会生成对应的静态库文件 libcalc.a 5.1.2 gcc生成规则：1gcc -c add.c div.c mult.c sub.c -I ./include/ 生成 .o 编译文件 1234567891011121314# 查看目录中的文件$ tree.├── add.c├── add.o # 目标文件├── div.c├── div.o # 目标文件├── include│ └── head.h├── main.c├── mult.c├── mult.o # 目标文件├── sub.c└── sub.o # 目标文件 将生成的目标文件通过 ar工具打包生成静态库 123456789101112131415161718# 将生成的目标文件 .o 打包成静态库$ ar rcs libcalc.a add.o div.o mult.o sub.o #在同一个目录中可以写成 *.o# 查看目录中的文件$ tree.├── add.c├── add.o├── div.c├── div.o├── include│ └── `head.h ===&gt; 和静态库一并发布├── `libcalc.a ===&gt; 生成的静态库├── main.c├── mult.c├── mult.o├── sub.c└── sub.o 将生成的的静态库 libcalc.a和库对应的头文件head.h一并发布给使用者就可以了。 123# 3. 发布静态库 1. head.h =&gt; 函数声明 2. libcalc.a =&gt; 函数定义(二进制格式) 5.1.3 gcc静态库的使用:12345678# 首先拿到了发布的静态库 `head.h` 和 `libcalc.a` # 将静态库, 头文件, 测试程序放到一个目录中准备进行测试.├── head.h # 函数声明├── libcalc.a # 函数定义（二进制格式）└── main.c # 函数测试 编译测试程序, 得到可执行文件。 1234567891011121314# 编译的时候指定库信息 -I: 指定头文件所在的目录(相对或者绝对路径) -L: 指定库所在的目录(相对或者绝对路径) -l: 指定库的名字, 掐头(lib)去尾(.a) ==&gt; calc# -L -l, 参数和参数值之间可以有空格, 也可以没有 -L./ -lcalc$ gcc main.c -o app -I./ -L./ -lcalc# 查看目录信息, 发现可执行程序已经生成了$ tree.├── app # 生成的可执行程序├── head.h├── libcalc.a└── main.c 5.2 动态库：5.2.1 cmake生成规则：1add_library(库名称 SHARED 源文件1 [源文件2] ...) 在Linux中，动态库名字分为三部分：lib + 库名字 + .so ，示例：1add_library(calc SHARED $&#123;SRC_LIST&#125;) 这样最终就会生成对应的动态库文件 libcalc.so 5.1.2 gcc生成规则： 生成动态链接库是直接使用gcc命令并且需要添加-fPIC(-fpic) 以及-shared 参数。 -fPIC 或 -fpic 参数的作用是使得 gcc 生成的代码是与位置无关的，也就是使用相对位置。 -shared参数的作用是告诉编译器生成一个动态链接库。 12# 1. 将.c汇编得到.o, 需要额外的参数 -fpic/-fPIC$ gcc -c -fpic add.c div.c mult.c sub.c -I ./include/ 生成 .o 编译文件 1234567891011121314# 查看目录文件信息, 检查是否生成了目标文件$ tree.├── add.c├── add.o # 生成的目标文件├── div.c├── div.o # 生成的目标文件├── include│ └── head.h├── main.c├── mult.c├── mult.o # 生成的目标文件├── sub.c└── sub.o # 生成的目标文件 使用gcc将得到的目标文件打包生成动态库, 需要使用参数 -shared 123456789101112131415161718# 2. 将得到 .o 打包成动态库, 使用gcc , 参数 -shared$ gcc -shared add.o div.o mult.o sub.o -o libcalc.so # 检查目录中是否生成了动态库$ tree.├── add.c├── add.o├── div.c├── div.o├── include│ └── `head.h ===&gt; 和动态库一起发布├── `libcalc.so ===&gt; 生成的动态库├── main.c├── mult.c├── mult.o├── sub.c└── sub.o 将生成的的动态库 libcalc.so和库对应的头文件head.h一并发布给使用者就可以了。 123# 发布库文件和头文件 1. head.h 2. libcalc.so 5.1.3 gcc静态库的使用:123456789# 1. 拿到发布的动态库 `head.h libcalc.so# 2. 基于头文件编写测试程序, 测试动态库中提供的接口是否可用 `main.c`# 示例目录:.├── head.h ==&gt; 函数声明├── libcalc.so ==&gt; 函数定义└── main.c ==&gt; 函数测试 编译测试程序, 得到可执行文件。 1234567891011121314# 在编译的时候指定动态库相关的信息: 头文件路径-I 库的路径 -L, 库的名字 -l$ gcc main.c -o app -I./ -L./ -lcalc# 查看是否生成了可执行程序$ tree.├── app # 生成的可执行程序├── head.h├── libcalc.so└── main.c# 执行生成的可执行程序, 错误提示 ==&gt; 可执行程序执行的时候找不到动态库$ ./app ./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory 修改解决动态库链接编译问题 方案 1: 将库路径添加到环境变量LD_LIBRARY_PATH中 找到相关的配置文件 用户级别: ~&#x2F;.bashrc —&gt; 设置对当前用户有效 系统级别: &#x2F;etc&#x2F;profile —&gt; 设置对所有用户有效 使用 vim 打开配置文件, 在文件最后添加这样一句话 12# 自己把路径写进去就行了export LD_LIBRARY_PATH =$LD_LIBRARY_PATH :动态库的绝对路径 让修改的配置文件生效 修改了用户级别的配置文件, 关闭当前终端, 打开一个新的终端配置就生效了 修改了系统级别的配置文件, 注销或关闭系统, 再开机配置就生效了 不想执行上边的操作, 可以执行一个命令让配置重新被加载 1234# 修改的是哪一个就执行对应的那个命令# source 可以简写为一个 . , 作用是让文件内容被重新加载$ source ~/.bashrc (. ~/.bashrc)$ source /etc/profile (. /etc/profile) 方案 2: 更新 &#x2F;etc&#x2F;ld.so.cache 文件 找到动态库所在的绝对路径（不包括库的名字）比如：&#x2F;home&#x2F;robin&#x2F;Library&#x2F; 使用vim 修改 &#x2F;etc&#x2F;ld.so.conf 这个文件, 将上边的路径添加到文件中(独自占一行) 1234# 1. 打开文件$ sudo vim /etc/ld.so.conf# 2. 添加动态库路径, 并保存退出 更新 &#x2F;etc&#x2F;ld.so.conf中的数据到 &#x2F;etc&#x2F;ld.so.cache 中 12# 必须使用管理员权限执行这个命令$ sudo ldconfig 方案 3: 拷贝动态库文件到系统库目录 &#x2F;lib&#x2F; 或者 &#x2F;usr&#x2F;lib 中 (或者将库的软链接文件放进去) 12345# 库拷贝sudo cp /xxx/xxx/libxxx.so /usr/lib# 创建软连接sudo ln -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so 验证执行命令： 123456789# 语法:$ ldd 可执行程序名# 举例:$ ldd app linux-vdso.so.1 =&gt; (0x00007ffe8fbd6000) libcalc.so =&gt; /home/robin/Linux/3Day/calc/test/libcalc.so (0x00007f5d85dd4000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5d85a0a000) /lib64/ld-linux-x86-64.so.2 (0x00007f5d85fd6000) ==&gt; 动态链接器, 操作系统提供 5.3 指定输出的路径： 方式1 - 适用于动态库 1set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib) 方式2 - 都适用 12# 设置动态库/静态库生成路径set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib) 5.4 包含库文件：5.4.1 链接静态库：123456src├── add.cpp├── div.cpp├── main.cpp├── mult.cpp└── sub.cpp 现在我们把上面src目录中的add.cpp、div.cpp、mult.cpp、sub.cpp编译成一个静态库文件libcalc.a。通过命令制作并使用静态链接库。 测试目录结构如下： 123456789101112$ tree .├── build├── CMakeLists.txt├── include│ └── head.h├── lib│ └── libcalc.a # 制作出的静态库的名字└── src └── main.cpp4 directories, 4 files 在cmake中，链接静态库的命令如下： 1link_libraries(&lt;static lib&gt; [&lt;static lib&gt;...]) 参数1：指定出要链接的静态库的名字 可以是全名 libxxx.a 也可以是掐头（lib）去尾（.a）之后的名字 xxx 参数2-N：要链接的其它静态库的名字 如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来： 1link_directories(&lt;lib path&gt;) 这样，修改之后的CMakeLists.txt文件内容如下: 1234567891011cmake_minimum_required(VERSION 3.0)project(CALC)# 搜索指定目录下源文件file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)# 包含头文件路径include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)# 包含静态库路径link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)# 链接静态库link_libraries(calc)add_executable(app $&#123;SRC_LIST&#125;) 5.4.2 链接动态库：动态库的链接和静态库是完全不同的： 静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。 动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存 因此，在cmake中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后： 1234567cmake_minimum_required(VERSION 3.0)project(TEST)file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)# 添加并指定最终生成的可执行程序名add_executable(app $&#123;SRC_LIST&#125;)# 指定可执行程序要链接的动态库名字target_link_libraries(app pthread) 在target_link_libraries(app pthread)中： app: 对应的是最终生成的可执行程序的名字 pthread：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为libpthread.so，在指定的时候一般会掐头（lib）去尾（.so）。 123456cmake_minimum_required(VERSION 3.0)project(TEST)file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)add_executable(app $&#123;SRC_LIST&#125;)target_link_libraries(app pthread calc) 在第六行中，pthread、calc都是可执行程序app要链接的动态库的名字。当可执行程序app生成之后并执行该文件，会提示有如下错误信息： 12$ ./app ./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory 在 CMake 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令： 1link_directories(path) 所以修改之后的CMakeLists.txt文件应该是这样的： 1234567891011cmake_minimum_required(VERSION 3.0)project(TEST)file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)# 指定源文件或者动态库对应的头文件路径include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)# 指定要链接的动态库的路径link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)# 添加并生成一个可执行程序add_executable(app $&#123;SRC_LIST&#125;)# 指定要链接的动态库target_link_libraries(app pthread calc) 通过link_directories指定了动态库的路径之后，在执行生成的可执行程序的时候，就不会出现找不到动态库的问题了。 温馨提示：使用 target_link_libraries 命令就可以链接动态库，也可以链接静态库文件。 6. 日志在CMake中可以用用户显示一条消息，该命令的名字为message： 1message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] &quot;message to display&quot; ...) (无) ：重要消息 STATUS ：非重要消息 WARNING：CMake 警告, 会继续执行 AUTHOR_WARNING：CMake 警告 (dev), 会继续执行 SEND_ERROR：CMake 错误, 继续执行，但是会跳过生成的步骤 FATAL_ERROR：CMake 错误, 终止所有处理过程 CMake的命令行工具会在stdout上显示STATUS消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。 CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。 123456# 输出一般日志信息message(STATUS &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)# 输出警告信息message(WARNING &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)# 输出错误信息message(FATAL_ERROR &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;) 7. 变量操作7.1 追加有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过file命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用set命令也可以使用list命令。 7.1.1 使用set拼接如果使用set进行字符串拼接，对应的命令格式如下： 1set(变量名1 $&#123;变量名1&#125; $&#123;变量名2&#125; ...) 关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。 12345678cmake_minimum_required(VERSION 3.0)project(TEST)set(TEMP &quot;hello,world&quot;)file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/src1/*.cpp)file(GLOB SRC_2 $&#123;PROJECT_SOURCE_DIR&#125;/src2/*.cpp)# 追加(拼接)set(SRC_1 $&#123;SRC_1&#125; $&#123;SRC_2&#125; $&#123;TEMP&#125;)message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;) 7.1.2 使用list拼接list命令的功能比set要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，APPEND表示进行数据追加，后边的参数和set就一样了。 1list(APPEND &lt;list&gt; [&lt;element&gt; ...]) 7.2 字符串移除使用list命令，REMOVE_ITEM表示对数据进行移除 1list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...]) 例子： 12345678910cmake_minimum_required(VERSION 3.0)project(TEST)set(TEMP &quot;hello,world&quot;)file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/*.cpp)# 移除前日志message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;)# 移除 main.cpplist(REMOVE_ITEM SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/main.cpp)# 移除后日志message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;) 8. 宏定义在CMake中，对应的命令叫做add_definitions: 1add_definitions(-D宏名称) 例子： 12345cmake_minimum_required(VERSION 3.0)project(TEST)# 自定义 DEBUG 宏add_definitions(-DDEBUG)add_executable(app ./test.c) 9. 预定义宏下面的列表中为大家整理了一些CMake中常用的宏： 宏 功能 PROJECT_SOURCE_DIR 使用cmake命令后紧跟的目录，一般是工程的根目录 PROJECT_BINARY_DIR 执行cmake命令的目录 CMAKE_CURRENT_SOURCE_DIR 当前处理的CMakeLists.txt所在的路径 CMAKE_CURRENT_BINARY_DIR target 编译目录 EXECUTABLE_OUTPUT_PATH 重新定义目标二进制可执行文件的存放位置 LIBRARY_OUTPUT_PATH 重新定义目标链接库文件的存放位置 PROJECT_NAME 返回通过PROJECT指令定义的项目名称 CMAKE_BINARY_DIR 项目实际构建路径，假设在build目录进行的构建，那么得到的就是这个目录的路径 10. 嵌套的CMake如果项目很大，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果只使用一个CMakeLists.txt，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个CMakeLists.txt文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。 先来看一下下面的这个的目录结构： 12345678910111213141516171819202122232425$ tree.├── build├── calc│ ├── add.c│ ├── CMakeLists.txt│ ├── div.c│ ├── mult.c│ └── sub.c├── CMakeLists.txt├── include│ ├── calc.h│ └── sort.h├── sort│ ├── CMakeLists.txt│ ├── insert.c│ └── select.c├── test1│ ├── calc.cpp│ └── CMakeLists.txt└── test2 ├── CMakeLists.txt └── sort.c6 directories, 15 files include 目录：头文件目录 calc 目录：目录中的四个源文件对应的加、减、乘、除算法 对应的头文件是include中的calc.h sort 目录 ：目录中的两个源文件对应的是插入排序和选择排序算法 对应的头文件是include中的sort.h test1 目录：测试目录，对加、减、乘、除算法进行测试 test2 目录：测试目录，对排序算法进行测试 可以看到各个源文件目录所需要的CMakeLists.txt文件现在已经添加完毕了。接下来庖丁解牛，我们依次分析一下各个文件中需要添加的内容。 10.1 节点关系众所周知，Linux的目录是树状结构，所以嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。因此，我们需要了解一些关于 CMakeLists.txt 文件变量作用域的一些信息： 根节点CMakeLists.txt中的变量全局有效 父节点CMakeLists.txt中的变量可以在子节点中使用 子节点CMakeLists.txt中的变量只能在当前节点中使用 10.2 添加子目录1add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) source_dir：指定了CMakeLists.txt源文件和代码文件的位置，其实就是指定子目录 binary_dir：指定了输出文件的路径，一般不需要指定，忽略即可。 EXCLUDE_FROM_ALL：在子路径下的目标默认不会被包含到父路径的ALL目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。 通过这种方式CMakeLists.txt文件之间的父子关系就被构建出来了。 10.3 编写CMakeLists.txt文件10.3.1 根目录根目录中的 CMakeLists.txt文件内容如下： 1234567891011121314151617181920cmake_minimum_required(VERSION 3.0)project(test)# 定义变量# 静态库生成的路径set(LIB_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)# 测试程序生成的路径set(EXEC_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/bin)# 头文件目录set(HEAD_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)# 静态库的名字set(CALC_LIB calc)set(SORT_LIB sort)# 可执行程序的名字set(APP_NAME_1 test1)set(APP_NAME_2 test2)# 添加子目录add_subdirectory(calc)add_subdirectory(sort)add_subdirectory(test1)add_subdirectory(test2) 在根节点对应的文件中主要做了两件事情：定义全局变量和添加子目录。 定义的全局变量主要是给子节点使用，目的是为了提高子节点中的CMakeLists.txt文件的可读性和可维护性，避免冗余并降低出差的概率。 一共添加了四个子目录，每个子目录中都有一个CMakeLists.txt文件，这样它们的父子关系就被确定下来了。 10.3.2 calc 目录calc 目录中的 CMakeLists.txt文件内容如下： 123456cmake_minimum_required(VERSION 3.0)project(CALCLIB)aux_source_directory(./ SRC)include_directories($&#123;HEAD_PATH&#125;)set(LIBRARY_OUTPUT_PATH $&#123;LIB_PATH&#125;)add_library($&#123;CALC_LIB&#125; STATIC $&#123;SRC&#125;) 第3行aux_source_directory：搜索当前目录（calc目录）下的所有源文件 第4行include_directories：包含头文件路径，HEAD_PATH是在根节点文件中定义的 第5行set：设置库的生成的路径，LIB_PATH是在根节点文件中定义的 第6行add_library：生成静态库，静态库名字CALC_LIB是在根节点文件中定义的 10.3.2 sort 目录sort 目录中的 CMakeLists.txt文件内容如下： 123456cmake_minimum_required(VERSION 3.0)project(CALCLIB)aux_source_directory(./ SRC)include_directories($&#123;HEAD_PATH&#125;)set(LIBRARY_OUTPUT_PATH $&#123;LIB_PATH&#125;)add_library($&#123;CALC_LIB&#125; SHARED $&#123;SRC&#125;) 第6行add_library：生成动态库，动态库名字SORT_LIB是在根节点文件中定义的 这个文件中的内容和calc节点文件中的内容类似，只不过这次生成的是动态库。 10.3.3 test1 目录test1 目录中的 CMakeLists.txt文件内容如下： 12345678cmake_minimum_required(VERSION 3.0)project(CALCTEST)aux_source_directory(./ SRC)include_directories($&#123;HEAD_PATH&#125;)link_directories($&#123;LIB_PATH&#125;)link_libraries($&#123;CALC_LIB&#125;)set(EXECUTABLE_OUTPUT_PATH $&#123;EXEC_PATH&#125;)add_executable($&#123;APP_NAME_1&#125; $&#123;SRC&#125;) 第4行include_directories：指定头文件路径，HEAD_PATH变量是在根节点文件中定义的 第6行link_libraries：指定可执行程序要链接的静态库，CALC_LIB变量是在根节点文件中定义的 第7行set：指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的 第8行add_executable：生成可执行程序，APP_NAME_1变量是在根节点文件中定义的 此处的可执行程序链接的是静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被加载到内存中了。 10.3.4 test2 目录test2 目录中的 CMakeLists.txt文件内容如下： 12345678cmake_minimum_required(VERSION 3.0)project(SORTTEST)aux_source_directory(./ SRC)include_directories($&#123;HEAD_PATH&#125;)set(EXECUTABLE_OUTPUT_PATH $&#123;EXEC_PATH&#125;)link_directories($&#123;LIB_PATH&#125;)add_executable($&#123;APP_NAME_2&#125; $&#123;SRC&#125;)target_link_libraries($&#123;APP_NAME_2&#125; $&#123;SORT_LIB&#125;) 第四行include_directories：包含头文件路径，HEAD_PATH变量是在根节点文件中定义的 第五行set：指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的 第六行link_directories：指定可执行程序要链接的动态库的路径，LIB_PATH变量是在根节点文件中定义的 第七行add_executable：生成可执行程序，APP_NAME_2变量是在根节点文件中定义的 第八行target_link_libraries：指定可执行程序要链接的动态库的名字 在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库。 注意：引用变量要使用{},不要用成() set(EXECUTABLE_OUTPUT_PATH $&#123;EXEC_PATH&#125;) 写成如下就会出错： set(EXECUTABLE_OUTPUT_PATH $(EXEC_PATH)) 就会出错 10.3.4 构建项目1234567891011121314151617181920212223242526272829303132333435xuan@DESKTOP-A52B6V9:~/linux/demos/cpro$ cd build/xuan@DESKTOP-A52B6V9:~/linux/demos/cpro/build$ cmake ..-- The C compiler identification is GNU 11.4.0-- The CXX compiler identification is GNU 11.4.0-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working C compiler: /usr/bin/cc - skipped-- Detecting C compile features-- Detecting C compile features - done-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: /usr/bin/c++ - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- Configuring done-- Generating done-- Build files have been written to: /home/xuan/linux/demos/cpro/buildxuan@DESKTOP-A52B6V9:~/linux/demos/cpro/build$ make[ 8%] Building C object calc/CMakeFiles/calc.dir/add.c.o[ 16%] Building C object calc/CMakeFiles/calc.dir/div.c.o[ 25%] Building C object calc/CMakeFiles/calc.dir/mult.c.o[ 33%] Building C object calc/CMakeFiles/calc.dir/sub.c.o[ 41%] Linking C static library ../../lib/libcalc.a[ 41%] Built target calc[ 50%] Building C object sort/CMakeFiles/sort.dir/insert.c.o[ 58%] Building C object sort/CMakeFiles/sort.dir/select.c.o[ 66%] Linking C shared library ../../lib/libsort.so[ 66%] Built target sort[ 75%] Building C object test2/CMakeFiles/test2.dir/sort.c.o[ 83%] Linking C executable ../../bin/test2[ 83%] Built target test2[ 91%] Building C object test1/CMakeFiles/test1.dir/calc.c.o[100%] Linking C executable ../../bin/test1[100%] Built target test1 通过上述log可以得到如下信息： 在项目根目录的lib目录中生成了静态库libcalc.a 在项目根目录的lib目录中生成了动态库libsort.so 在项目根目录的bin目录中生成了可执行程序test1 在项目根目录的bin目录中生成了可执行程序test2 以下是生成的树状图： 1234567$ tree bin/ lib/bin/├── test1└── test2lib/├── libcalc.a└── libsort.so 在项目中，如果将程序中的某个模块制作成了动态库或者静态库并且在CMakeLists.txt 中指定了库的输出目录，而后其它模块又需要加载这个生成的库文件，此时直接使用就可以了。 如果没有指定库的输出路径或者需要直接加载外部提供的库文件，此时就需要使用link_directories($&#123;LIB_PATH&#125;)将库文件路径指定出来,然后链接库的名字link_libraries($&#123;CALC_LIB&#125;)。 11. 流程控制11.1 条件判断1234567if(&lt;condition&gt;) &lt;commands&gt;elseif(&lt;condition&gt;) # 可选快, 可以重复 &lt;commands&gt;else() # 可选快 &lt;commands&gt;endif() 11.1.1 基本表达式 if(&lt;expression&gt;): expression 有以下三种情况：常量、变量、字符串。 如果是1, ON, YES, TRUE, Y, 非零值，非空字符串时，条件判断返回True 如果是 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND，空字符串时，条件判断返回False 11.1.2 逻辑判断 if(NOT ) if( AND ) if( OR ) 11.1.3 比较 if(&lt;variable|string&gt; &lt;COMMAND&gt; &lt;variable|string&gt;) &lt;COMMAND&gt;为如下值的解释： LESS：如果左侧数值&#x2F;字符串小于右侧，返回True GREATER：如果左侧数值&#x2F;字符串大于右侧，返回True EQUAL：如果左侧数值&#x2F;字符串等于右侧，返回True LESS_EQUAL：如果左侧数值&#x2F;字符串小于等于右侧，返回True GREATER_EQUAL：如果左侧数值&#x2F;字符串大于等于右侧，返回True 11.1.4 文件操作存在&#x2F;是返回True，不存在&#x2F;否返回False 判断文件或者目录是否存在：if(EXISTS path-to-file-or-directory) 判断是不是目录：if(IS_DIRECTORY path) 此处目录的 path 必须是绝对路径 判断是不是软连接：if(IS_SYMLINK file-name) 此处的 file-name 对应的路径必须是绝对路径 软链接相当于 Windows 里的快捷方式 判断是不是绝对路径：if(IS_ABSOLUTE path) 如果绝对路径是Linux，该路径需要从根目录开始描述 如果绝对路径是Windows，该路径需要从盘符开始描述 11.1.5 其他 判断某个元素是否在列表中：if(&lt;variable|string&gt; IN_LIST &lt;variable&gt;) 比较两个路径是否相等：if(&lt;variable|string&gt; PATH_EQUAL &lt;variable|string&gt;) 11.2 循环在 CMake 中循环有两种方式，分别是：foreach和while。 11.2.1 foreach使用 foreach 进行循环，语法格式如下： 123foreach(&lt;loop_var&gt; &lt;items&gt;) &lt;commands&gt;endforeach() foreach(&lt;loop_var&gt; RANGE &lt;stop&gt;) RANGE：关键字，表示要遍历范围 stop：这是一个正整数，表示范围的结束值，在遍历的时候从 0 开始，最大值为 stop。 loop_var：存储每次循环取出的值 123456cmake_minimum_required(VERSION 3.2)project(test)# 循环foreach(item RANGE 10) message(STATUS &quot;当前遍历的值为: $&#123;item&#125;&quot; )endforeach() 上面例子输出0~10 foreach(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;]) RANGE：关键字，表示要遍历范围 start：这是一个正整数，表示范围的起始值，也就是说最小值为 start stop：这是一个正整数，表示范围的结束值，也就是说最大值为 stop step：控制每次遍历的时候以怎样的步长增长，默认为1，可以不设置 -loop_var：存储每次循环取出的值 123456cmake_minimum_required(VERSION 3.2)project(test)foreach(item RANGE 10 30 2) message(STATUS &quot;当前遍历的值为: $&#123;item&#125;&quot; )endforeach() 上面例子输出10~30,从10开始,每次增长2。 foreach(&lt;loop_var&gt; IN [LISTS [&lt;lists&gt;]] [ITEMS [&lt;items&gt;]]) IN：关键字，表示在 xxx 里边 LISTS：关键字，对应的是列表list，通过set、list可以获得 ITEMS：关键字，对应的也是列表 loop_var：存储每次循环取出的值 123456789cmake_minimum_required(VERSION 3.2)project(test)# 创建 listset(WORD a b c d)set(NAME ace sabo luffy)# 遍历 listforeach(item IN LISTS WORD NAME) message(STATUS &quot;当前遍历的值为: $&#123;item&#125;&quot; )endforeach() 在上面的例子中，创建了两个 list 列表，在遍历的时候对它们两个都进行了遍历（可以根据实际需求选择同时遍历多个或者只遍历一个） 12345678cmake_minimum_required(VERSION 3.2)project(test)set(WORD a b c &quot;d e f&quot;)set(NAME ace sabo luffy)foreach(item IN ITEMS $&#123;WORD&#125; $&#123;NAME&#125;) message(STATUS &quot;当前遍历的值为: $&#123;item&#125;&quot; )endforeach() 在上面的例子中，遍历过程中将关键字LISTS改成了ITEMS，后边跟的还是一个或者多个列表，只不过此时需要通过$&#123;&#125;将列表中的值取出。其输出的信息和上一个例子是一样的： 123456789101112$ cd build/$ cmake ..-- 当前遍历的值为: a-- 当前遍历的值为: b-- 当前遍历的值为: c-- 当前遍历的值为: d e f-- 当前遍历的值为: ace-- 当前遍历的值为: sabo-- 当前遍历的值为: luffy-- Configuring done-- Generating done-- Build files have been written to: /home/robin/abc/a/build 小细节：在通过 set 组织列表的时候，如果某个字符串中有空格，可以通过双引号将其包裹起来，具体的操作方法可以参考上面的例子。 foreach(&lt;loop_var&gt;... IN ZIP_LISTS &lt;lists&gt;) loop_var：存储每次循环取出的值，可以根据要遍历的列表的数量指定多个变量，用于存储对应的列表当前取出的那个值。 如果指定了多个变量名，它们的数量应该和列表的数量相等 如果只给出了一个 loop_var，那么它将一系列的 loop_var_N 变量来存储对应列表中的当前项，也就是说 loop_var_0 对应第一个列表，loop_var_1 对应第二个列表，以此类推…… 如果遍历的多个列表中一个列表较短，当它遍历完成之后将不会再参与后续的遍历（因为其它列表还没有遍历完）。 IN：关键字，表示在 xxx 里边 ZIP_LISTS：关键字，对应的是列表list，通过set 、list可以获得 123456789101112131415cmake_minimum_required(VERSION 3.17)project(test)# 通过list给列表添加数据list(APPEND WORD hello world &quot;hello world&quot;)list(APPEND NAME ace sabo luffy zoro sanji)# 遍历列表foreach(item1 item2 IN ZIP_LISTS WORD NAME) message(STATUS &quot;当前遍历的值为: item1 = $&#123;item1&#125;, item2=$&#123;item2&#125;&quot; )endforeach()message(&quot;=============================&quot;)# 遍历列表foreach(item IN ZIP_LISTS WORD NAME) message(STATUS &quot;当前遍历的值为: item1 = $&#123;item_0&#125;, item2=$&#123;item_1&#125;&quot; )endforeach() 在这个例子中关于列表数据的添加是通过list来实现的。在遍历列表的时候一共使用了两种方式，一种提供了多个变量来存储当前列表中的值，另一种只有一个变量，但是实际取值的时候需要通过变量名_0、变量名_1、变量名_N 的方式来操作，注意事项：第一个列表对应的编号是0，第一个列表对应的编号是0，第一个列表对应的编号是0。 上面的例子输出的结果如下： 12345678910111213141516$ cd build/$ cmake ..-- 当前遍历的值为: item1 = hello, item2=ace-- 当前遍历的值为: item1 = world, item2=sabo-- 当前遍历的值为: item1 = hello world, item2=luffy-- 当前遍历的值为: item1 = , item2=zoro-- 当前遍历的值为: item1 = , item2=sanji=============================-- 当前遍历的值为: item1 = hello, item2=ace-- 当前遍历的值为: item1 = world, item2=sabo-- 当前遍历的值为: item1 = hello world, item2=luffy-- 当前遍历的值为: item1 = , item2=zoro-- 当前遍历的值为: item1 = , item2=sanji-- Configuring done (0.0s)-- Generating done (0.0s)-- Build files have been written to: /home/robin/abc/a/build 11.2.2 while123while(&lt;condition&gt;) &lt;commands&gt;endwhile() while 比较简单就不做描述了。 12. cmake设置编译器12.1 命令行在命令行中指定编译器，你可以在调用 cmake 命令时使用 -DCMAKE_C_COMPILER 和 -DCMAKE_CXX_COMPILER 选项来分别为C和C++设置编译器。例如： 1cmake -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ /path/to/source 12.2 CMakeLists.txt在项目的 CMakeLists.txt 文件中，你可以使用 set 命令来指定编译器： 12set(CMAKE_C_COMPILER /user/bin/gcc)set(CMAKE_CXX_COMPILER /user/bin/g++) 12.3 工具链文件CMake允许使用所谓的“工具链文件”（toolchain file）来指定编译器和工具链设置。这在跨平台构建时非常有用。工具链文件是一个普通的CMake脚本，它设置了构建系统所需的编译器和工具链选项。例如，创建一个名为 toolchain.cmake 的文件，并在其中设置编译器： set(CMAKE_C_COMPILER gcc) set(CMAKE_CXX_COMPILER g++) 然后在调用 cmake 命令时指定工具链文件： cmake -DCMAKE_TOOLCHAIN_FILE=path/to/toolchain.cmake /path/to/source 请记住，一旦CMake缓存生成，更改编译器的设置就需要清理CMake缓存并重新运行CMake配置。这是因为CMake在第一次运行时会将编译器和工具链的信息缓存起来，以便后续构建使用。","tags":"linux cmake"},{"title":"Makefile笔记","url":"/2024/05/08/Makefile笔记/","text":"makefile问题汇总修改.h文件没有重新编译 定义COMPILE_FLAGS = -MD或者-MMD, 编译器标志，用于生成 .d 文件 $(BUILD_DIR)为编译文件目录，跟进自身makefile修改，原来的编译规则： 1-include $(wildcard $(BUILD_DIR)/*/*.d) # 包含所有生成的依赖文件，避免重复编译、提高效率 /*/*.d 为当前目录下的二级所有文件检索。 修改为以下编译规则：12345# 找到所有的 .d 文件DEP_FILES := $(shell find $(BUILD_DIR) -type f -name &#x27;*.d&#x27;)# 包含所有生成的依赖文件，避免重复编译、提高效率# 包含所有的 .d 文件-include $(DEP_FILES) 或者：12-include $(wildcard $(BUILD_DIR)/**/*.d)-include $(wildcard $(BUILD_DIR)/*/*/*.d) /**/*.d 它允许你搜索和匹配嵌套在任意深度的目录中的文件。/*/*/*.d 为当前目录下的三级所有文件检索，根据具体情况修改。 $&lt; 和 $^ 的区别在Makefile中，$&lt; 和 $^ 是两个自动变量，它们在规则中用来引用规则的依赖文件，但它们的用途和行为有所不同： $&lt; - 代表规则的第一个依赖文件。 当规则有多个依赖文件时，$&lt; 只引用第一个依赖文件。 它通常用于指定要编译的源文件，特别是在编译单个目标文件时。 $^ - 代表规则的所有依赖文件。 无论规则有多少个依赖文件，$^ 都会将它们全部列出。 它常用于链接阶段，当你需要将多个目标文件链接成最终的可执行文件时。 举个例子来说明它们的不同： 12345# 假设有一个目标文件 main.o 需要两个源文件 main.c 和 utils.c 来生成main.o: main.c utils.c $(CC) $(CFLAGS) -c main.c -o $@# 在这个例子中，$&lt; 就是 main.c，而 $^ 就是 main.c utils.c 再看一个示例： 123$(BUILD_DIR)/%.o: %.c @mkdir -p $(dir $@) $(CC) $(CFLAGS) $(INCLUDE) $&lt; -o $@ 这个规则的意思是，对于$(BUILD_DIR)目录下的每个.o文件，都有一个对应的.c文件。在Makefile中，$&lt; 是一个自动变量，它代表当前规则的第一个依赖文件。然而，$&lt; 并不会直接依赖所有的 .c 文件，而是依赖于当前规则的 第一个依赖文件。 总结一下： 使用 $&lt; 时，只有第一个依赖文件会被考虑。 使用 $^ 时，所有依赖文件都会被考虑。 在实际编写Makefile时，根据你的需要选择合适的变量。 makefile伪指令在 Makefile 中，.PHONY 是一个特殊的声明，用来指出一些目标并不是实际的文件，而是一些需要执行的命令序列。这样做可以让 Make 工具在遇到同名文件时，不会误认为这些目标是要操作的文件，而是要执行的命令。 123456789101112131415161718192021222324.PHONY : clean all copy mix downloadall: $(TARGET).bin $(TARGET).list $(TARGET).hex $(SZ) $(TARGET).elf @make copy @make mix copy: $(TARGET).bin cp $(TARGET).bin app.bin cp ../bootloader/bootloader.bin bootloader.bin# cp $(TARGET).hex app.hexmix: ./tools/papp_up ./tools/mix_10K $(OC) -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex rm bootloader.bin rm app.bin rm mix.binclean: rm -rf $(BUILD_DIR) rm papp.bin rm mix.hex Makefile默认执行的是 第一个目标（不包括以点开头的目标）all，而不是 .PHONY 后的第一个目标。.PHONY 宏的作用是防止Make错误地将伪目标与文件系统中的文件混淆。 make会加载依赖$(TARGET).bin $(TARGET).list $(TARGET).hex $(SZ) $(TARGET).elf。 @符号使得 Make 工具在执行命令时不会打印该命令本身,如make copy。 拓展：$(OC) -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex表示将 mix.bin 的二进制文件转换为名为 mix.hex 的 Intel HEX格式文件，并将所有地址偏移设置为 0x8000000 n32g452rc的makefile解析makefile源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158# C编译器的宏定义C_DEFS += \\-DN32G45X \\-DUSE_STDPERIPH_DRIVER# C编译器的头文件搜索路径INCLUDE += \\-ICMSIS/core \\-ICMSIS/device \\-Istd_periph_lib/inc# APP源文件C_APP_SOURCES += \\application/main.c \\application/n32g45x_it.c# 中间层驱动源文件C_DRV_SOURCES += \\msp/drv_msp.c \\$(wildcard rtt-nano/src/*.c)# C编译器的底层驱动源文件C_LIB_SOURCES += \\CMSIS/device/system_n32g45x.c \\std_periph_lib/src/misc.c \\std_periph_lib/src/n32g45x_rcc.cC_SOURCES += $(C_LIB_SOURCES)C_SOURCES += $(C_APP_SOURCES)C_SOURCES += $(C_DRV_SOURCES)ASM_SOURCES += \\CMSIS/device/startup/startup_n32g45x_gcc.S \\rtt-nano/libcpu/arm/cortex-m4/context_gcc.S# 指定交叉编译工具链的 编译器、连接器、库管理器、CROSS_COMPILE=arm-none-eabi-CC=$(CROSS_COMPILE)gccLD=$(CROSS_COMPILE)ldAR=$(CROSS_COMPILE)arAS=$(CROSS_COMPILE)asOC=$(CROSS_COMPILE)objcopyOD=$(CROSS_COMPILE)objdumpSZ=$(CROSS_COMPILE)size# 指定目标硬件的架构和浮点运算单元 -mfpu=fpv4-sp-d16 -mfloat-abi=hard -mfloat-abi=soft MCU = -mcpu=cortex-m4 -mthumb \\ -ffunction-sections \\ -fdata-sections \\ --specs=nano.specs \\ --specs=nosys.specs \\ -Os -ggdb# 定义编译C源文件的编译选项：禁用共享变量、函数和数据分段、优化级别、调试信息级别、开启所有警告、目标架构、预定义宏# O0:禁用优化，O1：基本优化，O2, O3, Os# g0:禁用调试信息, g1, g2, g3, gCFLAGS += -c -fno-common \\ --specs=rdimon.specs \\ -std=gnu99 -mabi=aapcs \\ -Wall \\ $(MCU) \\ $(C_DEFS)# 定义链接器脚本、链接选项、目标文件格式转换选项、反汇编 -nostdlib -lnosysLDSCRIPT=n32g452_flash.ldLDFLAGS += -Wl,--gc-sections --data-sections -mabi=aapcs $(MCU) -T$(LDSCRIPT) \\ -x assembler-with-cpp -Wa,-mimplicit-it=thumb# printf打印浮点数# LDFLAGS += -lc -lrdimon -u _printf_floatOCFLAGS = -ObinaryODFLAGS = -S#输出目录和目标文件名BUILD_DIR = buildTARGET = $(BUILD_DIR)/app# C源文件、汇编源文件的目标文件路径C_OBJECTS = $(addprefix $(BUILD_DIR)/, $(C_SOURCES:.c=.o))ASM_OBJECTS = $(addprefix $(BUILD_DIR)/, $(ASM_SOURCES:.S=.o))OBJECTS += $(ASM_OBJECTS) $(C_OBJECTS).PHONY : clean allall: $(TARGET).bin $(TARGET).list $(TARGET).hex $(SZ) $(TARGET).elf @make copy @make mix.PHONY: copycopy: $(TARGET).bin cp $(TARGET).bin app.bin cp ../bootloader/bootloader.bin bootloader.bin# cp $(TARGET).hex app.hexmix: ./tools/papp_up ./tools/mix_10K $(OC) -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex rm bootloader.bin rm app.bin rm mix.binclean: rm -rf $(BUILD_DIR) rm papp.bin rm mix.hexSYS := $(shell uname -a)ifeq ($(findstring Microsoft,$(SYS)),Microsoft)COPY_CMD: cp $(TARGET).hex &quot;/mnt/c/Users/Breo/Desktop/iap-tools/linux_download&quot; wsl.exe -d Ubuntu-20.04 cmd.exe /c &quot;C:\\\\\\Users\\\\\\BREO\\\\\\Desktop\\\\\\iap-tools\\\\\\linux_download\\\\\\program452RC.bat&quot;elseCOPY_CMD: echo &quot;当前系统不是 WSL，跳过拷贝文件指令&quot;endifdownload: @make all @$(MAKE) COPY_CMD# 定义生成目标文件的规则$(TARGET).list: $(TARGET).elf $(OD) $(ODFLAGS) $&lt; &gt; $(TARGET).lst$(TARGET).bin: $(TARGET).elf $(OC) $(OCFLAGS) $(TARGET).elf $(TARGET).bin$(TARGET).elf: $(OBJECTS) $(CC) $(ASM_OBJECTS) $(C_OBJECTS) $(LDFLAGS) -Wl,-Map=$(TARGET).map -o $(TARGET).elf$(TARGET).hex: $(TARGET).elf $(OC) -O ihex $&lt; $@# 定义编译C源文件、汇编源文件的规则，将源文件编译成目标文件$(BUILD_DIR)/%.o: %.c mkdir -p $(dir $@) $(CC) $(INCLUDE) $(CFLAGS) -MMD -c $&lt; -o $@$(BUILD_DIR)/%.o: %.S mkdir -p $(dir $@) $(CC) $(INCLUDE) $(CFLAGS) -c $&lt; -o $@#-include $(wildcard $(BUILD_DIR)/**/*.d) # 包含所有生成的依赖文件，避免重复编译、提高效率# 找到所有的 .d 文件DEP_FILES := $(shell find $(BUILD_DIR) -type f -name &#x27;*.d&#x27;)# 包含所有生成的依赖文件，避免重复编译、提高效率# 包含所有的 .d 文件-include $(DEP_FILES) 下面是对这段代码的逐句分析： 宏定义 (C_DEFS): -DN32G45X 和 -DUSE_STDPERIPH_DRIVER 是编译器的宏定义，用于在编译时定义特定的预处理变量。 头文件搜索路径 (INCLUDE): -ICMSIS/core, -ICMSIS/device, -Istd_periph_lib/inc 指定了编译器搜索头文件的路径。 应用层源文件 (C_APP_SOURCES): 列出了应用层的 C 源文件。 中间层驱动源文件 (C_DRV_SOURCES): 使用 $(wildcard rtt-nano&#x2F;src&#x2F;*.c) 来匹配 rtt-nano&#x2F;src 目录下的所有 .c 文件。 底层驱动源文件 (C_LIB_SOURCES): 列出了底层驱动的 C 源文件。 源文件汇总 (C_SOURCES): 将应用层、中间层和底层驱动的源文件汇总到 C_SOURCES。 汇编源文件 (ASM_SOURCES): 列出了汇编语言的源文件。 交叉编译工具链 (CROSS_COMPILE, CC, LD, AR, AS, OC, OD, SZ): 定义了交叉编译工具链的前缀和各个工具（编译器、链接器、库管理器等）的命令。 目标硬件的架构和浮点运算单元 (MCU): -mcpu=cortex-m4: 编译器目标处理器是 Cortex-M4 CPU -mcpu= 后面跟的是具体的目标 CPU 型号 -mthumb: 编译器生成 Thumb 指令集的代码。Thumb 指令集是 ARM 架构的一种16位指令集,用于嵌入式系统以减少内存占用和提高代码密度。 -ffunction-sections: 允许编译器将 每个函数 分别放入程序的 单独段 中。这可以使得链接器在最终的链接阶段丢弃未使用的函数，从而减小最终固件的大小。 -fdata-sections: 类似于 -ffunction-sections，这个选项允许编译器将 不同的数据 放入程序的 不同段 中。这同样有助于链接器优化，移除未使用的数据段。 --specs=nano.specs: 这个选项指定使用新libnano规格，这是针对小型嵌入式系统的 C 标准库的缩减版本。它提供了比标准 C 库 更小的占用空间，适合资源受限的系统。 --specs=nosys.specs: 这个选项指定编译器使用 nosys 作为系统调用的默认返回值。在嵌入式系统中，系统调用可能并不总是可用，这个选项 允许编译器生成不依赖系统调用的代码。 -Os: 这个选项指示编译器优化大小。编译器会尝试在不牺牲太多性能的情况下，生成尽可能小的代码。还有 -O0(无优化), -O1, -O2, -O3, -Og(优化调试,不是优化性能或大小) -ggdb: 这个选项用于生成调试信息。-g 让编译器在对象文件中包含调试信息，使得开发者可以使用调试器（如 GDB）来调试程序。 -mfpu=fpv4-sp-d16(未使用): 符合 FPU 版本 4（FPv4）的浮点单元，它支持单精度（single-precision）和双精度（double-precision）浮点运算。-sp-d16 表示该 FPU 拥有 16 个双精度寄存器，它们被组织为 32 个单精度寄存器。 -mfloat-abi=hard(未使用): 这个选项指定使用“硬”浮点 ABI，意味着浮点运算将使用目标硬件的 FPU 执行，并且浮点函数（如 sin、cos、sqrt 等）将被实现为直接调用硬件支持的浮点指令。这通常可以提高性能，因为 浮点运算更快，但可能会 增加固件的大小，因为需要包含 FPU 的指令集。 -mfloat-abi=soft(未使用): soft 浮点 ABI 指定浮点运算将通过软件库实现，而不是直接使用硬件 FPU。这种方式可以 生成更小的代码，因为不需要包含 FPU 的指令集，但运行时的 浮点运算会较慢，因为它们需要通过软件模拟。 注意：-mfpu=fpv4-sp-d16 与 -mfloat-abi=hard 或 -mfloat-abi=soft 选项一起使用。 编译选项 (CFLAGS):定义了编译 C 源文件时使用的选项,$(MCU) 和 $(C_DEFS)上面有解释，不过多阐述。 -c: 这个选项告诉编译器 仅编译源代码 文件而 不进行链接。编译器会为每个源文件生成一个目标（object）文件，这些目标文件 随后可以被链接 器链接成可执行文件或库。 -fno-common: 在一些系统中，-fcommon 是默认行为，它允许存在多个未初始化的相同大小的全局变量或静态变量，它们在链接时合并为一个。-fno-common 选项禁用了这一行为，要求每个全局变量或静态变量都有其自己的内存位置。这在嵌入式系统或某些特定系统中可能是必需的。 --specs=rdimon.specs: 这个选项指定使用 rdimon.specs 文件作为编译器的规格说明。规格说明文件包含了特定于系统的编译和链接规则，rdimon.specs 可能是指某个特定实时操作系统（RTOS）或嵌入式平台的规格。 -std=gnu99: 这个选项指定编译器遵循 ISO C99 标准，同时包括 GNU 的扩展。gnu99 意味着除了标准的 C99 特性外，编译器还会接受 GNU C 的特定扩展。 -mabi=aapcs: 这个选项指定使用 ARM 架构程序调用标准（AAPCS，ARM Architecture Procedure Call Standard）。AAPCS 定义了函数调用时的参数传递、返回值以及寄存器使用等规则。 -Wall: 这个选项告诉编译器打开大多数警告信息。虽然 -Wall 并不打开所有的警告选项，但它会启用大量标准警告，帮助开发者发现潜在的问题。 链接器脚本和链接选项 (LDSCRIPT, LDFLAGS): LDSCRIPT=n32g452_flash.ld 链接器使用的脚本 -Wl,--gc-sections Wl 是告诉 GCC 后面的选项是传递给链接器的 --gc-sections 告诉链接器在最终的可执行文件中删除未使用的代码段，减小程序大小。 --data-sections: 这个选项类似于 --gc-sections，但它专门用于数据段。它允许链接器移除未使用的数据段，进一步减小程序大小。 -mabi=aapcs: 这个选项指定了应用程序二进制接口（ABI）。aapcs 代表 ARM 架构过程调用标准，它定义了 ARM 架构中函数调用的规则，包括如何传递参数、如何管理堆栈等。 -T$(LDSCRIPT): -T 是链接器选项，用来指定链接脚本文件。链接脚本包含了有关如何链接程序的附加信息，比如内存布局、各种段的位置等。$(LDSCRIPT) 是一个 Makefile 变量，它的值是链接脚本文件的名称，通常是一个文本文件，告诉链接器如何组织内存中的段。 -x assembler-with-cpp: 这个选项告诉链接器将所有输入文件视为预处理过的汇编源文件。这通常用于确保链接器正确处理由 C 预处理器生成的汇编代码。 -Wa,-mimplicit-it=thumb: 这是传递给汇编器的选项（通过 -Wa 前缀）。-mimplicit-it=thumb 指定默认的指令集为 Thumb 模式，这是 ARM 架构的一种 16 位指令集，用于减小代码大小。 目标文件格式转换选项 (OCFLAGS, ODFLAGS):- OCFLAGS = -Obinary- ODFLAGS = -S 输出目录和目标文件名 (BUILD_DIR, TARGET): 定义了构建输出目录和最终目标文件的名称。 目标文件的生成 (C_OBJECTS, ASM_OBJECTS, OBJECTS): C_OBJECTS = $(addprefix $(BUILD_DIR)/, $(C_SOURCES:.c=.o)) $(C_SOURCES:.c=.o)将所有的 C 源文件列表 $(C_SOURCES) 中的每个 .c 扩展名替换为 .o 扩展名，得到目标文件（object files）列表。 $(addprefix $(BUILD_DIR)/, ...) 为每个 .o 文件加前缀加上构建目录 $(BUILD_DIR)/ 的路径。 C_OBJECTS 变量包含了所有 C 源文件对应的、带有完整路径的目标文件列表。 ASM_OBJECTS = $(addprefix $(BUILD_DIR)/, $(ASM_SOURCES:.S=.o)): 这行代码的逻辑与 C_OBJECTS 类似，但是针对汇编源文件 $(ASM_SOURCES)。 它将所有 .S 源文件扩展名替换为 .o，然后添加构建目录的前缀，生成汇编语言目标文件的列表。 OBJECTS += $(ASM_OBJECTS) $(C_OBJECTS): 这行代码使用 += 操作符将 $(ASM_OBJECTS) 和 $(C_OBJECTS) 列表中的所有目标文件添加到 OBJECTS 变量中。 OBJECTS 变量通常用于表示所有需要链接的文件的列表，它可能已经包含了一些其他目标文件，这里通过 += 操作符将汇编和 C 语言的目标文件列表追加进去。 最终，OBJECTS 包含了所有需要被链接器用来生成最终可执行文件或库文件的目标文件。 伪目标 (.PHONY): 定义了 clean, all, copy, mix, download 等伪目标，用于执行特定的命令序列。 条件命令 (SYS, ifeq): SYS := $(shell uname -a): 这行使用 uname -a 命令来获取当前系统的内核信息，并将输出赋值给 SYS 变量。$(shell ...) 命令会在 shell 中执行括号内的内容，并返回其输出。 ifeq ($(findstring Microsoft,$(SYS)),Microsoft): 这是一个条件语句，用于检查 SYS 变量中是否包含字符串 “Microsoft“。$(findstring ...) 函数在 SYS 的值中搜索 “Microsoft“ 字符串。如果找到，返回 “Microsoft“；否则返回空字符串。 ifeq 检查 $(findstring Microsoft,$(SYS)) 的结果是否等于 “Microsoft“。如果是，将执行下面的命令 wsl.exe -d Ubuntu-20.04 cmd.exe /c &quot;C:\\\\\\Users\\\\\\BREO\\\\\\Desktop\\\\\\iap-tools\\\\\\linux_download\\\\\\program452RC.bat&quot;: 使用 wsl.exe 调用 WSL 环境。 -d Ubuntu-20.04中，-d 选项允许你选择一个特定的发行版来启动,这里是Ubuntu-20.04。 cmd.exe:这是 Windows 的命令行解释器，来运行一个 Windows 批处理脚本。 /c: 告诉 cmd.exe 执行指定的命令，然后关闭窗口。 &quot;C:\\\\\\...bat&quot;: 需要执行脚本的路径。 **不知道为什么要用\\\\\\**。 生成目标文件的规则 ($(TARGET).list, $(TARGET).bin, $(TARGET).elf, $(TARGET).hex): $(TARGET).list: $(TARGET).elf:(以下规则类似) $(TARGET).list: $@(目标文件) $(TARGET).elf: $&lt;(输入文件) $(OD) $(ODFLAGS) $&lt; &gt; $(TARGET).lst: 这是上述规则的命令部分。$(OD) 是 objdump 工具的变量，$(ODFLAGS) 是 objdump 的相关参数。$&lt; 是自动变量，表示第一个依赖文件，也就是 $(TARGET).elf。 命令使用 objdump 提取 .elf 文件的汇编内容，并重定向输出到 $(TARGET).lst 文件。 $(OC) $(OCFLAGS) $(TARGET).elf $(TARGET).bin: 这是上述规则的命令部分。$(OC) 是 objcopy 工具的变量，$(OCFLAGS) 是 objcopy 的相关参数。 命令使用 objcopy 从 .elf 文件生成二进制格式的 .bin 文件。 $(CC) $(ASM_OBJECTS) $(C_OBJECTS) $(LDFLAGS) -Wl,-Map=$(TARGET).map -o $(TARGET).elf: 这是 链接命令，使用 $(CC) 编译器（实际上是链接器）来链接对象文件 $(ASM_OBJECTS) 和 $(C_OBJECTS)，以及链接器标志 $(LDFLAGS)。 -Wl,-Map=$(TARGET).map 选项告诉链接器生成一个内存映射文件 $(TARGET).map。 -o $(TARGET).elf 指定了输出的 可执行文件名。 $(OC) -O ihex $&lt; $@: 这是上述规则的命令部分，使用 objcopy 的 -O ihex 选项将输入文件（$&lt;）转换为 Intel HEX 格式，并命名为 $@，即 $(TARGET).hex。 mkdir -p $(dir $@) 这条命令确保目标文件的目录存在。$(dir $@) 获取目标文件的目录路径，mkdir -p 命令 创建这个目录（如果它还不存在）。 $(CC) $(INCLUDE) $(CFLAGS) -MMD -c $&lt; -o $@ 这是编译单个 C 源文件的命令。它使用 $(CC) 编译器，$(INCLUDE) 包含路径，$(CFLAGS) 编译选项，-c 选项来编译不链接，-MMD 生成依赖文件，$&lt; 是源文件，$@ 是目标文件。 $(BUILD_DIR)/%.o: %.S: 这是一个模式规则，用于从 .S 汇编源文件生成 .o 目标文件，其命令与上面编译 C 文件的命令类似，但是通常 不包含编译选项，因为汇编语言的处理方式与 C 语言不同。 -include $(wildcard $(BUILD_DIR)/**/*.d): $(wildcard *.c) 会列出当前目录下所有的 .c 文件。 $(wildcard $(BUILD_DIR)/**/*.d) 会列出 $(BUILD_DIR) 目录下的所有 .d 文件。 DEP_FILES := $(shell find $(BUILD_DIR) -type f -name &#39;*.d&#39;),-include $(DEP_FILES): find 这是一个 find 命令，用于在文件系统中搜索文件。 $(BUILD_DIR) 是之前定义的 Makefile 变量，表示构建目录的路径。 -type f 指定 find 命令只搜索文件（不包括目录）。 -name &#39;*.d&#39; 定义了搜索的文件名模式，*.d 匹配所有以 .d 结尾的文件，这通常是由编译器生成的依赖文件。 -include $(DEP_FILES)： make 将会包含这些 .d ,这些文件包含了头文件的依赖信息,从而确保 make 能够正确地检测到源文件的依赖关系，并且在源文件或其头文件发生变化时重新编译相应的目标文件。 编译C源文件和汇编源文件的规则 ($(BUILD_DIR)/%.o: %.c, $(BUILD_DIR)/%.o: %.S): 定义了如何编译 C 和汇编源文件为 .o 目标文件。 包含生成的依赖文件 (-include $(wildcard $(BUILD_DIR)/**/*.d), DEP_FILES): 使用 find 命令找到所有的 .d 文件，然后使用 -include 指令包含这些文件，以确保 Make 能够跟踪源文件的变化并避免不必要的重新编译。 标准makefile基本语法[参考文档]：https://seisman.github.io/how-to-write-makefile/index.html 书写规则规则的语法123targets : prerequisites command ... 或是这样： 123targets : prerequisites ; command command ... 如果命令太长，你可以使用反斜杠（ \\ ）作为换行符 在规则中使用通配符make支持三个通配符： * ， ? 和 ~ 。这是和Unix的B-Shell是相同的。 *：通配符代替了你一系列的文件，如 *.c 表示所有后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如： * ，那么可以用转义字符 \\ ，如 \\* 来表示真实的 * 字符，而不是任意长度的字符串。12clean: rm -f *.o clean是操作系统Shell所支持的通配符。1objects = *.o objects的值就是 *.o, 并不是说 *.o 会展开， 如需展开进行以下操作。1objects := $(wildcard *.o) 示例1：1var = $(shell echo &quot;Hello, World!&quot;) := 和 =区别： = (递归展开):示例1每次引用 $(var) 时，Make 都会执行 echo &quot;Hello, World!&quot; := (直接展开):示例1每次引用 $(var) 的值在 Makefile 解析时设置为 &quot;Hello, World!&quot; 示例2可写出编译并链接所有 .c 和 .o 文件： 123objects := $(patsubst %.c,%.o,$(wildcard *.c))foo : $(objects) cc -o foo $(objects) patsubst 函数用于将第一个参数中匹配第二个参数模式的部分替换为第三个参数中的相应模式 patsubst 函数用于将 *.c 替换为 *.o，wildcard 函数用于获取当前目录下所有 .c 文件。 文件搜索1VPATH = src:../headers Makefile文件中的特殊变量 VPATH,当make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。 “src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）。 12vpath &lt;pattern&gt; &lt;directories&gt;vpath %.h ../headers vpath使用方法中的&lt;pattern&gt;需要包含 % 字符。 % 的意思是匹配零或若干字符，（需引用 % ，使用 \\ ）例如， %.h 表示所有以 .h 结尾的文件。&lt;pattern&gt;指定了要搜索的文件集，而&lt;directories&gt;则指定了&lt;pattern&gt;的文件集的搜索的目录。 伪目标123.PHONY : cleanclean : rm *.o temp 伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。 1234567891011all : prog1 prog2 prog3.PHONY : allprog1 : prog1.o utils.o cc -o prog1 prog1.o utils.oprog2 : prog2.o cc -o prog2 prog2.oprog3 : prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于默认目标的特性是，总是被执行的，但由于“all”又是一个伪目标，伪目标只是一个标签不会生成文件，所以不会有“all”文件产生。于是，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。 .PHONY : all 声明了“all”这个目标为“伪目标”。（注：这里的显式“.PHONY : all” 不写的话一般情况也可以正确的执行，这样make可通过隐式规则推导出， “all” 是一个伪目标，执行make不会生成“all”文件，而执行后面的多个目标。建议：显式写出是一个好习惯。） 多目标Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。 12bigoutput littleoutput : text.g generate text.g -$(subst output,,$@) &gt; $@ 上述规则等价于： 1234bigoutput : text.g generate text.g -big &gt; bigoutputlittleoutput : text.g generate text.g -little &gt; littleoutput 其中，-$(subst output,,$@)中的 $ 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思， $@ 表示目标的集合，就像一个数组， $@ 依次取出目标，并执于命令。 $(subst from,to,text) from 是您想要替换的字符串。 to 是您想要替换成的新字符串。 text 是原始文本。 generate text.g -$(subst output,,$@) &gt; $@中的”&gt;“ 是一个shell命令，用于将 generate text.g -$(subst output,,$@) 的输出重定向到右侧$@文件中。 静态模式静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法： 123&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt; &lt;commands&gt; ... 我们的“目标模式”或是“依赖模式”中都应该有 % 这个字符，如果你的文件名中有 % 那么你可以使用反斜杠 \\ 进行转义，来标明真实的 % 字符。看一个例子： 123456objects = foo.o bar.oall: $(objects)$(objects): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 我们的目标从$object中获取 %.o 表明要所有以 .o 结尾的目标，也就是 foo.o bar.o,也就是变量 $object 集合的模式 依赖模式 %.c 则取模式 %.o 的 % ，也就是 foo bar ，并为其加下 .c 的后缀，于是，我们的依赖目标就是 foo.c bar.c 命令中的 $&lt; 和 $@ 则是自动化变量， $&lt; 表示 第一个依赖文件， $@ 表示 目标集（也就是“foo.o bar.o”） 上面的规则展开后等价于下面的规则： 1234foo.o : foo.c $(CC) -c $(CFLAGS) foo.c -o foo.obar.o : bar.c $(CC) -c $(CFLAGS) bar.c -o bar.o 如果我们的 %.o 有几百个，使用“静态模式规则”很方便，再看一个例子： 123456files = foo.elc bar.o lose.o$(filter %.o,$(files)): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@$(filter %.elc,$(files)): %.elc: %.el emacs -f batch-byte-compile $&lt; $(filter %.o,$(files))表示调用Makefile的filter函数，过滤“$files”集，只要其中模式为“%.o”的内容。 自动生成依赖性在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句 #include &quot;defs.h&quot; ，那么我们的依赖关系应该是： main.o : main.c defs.h 但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件,例如，如果我们执行下面的命令: cc -M main.c 其输出是： main.o : main.c defs.h 需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用 -MM 参数，不然，-M 参数会把一些 标准库的头文件也包含进来。 gcc -M main.c的输出是:123456789main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \\ /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \\ /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \\ /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \\ /usr/include/bits/sched.h /usr/include/libio.h \\ /usr/include/_G_config.h /usr/include/wchar.h \\ /usr/include/bits/wchar.h /usr/include/gconv.h \\ /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \\ /usr/include/bits/stdio_lim.h gcc -MM main.c的输出则是:1main.o: main.c defs.h GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 name.c 的文件都生成一个 name.d 的Makefile文件， .d 文件中就存放对应 .c 文件的依赖关系。 我们可以写出 .c 文件和 .d 文件的依赖关系，并让make自动更新或生成 .d 文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。 12345%.d: %.c @set -e; rm -f $@; \\ $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \\ sed &#x27;s,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g&#x27; &lt; $@.$$$$ &gt; $@; \\ rm -f $@.$$$$ 规则的意思是，所有的 .d 文件依赖于 .c 文件 rm -f $@ 的意思是删除所有的目标，也就是 .d 文件 第二行的意思是，为每个依赖文件 $&lt; ，也就是 .c 文件生成依赖文件， $@ 表示模式 %.d 文件，如果有一个C文件是name.c，那么 % 就是 name ， $$$$ 意为一个随机编号，第二行生成的文件有可能是“name.d.12345” 第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档 第四行就是删除临时文件 总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入 .d 文件的依赖，即把依赖关系： main.o : main.c defs.h 转成： main.o main.d : main.c defs.h 于是，我们的 .d 文件也会自动更新了，并会自动生成了, 你还可以在这个 .d 文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 .d 文件都包含一个完整的规则, 例如： 123sources = foo.c bar.cinclude $(sources:.c=.d) $(sources:.c=.d) 中的 .c=.d 的意思是做一个替换，把变量 $(sources) 所有 .c 的字串都替换成 .d 因为include是按次序来载入文件，最先载入的 .d 文件中的目标会成为默认目标。 书写命令显示命令1@echo 正在编译XXX模块...... 当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出: 12echo 正在编译XXX模块...... //输出命令正在编译XXX模块...... 如果make执行时，带入make参数 -n 或 --just-print ，那么其只是显示命令，但不会执行命令。 make参数 -s 或 --silent 或 --quiet 则是全面禁止命令的显示。 命令执行当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。 示例一：123exec: cd /home/hchen pwd 12exec: cd /home/hchen; pwd 当我们执行 make exec 时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。 命令出错忽略命令的出错，我们可以在Makefile的命令行前加一个减号 - （在Tab键之后），标记为不管命令出不出错都认为是成功的。如： 12clean: -rm -f *.o 还有一个全局的办法是，给make加上 -i 或是 --ignore-errors 参数，那么，Makefile中所有命令都会忽略错误。如果一个规则是以 .IGNORE 作为目标的，那么这个规则中的所有命令将会忽略错误。 还有一个要提一下的make的参数的是 -k 或是 --keep-going ，这个参数的意思是，如果某规则中的命令出错了，那么就 终止该规则 的执行，但 继续执行其它规则。 嵌套执行make在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile 例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写： 12subsystem: cd subdir &amp;&amp; $(MAKE) 其等价于： 12subsystem: $(MAKE) -C subdir Makefile的-C选项，可以指定编译目录，-f选项可以指定编译文件。 定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。 我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了 -e 参数。 如果你要传递变量到下级Makefile中，那么你可以使用这样的声明: export &lt;variable ...&gt;; 如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明: unexport &lt;variable ...&gt;; 如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。示例一： export variable &#x3D; value &#x2F;&#x2F; 其等价于： variable &#x3D; value export variable &#x2F;&#x2F; 其等价于： export variable :&#x3D; value &#x2F;&#x2F; 其等价于： variable :&#x3D; value export variable 示例二： export variable += value // 其等价于： variable += value export variable 需要注意的是，有两个变量，一个是 SHELL ，一个是 MAKEFLAGS ，这两个变量不管你是否export，其总是要 传递到下层 Makefile中，特别是 MAKEFLAGS 变量，其中包含了make的 参数信息，如果我们执行“总控Makefile”时有make参数或是在上层 Makefile中定义了这个变量，那么 MAKEFLAGS 变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。 但是make命令中的有几个参数并不往下传递，它们是 -C , -f , -h, -o 和 -W （有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：12subsystem:cd subdir &amp;&amp; $(MAKE) MAKEFLAGS= 如果你定义了环境变量 MAKEFLAGS ，那么你得确信其中的选项是大家都会用到的，如果其中有 -t , -n 和 -q 参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。 还有一个在“嵌套执行”中比较有用的参数， -w 或是 --print-directory 会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用 make -w 来执行，那么当进入该目录时，我们会看到:1make: Entering directory `/home/hchen/gnu/make&#x27;. 而在完成下层make后离开目录时，我们会看到:1make: Leaving directory `/home/hchen/gnu/make&#x27; 当你使用 -C 参数来指定make下层Makefile时， -w 会被自动打开的。如果参数中有 -s （ --slient ）或是 --no-print-directory ，那么， -w 总是失效的。 定义命令包如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 define 开始，以 endef 结束，如: 1234define run-yaccyacc $(firstword $^)mv y.tab.c $@endef 这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在 define 和 endef 中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。 12foo.c : foo.y $(run-yacc) 我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的 $^ 就是 foo.y ， $@ 就是 foo.c （有关这种以 $ 开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。 使用函数函数的调用语法函数调用，很像变量的使用，也是以 $ 来标识的，其语法如下： $(&lt;function&gt; &lt;arguments&gt;) // 或者 $&#123;&lt;function&gt; &lt;arguments&gt;&#125; 字符串处理函数subst1$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;) 名称：字符串替换函数 功能：把字串 &lt;text&gt; 中的 &lt;from&gt; 字符串替换成 &lt;to&gt; 。 返回：函数返回被替换过后的字符串。 patsubst1$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;) 名称：模式 字符串替换函数。 功能：查找 &lt;text&gt; 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式 &lt;pattern&gt; ，如果匹配的话，则以 &lt;replacement&gt; 替换。这里， &lt;pattern&gt; 可以包括通配符 % ，表示任意长度的字串。如果 &lt;replacement&gt; 中也包含 % ，那么， &lt;replacement&gt; 中的这个 % 将是 &lt;pattern&gt; 中的那个 % 所代表的字串。（可以用 \\ 来转义，以 \\% 来表示真实含义的 % 字符） 返回：函数返回被替换过后的字符串。 示例：1$(patsubst %.c,%.o,x.c.c bar.c) 把字串 x.c.c bar.c 符合模式 %.c 的单词替换成 %.o ，返回结果是 x.c.o bar.o strip$(strip &lt;string&gt;) 名称：去空格函数。 功能：去掉 &lt;string&gt; 字串中开头和结尾的空字符。 返回：返回被去掉空格的字符串值。 示例：1$(strip a b c ) 把字串a b c 去掉开头和结尾的空格，结果是 a b c。 findstring$(findstring &lt;find&gt;,&lt;in&gt;) 名称：查找字符串函数 功能：在字串 中查找 字串。 返回：如果找到，那么返回 ，否则返回空字符串。 示例：12$(findstring a,a b c)$(findstring a,b c) 第一个函数返回 a 字符串，第二个返回空字符串 混合总结override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH))) 如果我们的 $(VPATH) 值是 src:../headers ，那么 $(patsubst %,-I%,$(subst :, ,$(VPATH))) 将返回 -Isrc -I../headers ，这正是cc或gcc搜索头文件路径的参数。 注：函数太多，不做概述。详见：https://seisman.github.io/how-to-write-makefile/functions.html例程：https://github.com/XUAN9527/linux_test/tree/main/make_demo Makefile搭配Kconfig使用话不多说，我们一般使用menuconfig+Kconfig的方式进行版本配置，这里简单的笔记一个Python解析器版本的实现Kconfiglib。[参考链接1]：https://cstriker1407.info/blog/kconfiglib-simple-note/[参考链接2]：https://juejin.cn/post/7101836149915648030 环境搭建 安装必须组件：Python3 + kconfiglib 1234sudo apt updatesudo apt install python3sudo apt install python3-pippip3 install kconfiglib 验证安装:1234567$ python3 --versionPython 3.10.14$ pip3 show kconfiglibName: kconfiglibVersion: 14.1.0... 实现示例 在跟目录下创建Kconfig文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859mainmenu &quot;N32l40x 128K MCU, Flash Configuration&quot;config SPI_FLASH_ENABLE bool &quot;spi flash enable&quot; default n help config spi flash enable/disablemenu &quot;Internal Flash Configuration&quot;depends on !SPI_FLASH_ENABLEconfig INTER_BOOTLOAD_FIRMWARE_SIZE int &quot;bootloader fireware size (K)&quot; range 10 32 default 10 help config bootloader fireware sizeconfig INTER_FACTORY_FIRMWARE_SIZE int &quot;factory fireware size (K)&quot; range 56 96 default 56 help config factory fireware size 56K/96Kconfig INTER_APPLICATION_FIRMWARE_SIZE int &quot;application fireware size (K)&quot; range 56 96 default 56 help config application fireware size 56K/96Kconfig INTER_DOWNLOAD_AREA_SIZE int &quot;download fireware size (K)&quot; range 56 96 default 56 help config download area size 56K/96Kconfig INTER_UPGRADE_DATA_SIZE int &quot;upgrade data size (K)&quot; range 2 4 default 2 help config upgrade data size 2K/4Kconfig INTER_DCD_DATA_SIZE int &quot;dcd data size (K)&quot; range 2 4 default 2 help config dcd data size 2K/4Kconfig INTER_USER_DATA_SIZE int &quot;user data size (K)&quot; range 2 408 default 2 help config user data size 2K/408K; 2k - inter flash; 408K - outerflashendmenu... shell执行menuconfig指令： 选择好需要的参数后，保存退出，生成.config配置文件。 shell执行genconfig指令，将.config文件生成config.h文件，可供程序调用。 如需搭配makefile使用，则需要将config.h文件添加到Makefile中,添加以下依赖规则。123456789101112all: genconfig ... ......menuconfig: menuconfig @echo &quot;menuconfig running!&quot;genconfig: genconfig @echo &quot;genconfig .config &gt; config.h complete!&quot; 执行make menuconfig进行配置，make编译生成即可。 makefile隐藏打印输出 以下是makefile使用make编译的shell输出信息： 12345678910111213141516171819202122xuan@DESKTOP-A52B6V9:~/work/wireless-charging/app$ makemkdir -p build/application/arm-none-eabi-gcc -ICMSIS/core -ICMSIS/device -Istd_periph_lib/inc -Iuser -Imsp -Idriver -Iapplication/inc -Icomponents/letter_shell -Icomponents/iap -Icomponents/ntc -Icomponents/soft_timer -Icomponents/comp_misc_lib -Icomponents/flexibleButton -Icomponents/aw9523b -c -fno-common --specs=rdimon.specs -std=gnu99 -mabi=aapcs -Wall -mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard -ffunction-sections -fdata-sections -lm --specs=nosys.specs --specs=nano.specs -Os -ggdb -DN32L40X -DUSE_STDPERIPH_DRIVER -D__FPU_PRESENT=1 -MMD -c application/main.c -o build/application/main.oarm-none-eabi-gcc build/CMSIS/device/startup/startup_n32l40x_gcc.o build/CMSIS/device/system_n32l40x.o build/std_periph_lib/src/n32l40x_rcc.o build/std_periph_lib/src/n32l40x_tim.o build/std_periph_lib/src/n32l40x_adc.o build/std_periph_lib/src/n32l40x_dma.o build/std_periph_lib/src/n32l40x_usart.o build/std_periph_lib/src/n32l40x_iwdg.o build/std_periph_lib/src/n32l40x_flash.o build/std_periph_lib/src/n32l40x_gpio.o build/std_periph_lib/src/n32l40x_spi.o build/std_periph_lib/src/misc.o build/application/main.o build/application/n32l40x_it.o build/application/system_work.o build/user/module_battery.o build/user/module_botton.o build/user/module_led.o build/user/module_power.o build/user/module_storage.o build/user/shell_debug.o build/user/user_board.o build/msp/board.o build/msp/drv_msp.o build/driver/drv_adc.o build/driver/drv_flash.o build/driver/drv_gpio.o build/driver/drv_iwdg.o build/driver/drv_pwm_gpio.o build/driver/drv_pwm_input.o build/driver/drv_usart.o build/driver/drv_spi_led.o build/driver/drv_i2c.o build/driver/drv_i2c_bit_ops.o build/components/comp_misc_lib/comp_misc_lib.o build/components/flexibleButton/flexible_button.o build/components/iap/af_utils.o build/components/iap/dcd_port.o build/components/iap/dcd_user.o build/components/iap/iap.o build/components/iap/ymodem.o build/components/letter_shell/log.o build/components/letter_shell/shell.o build/components/letter_shell/shell_cmd_list.o build/components/letter_shell/shell_companion.o build/components/letter_shell/shell_ext.o build/components/letter_shell/shell_port.o build/components/ntc/ntc.o build/components/soft_timer/soft_timer.o build/components/aw9523b/aw9523b.o -Wl,--gc-sections --data-sections -mabi=aapcs -mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard -ffunction-sections -fdata-sections -lm --specs=nosys.specs --specs=nano.specs -Os -ggdb -Tn32l40x_flash.ld -x assembler-with-cpp -Wa,-mimplicit-it=thumb -Wl,-Map=build/app.map -o build/app.elfarm-none-eabi-objcopy -Obinary build/app.elf build/app.binarm-none-eabi-objdump -S build/app.elf &gt; build/app.lstarm-none-eabi-objcopy -O ihex build/app.elf build/app.hexarm-none-eabi-size build/app.elf text data bss dec hex filename 29280 292 11888 41460 a1f4 build/app.elfmake[1]: Entering directory &#x27;/home/xuan/work/wireless-charging/app&#x27;cp build/app.bin app.bincp ../bootloader/bootloader.bin bootloader.binmake[1]: Leaving directory &#x27;/home/xuan/work/wireless-charging/app&#x27;make[1]: Entering directory &#x27;/home/xuan/work/wireless-charging/app&#x27;./tools/papp_up./tools/mix_10Karm-none-eabi-objcopy -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hexrm bootloader.binrm app.binrm mix.binmake[1]: Leaving directory &#x27;/home/xuan/work/wireless-charging/app&#x27; 以下是makefile的代码： 12345678910111213141516171819202122232425262728293031323334353637383940.PHONY : clean allall: $(TARGET).bin $(TARGET).list $(TARGET).hex $(SZ) $(TARGET).elf @make copy @make mix.PHONY: copy downloadcopy: $(TARGET).bin cp $(TARGET).bin app.bin cp ../bootloader/bootloader.bin bootloader.binmix: ./tools/papp_up ./tools/mix_10K $(OC) -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex rm bootloader.bin rm app.bin rm mix.binclean: rm -rf $(OUTPUT_DIR) rm papp.bin rm mix.hexSYS := $(shell uname -a)ifeq ($(findstring Microsoft,$(SYS)),Microsoft)COPY_CMD: cp $(OUTPUT_DIR)/app.hex &quot;/mnt/c/Users/Breo/Desktop/iap-tools/linux_download/&quot; wsl.exe -d Ubuntu-20.04 cmd.exe /c &quot;C:\\\\\\Users\\\\\\BREO\\\\\\Desktop\\\\\\iap-tools\\\\\\linux_download\\\\\\program.bat&quot;elseCOPY_CMD: echo &quot;当前系统不是 WSL，跳过拷贝文件指令&quot;endifdownload: @make all @$(MAKE) COPY_CMD 使用@和--no-print来隐藏打印信息，改进后： 123456789101112131415161718192021222324252627282930313233343536373839404142.PHONY : clean allall: $(TARGET).bin $(TARGET).list $(TARGET).hex $(SZ) $(TARGET).elf @make --no-print copy @make --no-print mix .PHONY: copycopy: $(TARGET).bin @cp $(TARGET).bin app.bin @cp ../bootloader/bootloader.bin bootloader.binmix: @./tools/papp_up @./tools/mix_10K @$(OC) -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex @rm bootloader.bin @rm app.bin @rm mix.binclean: -rm -rf $(OUTPUT_DIR) -rm papp.bin -rm mix.hexSYS := $(shell uname -a)ifeq ($(findstring Microsoft,$(SYS)),Microsoft)COPY_CMD: cp $(TARGET).hex &quot;/mnt/c/Users/Breo/Desktop/iap-tools/linux_download/&quot; wsl.exe -d Ubuntu-20.04 cmd.exe /c &quot;C:\\\\\\Users\\\\\\BREO\\\\\\Desktop\\\\\\iap-tools\\\\\\linux_download\\\\\\program.bat&quot;elseCOPY_CMD: echo &quot;当前系统不是 WSL，跳过拷贝文件指令&quot;endifdownload: @make all @$(MAKE) COPY_CMD","tags":"linux makefile"},{"title":"Linux小贴士","url":"/2024/05/06/Linux小贴士/","text":"tree指令小贴士1. 基本用法：显示当前目录下的文件和目录结构。 tree 2. 限制目录深度：使用 -L 选项后跟数字来限制目录显示的深度。 tree -L 2 这将显示当前目录及其下最多两级子目录。 3. 显示隐藏文件：默认情况下，隐藏文件（以点 . 开头的文件或目录）不会被显示。要显示这些隐藏文件，可以使用 -a 选项。 tree -a 4. 递归显示所有文件：使用 -R 选项递归显示所有文件。 tree -R 5. 指定目录：显示指定目录的树状结构。 tree /path/to/directory 6. 使用文件系统类型：显示目录结构时，包括文件系统类型。 tree -F -F 选项会在每个目录名后添加一个斜杠 /。 7. 排序：默认情况下，tree 会按字母顺序排序。使用 -f 选项可以按照文件修改时间排序。 tree -f 8. 显示文件大小：使用 -h 选项以更易读的格式显示文件大小。 tree -h 9. 显示目录和文件的权限：使用 -u 选项显示文件所有者，-g 选项显示文件组。 tree -ug 10. 使用颜色：tree 命令使用颜色来区分不同类型的文件和目录。使用 –no-colour 可以关闭颜色显示。 tree --no-colour 11. 输出到文件：将树状结构输出到一个文件中。 tree &gt; tree.txt 12. 执行命令：对每个文件或目录执行命令，例如，获取每个文件的详细信息。 tree -exec ls -l &#123;&#125; \\; 13. 帮助和手册：查看 tree 命令的帮助信息。 tree --help man tree 14. 安装 tree 命令（如果尚未安装）通常可以通过你的Linux发行版的包管理器来完成。例如，在Ubuntu上，你可以使用以下命令安装： sudo apt-get update sudo apt-get install tree 使用 tree 可以帮助你更直观地查看目录结构，特别是在处理复杂的文件系统时。 git小贴士","tags":"linux wsl"},{"title":"Qt5学习笔记","url":"/2024/04/30/Qt5学习笔记/","text":"环境搭建 Qt官方下载地址: https://download.qt.io/archive/qt/ 参考教程文档: https://subingwen.cn/qt/qt-primer/ 问题汇总打印问题问题现象： 在Qt Creater中，使用qDebug()打印信息时，在调试界面中，qDebug()的输出信息会显示在调试终端，当直接运行.exe文件时，qDebug()的输出信息会丢失。 1234567MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); qDebug() &lt;&lt; &quot;这是测试打印程序&quot; &lt;&lt; &quot; * &quot; &lt;&lt; 10000;&#125; 解决方法： 在qt.pro工程文件中中，添加如下代码：1CONFIG += c++17 console //添加console 勾选以下选项： 总结： 需要重新编译代码，.exe文件更新后生效。 再次编译运行时,会弹出terminal。","tags":"qt"},{"title":"CmBacktrace移植","url":"/2024/04/19/CmBacktrace移植/","text":"CmBacktrace简介 支持断言（assert）和故障（Hard Fault） 故障原因自动诊断 输出错误现场的 函数调用栈 适配 Cortex-M0&#x2F;M3&#x2F;M4&#x2F;M7 MCU； 支持 IAR、KEIL、GCC 编译器； 移植步骤1. 下载源码 官方源码地址 : https://github.com/armink/CmBacktrace示例项目地址 : https://github.com/XUAN9527/cmbacktrace-demo 2. copy源码文件 添加头文件cm_backtrace.h cmb_cfg.h cmb_def.h 添加源文件cm_backtrace.c 添加demos文件 demos/non_os/stm32f10x/app/src/fault_test.c 2.1 添加修改makefile： 方法一、修改添加fault_handler/gcc/cmb_fault.S为fault_handler/gcc/cmb_fault.s 123ASM_SOURCES = \\CMSIS/device/startup/startup_n32l40x_gcc.s \\components/cm_backtrace/fault_handler/gcc/cmb_fault.s # 添加这一行,或者 方法二、将cmb_fault.S将入makefile编译选项 123456789101112ASM_SOURCES = CMSIS/device/startup/startup_n32l40x_gcc.sASM_SOURCES2 = components/cm_backtrace/fault_handler/gcc/cmb_fault.S # 此行为新增# C源文件、汇编源文件的目标文件路径C_OBJECTS = $(addprefix $(OUTPUT_DIR)/, $(C_SOURCES:.c=.o))ASM_OBJECTS = $(addprefix $(OUTPUT_DIR)/, $(ASM_SOURCES:.s=.o)) \\ $(addprefix $(OUTPUT_DIR)/, $(ASM_SOURCES2:.S=.o)) # 此行为新增$(OUTPUT_DIR)/%.o: %.s %.S # 新增 %.S mkdir -p $(dir $@) $(CC) $(INCLUDE) $(CFLAGS) -c $&lt; -o $@ 2.2 添加printf重定向： 1234int _write(int fd, char* pBuffer, int size)&#123; return drv_serial_dma_write(ESERIAL_1, pBuffer, size);&#125; 2.3 修改文件： cmb_cfg.h文件 1234567891011121314151617181920#ifndef _CMB_CFG_H_#define _CMB_CFG_H_#include &quot;log.h&quot;/* print line, must config by user */#define cmb_println(...) printf(__VA_ARGS__);printf(&quot;\\r\\n&quot;) /* e.g., printf(__VA_ARGS__);printf(&quot;\\r\\n&quot;) or SEGGER_RTT_printf(0, __VA_ARGS__);SEGGER_RTT_WriteString(0, &quot;\\r\\n&quot;) *//* enable bare metal(no OS) platform */#define CMB_USING_BARE_METAL_PLATFORM/* enable OS platform *//* #define CMB_USING_OS_PLATFORM *//* OS platform type, must config when CMB_USING_OS_PLATFORM is enable *//* #define CMB_OS_PLATFORM_TYPE CMB_OS_PLATFORM_RTT or CMB_OS_PLATFORM_UCOSII or CMB_OS_PLATFORM_UCOSIII or CMB_OS_PLATFORM_FREERTOS or CMB_OS_PLATFORM_RTX5 *//* cpu platform type, must config by user */#define CMB_CPU_PLATFORM_TYPE CMB_CPU_ARM_CORTEX_M4 /* CMB_CPU_ARM_CORTEX_M0 or CMB_CPU_ARM_CORTEX_M3 or CMB_CPU_ARM_CORTEX_M4 or CMB_CPU_ARM_CORTEX_M7 *//* enable dump stack information */#define CMB_USING_DUMP_STACK_INFO/* language of print information */#define CMB_PRINT_LANGUAGE CMB_PRINT_LANGUAGE_ENGLISH /* CMB_PRINT_LANGUAGE_ENGLISH(default) or CMB_PRINT_LANGUAGE_CHINESE */#endif /* _CMB_CFG_H_ */ 修改n32l40x_flash.ld链接文件 text段开始之前添加 _stext = .; 下面为例程： 12345678910111213141516171819202122232425/* Define output sections */SECTIONS&#123; /* The startup code goes first into FLASH */ .isr_vector : &#123; . = ALIGN(4); KEEP(*(.isr_vector)) /* Startup code */ . = ALIGN(4); &#125; &gt;FLASH _stext = .; # text段开始之前添加 /* The program code and other data goes into FLASH */ .text : &#123; . = ALIGN(4); *(.text) /* .text sections (code) */ *(.text*) /* .text* sections (code) */ *(.glue_7) /* glue arm to thumb code */ *(.glue_7t) /* glue thumb to arm code */ *(.eh_frame) KEEP (*(.init)) KEEP (*(.fini)) bss段开始之前添加 _sstack = .; 下面为例程： 123456789101112131415161718192021222324252627.bss :&#123; /* This is used by the startup in order to initialize the .bss secion */ _sbss = .; /* define a global symbol at bss start */ __bss_start__ = _sbss; *(.bss) *(.bss*) *(COMMON) . = ALIGN(4); _ebss = .; /* define a global symbol at bss end */ __bss_end__ = _ebss;&#125; &gt;RAM_sstack = .; # stack段开始之前添加/* User_heap_stack section, used to check that there is enough RAM left */._user_heap_stack :&#123; . = ALIGN(4); PROVIDE ( end = . ); PROVIDE ( _end = . ); . = . + _Min_Heap_Size; . = . + _Min_Stack_Size; _estack = .; /* end of RAM */ . = ALIGN(4);&#125; &gt;RAM 2.4 main函数例程： 12345678910111213141516171819#include &quot;cm_backtrace.h&quot;#define HARDWARE_VERSION &quot;V1.0.0&quot;#define SOFTWARE_VERSION &quot;V0.1.0&quot;extern void fault_test_by_unalign(void);extern void fault_test_by_div0(void);int main(void)&#123; main_system_init(); cm_backtrace_init(&quot;CmBacktrace&quot;, HARDWARE_VERSION, SOFTWARE_VERSION); // 在开启时钟，打印和看门狗之后就需要初始化 fault_test_by_unalign(); fault_test_by_div0(); while(1) &#123; &#125;&#125; 编译出错后代码： 12345678910111213141516171819202122232425262728293031323334Firmware name: CmBacktrace, hardware version: V1.0.0, software version: V0.1.0Fault on interrupt or bare metal(no OS) environment===== Thread stack information ===== addr: 20004ec8 data: 5a6d79ca addr: 20004ecc data: f758b4b7 addr: 20004ed0 data: 94cfc3fd addr: 20004ed4 data: a8ccaa51 addr: 20004ed8 data: 61049ca6 addr: 20004edc data: e4e1b169 addr: 20004ee0 data: b48e100d addr: 20004ee4 data: c44eb7ea addr: 20004ee8 data: 23d4e51e addr: 20004eec data: 8527b7c0 addr: 20004ef0 data: fd9d41f7 addr: 20004ef4 data: f539e421 addr: 20004ef8 data: 4ad52963 addr: 20004efc data: 4587b423 addr: 20004f00 data: e000ed00 addr: 20004f04 data: 00000000 addr: 20004f08 data: 00000000 addr: 20004f0c data: 00000000 addr: 20004f10 data: 200022cc addr: 20004f14 data: 00000000 addr: 20004f18 data: 00000000 addr: 20004f1c data: 00000000 addr: 20004f20 data: 00000000 addr: 20004f24 data: 08009093======================================================= Registers information ==================== R0 : 20002ee9 R1 : 20002e4c R2 : e000ed14 R3 : 2000253c R12: 0000000a LR : 0800a3b3 PC : 080154c2 PSR: 61000000==============================================================Usage fault is caused by attempts to execute an undefined instructionShow more call stack info by run: addr2line -e CmBacktrace.elf -a -f 080154c2 0800a3b3 08009092 转换为定位代码工具： linux环境下输入： 1addr2line -e app.elf -a -f 080154c2 0800a3b2 08009092 解释：app.elf 为你的工程编译文件。 数据分析结果： 12345678910xuan@DESKTOP-A52B6V9:~/work/n5-mini-s-plus/code/app/build$ addr2line -e app.elf -a -f 080154c2 0800a3b2 080090920x080154c2fault_test_by_unalign/home/xuan/work/n5-mini-s-plus/code/app/components/cm_backtrace/fault_test.c:180x0800a3b2main/home/xuan/work/n5-mini-s-plus/code/app/application/main.c:300x08009092LoopFillZerobss/home/xuan/work/n5-mini-s-plus/code/app/CMSIS/device/startup/startup_n32l40x_gcc.s:113","tags":"linux cortex-m"},{"title":"Linux下开发单片机","url":"/2024/03/28/Linux下开发单片机/","text":"Ubuntu Wsl环境搭建Windows10系统安装子系统Wsl1. 通过 Microsoft Store 安装 打开 Microsoft Store。 搜索 “适用于 Linux 的 Windows 子系统”。 选择 “Ubuntu” 或您喜欢的其他 Linux 发行版。 点击 “获取”。 安装完成后，点击 “启动”。 2. 通过命令行 打开 PowerShell 或 命令提示符 以管理员身份运行。 输入以下命令: 1wsl --install 重启您的计算机。 安装完成后，您可以通过以下命令启动 WSL： 1wsl 注意: WSL 需要 Windows 10 版本 1709 或更高版本。 您可以通过以下命令检查您的 Windows 版本： 1winver 如果您使用的是 Windows 10 家庭版，您需要启用 “适用于 Linux 的 Windows 子系统” 功能： 1控制面板-&gt;程序和功能-&gt;启用或关闭 Windows 功能-&gt;适用于 Linux 的 Windows 子系统-&gt;确定 您可以通过以下命令启用 “适用于 Linux 的 Windows 子系统” 功能： 1dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux 重启您的计算机后，您就可以通过上述方法安装 WSL 了。 安装 Windows Terminal 编译环境配置 gcc-arm-none-eabi工具链安装 手动安装：官方链接地址 下载所需版本； 12sudo apt install bzip2sudo tar -xvf ~/n32_gcc/software_package/gcc-arm-none-eabi-9-2019-q4-major-x86_64-linux.tar.bz2 -C ~/n32_gcc 自动安装：sudo apt-get install gcc-arm-none-eabi 打开 ~/.bashrc 添加export PATH=$PATH:~/n32_gcc/gcc-arm-none-eabi-9-2019-q4-major/bin 添加alias open-file=&#39;explorer.exe .&#39; 使能用户环境变量source ~/.bashrc Make sudo apt-get install make Winodows Gcc + Make 环境搭建 安装software_package目录下的gcc-arm-none-eabi-9-2019-q4-major-win32-sha2.exe和make-3.81.exe 分别将其安装目录下的 ./bin添加到系统环境变量，重启生效 复制裸机工程至Windows下，修改部分Makefile的linux指令以适配Windows即可 裸机工程编译 cd n32g452_gcc make 环境配置及工具链打开新终端 ~&#x2F;.bashrc不会自动刷新解决linux每次打开新终端都要重新source ~/.bashrc问题执行以下代码： vi ~/.bash_profile 有可能此文件是空白新建的，无所谓。然后在此文件末尾加入： 123if [ -f ~/.bashrc ];thensource ~/.bashrcfi 然后:wq保存即可。此时打开新终端可以自动执行source ~/.bashrc arm-none-eabi-gcc工具链问题 arm-none-eabi-gcc工具链需加入用户变量：1export PATH=/home/xuan/OpenHarmony/install-software/gcc-arm-none-eabi-9-2019-q4-major/bin:$PATH 注意：需确认路径，否则找不到用户路径会搜索系统自带编译链 /usr/lib/gcc/arm-none-eabi/10.3.1 Linux下编写Python合并脚本合并 bootloader + app &#x3D; mix1. 安装 PyInstaller pip install pyinstaller 2. 编写Python合并程序 代码链接 3. 打包 Python 程序 参数说明： -F：生成单一可执行文件。 -D：生成包含所有依赖项的目录。 -n：指定可执行文件名。 --distpath：指定可执行文件输出目录。 --noconfirm：覆盖输出文件时无需确认。 以下是一些常用的高级选项： --hidden-import：指定要隐藏导入的模块。 --exclude-module：指定要排除的模块。 --onefile：将所有文件打包成一个可执行文件。 --runtime：指定 Python 运行时版本。 执行规则: cd new_file,copy file.py and file.ico pyinstaller -F -w (-i icofile) 文件名.py example: pyinstaller -F file.py pyinstaller -F -w -i file.ico file.py 4. 运行可执行文件 ./dist/file 5. 例程 代码链接 6. 实际应用场景 单独使用：Linux环境下单独执行使用。 集成在makefile中，使用make编译自动生成文件： 将papp_up和mix_10K打包至tools文件夹，放在makefile同一目录下。 需要bootloder.bin在../bootloader目录下。 修改makefile生成规则。 $(BUILD_DIR)为编译文件目录，跟进自身makefile修改。1234567891011121314151617181920212223242526.PHONY : clean allall: $(TARGET).bin $(TARGET).list $(TARGET).hex $(SZ) $(TARGET).elf @make copy @make mix.PHONY: copycopy: $(TARGET).bin cp $(TARGET).bin app.bin cp ../bootloader/bootloader.bin bootloader.bin# cp $(TARGET).hex app.hexmix: ./tools/papp_up ./tools/mix_10K $(OC) -I binary -O ihex --change-addresses 0x8000000 mix.bin mix.hex rm bootloader.bin rm app.bin rm mix.binclean: rm -rf $(BUILD_DIR) rm papp.bin rm mix.hex","tags":"linux wsl"},{"title":"I2C调试记录","url":"/2024/03/01/I2C调试记录/","text":"I2C基本原理介绍时序介绍参考Vishay的i2c时序图： 代码实现详解I2C协议实现有硬件I2C和软件I2C之分，这里只讲解软件I2C实现的版本。一下列出主要结构体和初始化函数。 I2C协议初始化I2C协议的scl和sda配置为开漏输出,需要外部上拉（一般为10K电阻） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#define i2c_pin_mode(pin,mode) drv_pin_mode(pin,mode)#define i2c_pin_write(pin,level) drv_pin_write(pin,level)#define i2c_pin_read(pin) drv_pin_read(pin)#define DRV_I2C_WR 0x00#define DRV_I2C_RD (1u &lt;&lt; 0)#define DRV_I2C_ADDR_10BIT (1u &lt;&lt; 2) /* this is a ten bit chip address */#define DRV_I2C_NO_START (1u &lt;&lt; 4)#define DRV_I2C_IGNORE_NACK (1u &lt;&lt; 5)#define DRV_I2C_NO_READ_ACK (1u &lt;&lt; 6) /* when I2C reading, we do not ACK */#define DRV_I2C_NO_STOP (1u &lt;&lt; 7)typedef enum&#123; EI2C_DEV_1 = 1, EI2C_DEV_2, EI2C_DEV_3&#125;EI2C_DEVICE;struct drv_soft_i2c_config&#123; uint8_t scl; uint8_t sda; uint8_t i2c_num;&#125;;struct drv_i2c_msg&#123; uint16_t addr; uint16_t flags; uint16_t len; uint8_t reg_addr; uint8_t *buf;&#125;;struct drv_i2c_bit_ops&#123; void *data; /* private data for lowlevel routines */ void (*set_sda)(void *data, int state); void (*set_scl)(void *data, int state); int (*get_sda)(void *data); int (*get_scl)(void *data); void (*udelay)(uint32_t us); uint32_t delay_us; /* scl and sda line delay */ uint32_t timeout; /* in tick */&#125;;struct drv_i2c_bus_device&#123; struct drv_i2c_msg msg; struct drv_i2c_bit_ops ops;&#125;;static void drv_i2c_gpio_init(struct drv_soft_i2c_config *i2c)&#123; struct drv_soft_i2c_config* cfg = i2c; i2c_pin_mode(cfg-&gt;scl, I2C_PIN_MODE_OUTPUT_OD); //PIN_MODE_OUTPUT i2c_pin_mode(cfg-&gt;sda, I2C_PIN_MODE_OUTPUT_OD); i2c_pin_write(cfg-&gt;scl, I2C_PIN_HIGH); i2c_pin_write(cfg-&gt;sda, I2C_PIN_HIGH);&#125;int drv_hw_i2c_init(EI2C_DEVICE dev_e)&#123; int size = sizeof(i2c_pin_config)/sizeof(struct drv_soft_i2c_config); struct drv_i2c_bus_device *dev = get_i2c_device(dev_e); uint8_t dev_num = (uint8_t)dev_e; struct drv_soft_i2c_config *pin_cfg = NULL; struct drv_i2c_bit_ops *ops = &amp;dev-&gt;ops; for(int i=0;i&lt;size;i++) &#123; if(i2c_pin_config[i].i2c_num == dev_num) &#123; pin_cfg = (struct drv_soft_i2c_config *)&amp;i2c_pin_config[i]; break; &#125; &#125; if(pin_cfg == NULL) return -1; ops-&gt;data = (void*)pin_cfg; ops-&gt;set_sda = n32_set_sda; ops-&gt;set_scl = n32_set_scl; ops-&gt;get_sda = n32_get_sda; ops-&gt;get_scl = n32_get_scl; ops-&gt;udelay = n32_udelay; ops-&gt;delay_us = 1; ops-&gt;timeout = 5; drv_i2c_gpio_init(pin_cfg); drv_i2c_bus_unlock(pin_cfg); return 0;&#125; 接口函数12345678int drv_i2c_bit_xfer(struct drv_i2c_bit_ops *bus, struct drv_i2c_msg msgs[], uint32_t num);struct drv_i2c_bus_device *get_i2c_device(EI2C_DEVICE dev_e);static uint64_t i2c_tick_get(void);int drv_hw_i2c_init(EI2C_DEVICE dev_e);int drv_i2c_send_data(EI2C_DEVICE dev_e,uint16_t addr,uint8_t reg_addr,uint8_t *buf,uint16_t len);int drv_i2c_recv_data(EI2C_DEVICE dev_e,uint16_t addr,uint8_t reg_addr,uint8_t *buf,uint16_t len); 实战开发问题分析实际开发过程中，同样的I2C驱动程序，在不同厂家芯片的使用上出现一些问题，导致部分厂家通信异常，导致数据接收不正确，以下进行分析对比，作证并解决问题。 Vishay 和 亿光 接近传感器模块对比Vishay使用VCNL3682S型号芯片，亿光使用APM-16D24-U6E型号芯片，I2C协议对比。 Vishay ： 亿光： 对比波形对比协议来看基本上是一致的，用JI2C工具测的i2c波形也基本上一致，但是我自己写的软件i2c驱动，Vishay可以正常使用，亿光读取的数据就有问题，用逻辑分析仪抓一波波形分析一下。 发现每次读完都会多恢复一个ack，而协议上读完最后一个字节需要恢复nack。 修改了以下代码12345678910111213141516static int i2c_send_ack_or_nack(struct drv_i2c_bit_ops *bus, int ack)&#123; struct drv_i2c_bit_ops *ops = bus; if (ack) // if(ack &gt;= 0) 改成 if(ack) SET_SDA(ops, 0); i2c_delay(ops); if (SCL_H(ops) &lt; 0) &#123;// logVerbose(&quot;ACK or NACK timeout.&quot;); return -2; &#125; SCL_L(ops); return 0;&#125; static int i2c_send_ack_or_nack(struct drv_i2c_bit_ops *bus, int ack)&#123;&#125;函数主要处理响应回复。 if(ack &gt;= 0)表示每次都会回复ack/nack if(ack)表示除最后一次数据不回复，其他每次都会回复ack/nack","tags":"逻辑分析仪 接近传感器"},{"title":"ESP32开发小贴士","url":"/2024/02/22/ESP32小贴士/","text":"ESP32 ESP-IDF自定义组件简介官方文档英文官方文档链接中文官方文档链接 示例说明此示例在《ESP32 smart_config和airkiss配网》https://zhuanlan.zhihu.com/p/440454542https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/121687760基础上，增加连接成功后点亮板载LED功能。实现所需功能后将各功能代码分离，再将分离后的代码构造成组件，使得项目有清晰的结构，方便功能代码移植. 开发环境《Win10启用Linux子系统安装Ubuntu》https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/112131624 《用乐鑫国内Gitee镜像搭建ESP32开发环境》https://link.zhihu.com/?target=https%3A//blog.csdn.net/chentuo2000/article/details/113424934 构建项目拷贝 &amp;&amp; 初始化例程将例子项目hello_world复制到ESP-IDF开发工具之外,更名为components_demo: cd ~/esp cp -r ~/esp/esp-adf/esp-idf/examples/get-started/hello_world ./components_demo 清空build目录: cd ~/esp/components_demo rm -r build/* 注意，每当添加了新组件就要删除build目录下的全部内容，或者执行下面这条命令： idf.py fullclean 清除以前的构建。 添加组件letter_shellidf.py -C components create-component letter_shell 该命令会创建一个新组件,新组件将包含构建组件所需的一组空文件。我们的工作就是在这一组空文件中写上我们的代码。如果熟悉了组件结构，也可以直接在项目中手工创建。 项目树构建好的项目结构如下: 注意：组件目录components名字不能改，其下的组件名可以随意取。build目录是编译时生成的，编译的结果都放在其中。dependencies.lock是随原来的项目复制过来的不要改。sdkconfig文件可以用idf.py menuconfig命令修改。 代码和说明各文件的位置关系很重要，请对照前面的项目树看代码文件。 项目的根CMakeLists.txt文件# The following lines of boilerplate have to be in your project&#39;s # CMakeLists in this exact order for cmake to work correctly cmake_minimum_required(VERSION 3.16) include($ENV&#123;IDF_PATH&#125;/tools/cmake/project.cmake) project(components_demo) 只需要修改project中的项目名称。 main目录CMakeLists.txt idf_component_register(SRCS &quot;main.c&quot; INCLUDE_DIRS &quot;.&quot;) main.c 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;freertos/queue.h&quot;#include &quot;esp_log.h&quot;#include &quot;shell_port.h&quot;#include &quot;log.h&quot;#include &quot;nvs_flash.h&quot;static const char *TAG = &quot;sample test&quot;;void app_main(void)&#123; esp_err_t ret; // Initialize NVS. ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) &#123; ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); &#125; ESP_ERROR_CHECK( ret ); esp_log_level_set(TAG, ESP_LOG_INFO); ESP_LOGI(TAG,&quot;this is a test program&quot;); userShellInit(); logInfo(&quot;log info!&quot;); logDebug(&quot;log debug!&quot;); logWarning(&quot;log warning!&quot;); logError(&quot;log error!&quot;); while(1) &#123; logDebug(&quot;log loop!&quot;); vTaskDelay(pdMS_TO_TICKS(2000)); &#125;&#125; 头文件nvs_flash.h是对系统组件的引用，shell_port.h是对自定义组件的引用。 letter_shell组件CMakeLists.txt: idf_component_register( SRCS &quot;shell.c&quot; &quot;shell_ext.c&quot; &quot;log.c&quot; &quot;shell_port.c&quot; INCLUDE_DIRS &quot;include&quot; LDFRAGMENTS &quot;shell.lf&quot; # PRIV_REQUIRES led REQUIRES esp_driver_uart ) 说明：1、PRIV_REQUIRES该参数指定对其它自定义组件的依赖，即私有依赖项。 PRIV_REQUIRES led表示指出在smart_config组件中要用到自定义的led组件。组件名字可以加引号，也可以不加。多个组件用空格分开。 2、 REQUIRES该参数指定对系统组件的依赖，即公共依赖项。 REQUIRES esp_driver_uart 表示在letter_shell组件中要用到系统组件esp_driver_uart。 3、系统组件的确定 对于要依赖的系统组件不像私有依赖项那样一目了然，有时我们并不清楚所要的系统组件名称。比如我们不知道需要组件wpa_supplicant，这时我们可以先编译一次，看看错误信息： 在CMakeLists.txt中添加依赖组件REQUIRES esp_driver_uart，编译通过。 关于CMakeLists.txt文件根和每个目录都有一个CMakeLists.txt文件，开始遇到的问题是不知道目录结构和怎样写CMakeLists.txt文件，要注意每一层目录中CMakeLists.txt文件的写法，本文的例子给出了一个简单的示范。对于复杂的项目还需要更多编写CMakeLists.txt文件的知识，请看简介中给出的官方文档。 ESP32移植Letter_shell问题添加shell组件及其log，编译出错可能原因: 宏使用不正确: 如果 SHELL_FREE 旨在实际释放与 companions 对象关联的内存或资源，则当前定义不正确。它应该调用内存管理函数或执行其他必要的清理任务。 编译器警告被视为错误: -Werror=unused-value 标志已启用，它将警告视为错误。即使宏使用本身可能不是关键问题，这也可能导致编译失败。 解决方案:修复 SHELL_FREE 定义: 如果 companions 需要内存分配，请更新 shell_cfg.h 中的 SHELL_FREE 宏以调用适当的内存管理函数，例如 free()。 如果 companions 不需要内存管理，请从 shell_companion.c 中的第 57 行删除 SHELL_FREE 调用；或者将shell_cfg.h 中的第 36 行 SHELL_USING_COMPANION 的宏定义改为 0。 禁用 -Werror&#x3D;unused-value (如果适用):如果您希望将未使用的值警告视为警告而不是错误，您可以暂时在编译期间禁用 -Werror=unused-value 标志。但是，通常建议修复底层问题以避免潜在的内存泄漏或资源管理问题。 其他提示: 提供有关您的项目更多信息，例如具体的 ESP-IDF 版本、涉及的组件以及 SHELL_FREE 宏的用途。这将有助于了解根本原因并提供更定制的指导。 分享 shell_cfg.h 头文件和 shell_companion.c 文件的相关部分，以便分析代码结构和上下文。考虑使用调试器逐步执行代码并检查 companions 在 SHELL_FREE 调用之前和之后的 值，以了解其使用情况和潜在的内存管理问题。 通过遵循这些步骤并提供更多信息，我可以帮助您有效地解决编译错误并确保您的 ESP-IDF 项目成功构建。 配置shell优先级将shell的freertos优先级设置为 tskIDLE_PRIORITY，为0级，跟空闲函数优先级一样，所有其他优先级任务执行完后才会执行 tskIDLE_PRIORITY优先级任务。 源代码例程ESP32移植letter_shell组件例程","tags":"esp32"},{"title":"ESP32开发环境搭建","url":"/2024/02/19/ESP32环境搭建/","text":"开发环境搭建ESP-ADF快速上手连接ESP-IDF快速上手连接 获取ESP-ADF打开Linux or macOS终端,新建搭建环境所需文件夹。 mkdir ~/esp cd ~/esp 编译 ESP-IDF 需要以下软件包。请根据使用的 Linux 发行版本，选择合适的安装：Ubuntu 和 Debian: sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 CentOS 7 &amp; 8: sudo yum -y update &amp;&amp; sudo yum install git wget flex bison gperf python3 python3-setuptools cmake ninja-build ccache dfu-util libusbx Arch: sudo pacman -S --needed gcc git make flex bison gperf python cmake ninja ccache dfu-util libusb 克隆最新版ESP-ADF： git clone --recursive https://github.com/espressif/esp-adf.git 若克隆失败，尝试以下指令： git clone --recursive git@github.com:espressif/esp-adf.git 若子模块拉取失败，尝试手动逐个拉取子模块： cd ~/esp/esp-adf/components git clone git@github.com:espressif/esp-adf-libs.git cd ~/esp/esp-adf/components git clone git@github.com:espressif/esp-sr.git cd ~/esp/esp-adf git clone git@github.com:espressif/esp-idf.git 设置环境变量按自己实际路径，可按自己喜好设置，也可不配置，手动敲指令也可。 vi ~/.bashrc在后面加上以下代码： 12345678910#开启ESP32编译环境alias get-idf=&#x27;. $HOME/esp/esp-adf/esp-idf/export.sh&#x27;alias get-adf=&#x27;. $HOME/esp/esp-adf/export.sh&#x27;#打开本地文件夹（wsl）alias open-file=&#x27;explorer.exe .&#x27;#烧录到设备，并打开监视器，/dev/ttyS15为USB挂载端口，需测试后填写，115200为监视器波特率，与设备UART0波特率对应alias esp-download=&#x27;idf.py -p /dev/ttyS15 -b 115200 flash monitor&#x27;export PATH=/home/qx_song/esp/esp-adf/esp-idf/tools:$PATHexport IDF_PATH=/home/qx_song/esp/esp-adf/esp-idfexport ADF_PATH=/home/qx_song/esp/esp-adf 保存退出 :wq 设置工具除了 ESP-IDF 本身，还需要为支持 ESP32 的项目安装 ESP-IDF 使用的各种工具，比如编译器、调试器、Python 包等。 cd ~/esp/esp-adf/esp-idf 安装esp32，esp32s2工具，运行以下指令：（按需求安装） ./install.sh esp32,esp32s2 若需要安装所有工具，运行以下指令： ./install.sh all 以下为ESP-IDF编译所需环境，请在需要运行ESP-IDF的终端窗口运行以下命令： . $HOME/esp/esp-adf/esp-idf/export.sh 或者使用快捷指令： get-idf ESP32工程示例开始创建工程现在，可以准备开发 ESP32 应用程序了。从 ESP-IDF 中 examples 目录下的 get-started/hello_world 工程开始，将 get-started/hello_world 工程复制至本地的 ~&#x2F;esp 目录下： cd ~/esp get-idf cp -r $IDF_PATH/examples/get-started/hello_world . 配置工程cd ~/esp/hello_world idf.py set-target esp32 由于ESP32是单核，默认配置是双核模式，需要配置参数： idf.py menuconfig Component config -&gt; FreeRTOS -&gt; [*]Run FreeRTOS only on first core 保存退出 编译工程idf.py build 烧录工程idf.py -p PORT flash 请将 PORT 替换为 ESP32 开发板的串口名称。如果 PORT 未经定义，idf.py 将尝试使用可用的串口自动连接。 合并执行构建、烧录和监视过程：idf.py -p PORT [-b BAUD] flash monitor 注：[-b BAUD] 和 monitor 配合使用，BAUD为程序中UART0的波特率 idf.py -p /dev/ttyS15 -b 115200 flash monitor idf.py -p [挂载端口] -b [波特率] flash monitor 擦除flashidf.py -p PORT erase-flash 若存在需要擦除的 OTA 数据，请运行以下命令： idf.py -p PORT erase-otadata 挂载端口windows 子系统 wsl输入烧录指令： idf.py flash 观察终端设备是挂载在哪个端口上，有ERROR忽略，选择端口例如 /dev/ttyS15，程序中UART0的波特率115200，下次就可以直接输此端口就可以烧录啦。 idf.py -p /dev/ttyS15 -b 115200 flash monitor 如果 ESP-IDF 监视器在烧录后很快发生错误，或打印信息全是乱码（如下），很有可能是因为开发板采用了 26 MHz 晶振，而 ESP-IDF 默认支持大多数开发板使用的 40 MHz 晶振。 x���ff�f�����`�~�~���f���x��f�f�����ff��`���f����`��~x������ff�f�����`�~�~�f����f����f`���x��f�f�����ff��`���f 此时，可以：1、退出监视器。2、返回 idf.py menuconfig。3、进入 Component config –&gt; Hardware Settings –&gt; Main XTAL Config –&gt; Main XTAL frequency 进行配置，将 CONFIG_XTAL_FREQ_SEL 设置为 26 MHz。4、重新编译和烧录应用程序。 总结启动终端ESP32编译只需要进行以下步骤： . $HOME/esp/esp-adf/esp-idf/export.sh //开启编译环境 idf.py set-target esp32 //首次搭建项目时配置 idf.py menuconfig //选择需要的配置 idf.py build idf.py flash 快捷方式： get-idf idf.py set-target esp32 idf.py menuconfig idf.py build esp-download","tags":"esp32 linux"},{"title":"Markdown小贴士","url":"/2024/02/19/Markdown小贴士/","text":"Markdown 的基本语法Markdown 的语法非常简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。以下是一些常用的 Markdown 标记符号： 标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 文本普通文本 **加粗文本** *斜体文本* **~删除线文本~** 列表* 无序列表 1. 有序列表 * 嵌套列表 代码块123456#include &lt;stdio.h&gt;int main() &#123;printf(&quot;Hello, world!\\n&quot;);return 0;&#125; 文本中代码高亮使用`printf(&quot;Hello, world!\\n&quot;);`函数进行打印 效果：使用printf(&quot;Hello, world!\\n&quot;);函数进行打印 链接链接文本: https://www.example.com 图片网络地址: ![这是一张示例图片](https://www.example.com/example.png) 本地文件路径：![这是一张示例图片](../pictures/这是一张示例图片.png) 图片链接跳转: ![这是一张示例图片](example.png) &#123;link=https://www.example.com/&#125; 图片标题: ![这是一张示例图片](example.png) &#123;title=这是一张示例图片&#125; 图片居中: ![这是一张示例图片](example.png) &#123;align=center&#125; 示例： ![这是一张示例图片](example.png) ![这是一张 200x100 像素的图片](example.png) &#123;width=200 height=100&#125; ![这是一张居中的图片](example.png) &#123;align=center&#125; ![点击图片跳转到 https://www.example.com/](example.png) &#123;link=https://www.example.com/&#125; ![这是一张示例图片](example.png) &#123;title=这是一张示例图片&#125; 表格 头部1 头部2 头部3 内容1 内容2 内容3 内容4 内容5 内容6 Markdown 的应用博客文章 技术文档 README 文件 演示文稿 电子书 总结Markdown 是一种易于学习和使用的标记语言，非常适合编写各种文档。如果您还没有使用过 Markdown，建议您尝试一下。 以下是 Markdown 官方教学网站：Markdown 官方网站","tags":"markdown"},{"title":"单片机开发问题汇总","url":"/2024/01/31/MCU开发问题汇总/","text":"内核复位（kernel reset）常见通用问题 内核复位代码，如ADC： 1234567891011void kernel_reset(void)&#123; __DSB(); __disable_irq(); //close irq drv_adc_deinit(EADC_DEV1,EDMA_CH6); //disable adc data SCB-&gt;AIRCR = ((0x5FA &lt;&lt; SCB_AIRCR_VECTKEY_Pos) | (SCB-&gt;AIRCR &amp; SCB_AIRCR_PRIGROUP_Msk) | SCB_AIRCR_VECTRESET_Msk); __DSB(); while(1);&#125; 板级初始化前先要重置状态： 12DMA_DeInit(dma_chx); //DMA开启循环接收后会持续接收字节ADC_DeInit(adc_handler); ADC驱动初始化&#x2F;反初始化: 1234567891011121314151617int drv_adc_init(EADC_DEVICE adc_dev,EDMA_CHANNEL dma_ch)&#123; drv_adc_configuration(adc_dev); drv_dma_configuration(adc_dev,dma_ch); drv_adc_enable(adc_dev,DISABLE); return 0;&#125;int drv_adc_deinit(EADC_DEVICE adc_dev,EDMA_CHANNEL dma_ch)&#123; ADC_Module *adc_handler = drv_get_adc_device(adc_dev)-&gt;ADC_Handler; DMA_ChannelType * dma_chx = drv_get_dma_channel(dma_ch); drv_adc_enable(adc_dev,DISABLE); DMA_EnableChannel(dma_chx,DISABLE); return 0;&#125; n32g452rc内核复位问题bootloader跳转到app 栈大小改变后跳转成功：将ram空间数据uint16_t改为uint32_t。 堆大小改变后跳转成功：将队列申请长度20改为30。 代码大小变化后跳转失败： 代码段变长，能跑进system_init,跑飞待查。 代码段变短，不能跑进system_init,跑飞待查。 总结： n32g45x系列栈大小和堆大小影响不大，只要代码段大小不变，跳转成功；若代码段长度变化，跳转失败。（芯片原因？） n32l40x系列不存在此类问题。 MCU复位后状态 复位期间和刚复位后，复用功能未开启,I/O端口被配置成模拟功能模式(PCFGy[1:0] = 00b, PMODEy[1:0] = 00b)。 但有以下几个例外的信号：BOOT0、 NRST、 OSC_IN、 OSC_OUT 默认无 GPIO 功能： BOOT0 引脚默认输入下拉 NRST 上拉输入输出 复位后，调试系统相关的引脚默认状态为启动 SWD-JTAG， JTAG 引脚被置于输入上拉或下拉模式： PA15：JTDI 置于输入上拉模式 PA14：JTCK 置于输入下拉模式 PA13：JTMS 置于输入上拉模式 PB4：NJTRST 置于输入上拉模式 PB3：JTD0 置于推挽输出无上下拉 PD0 和 PD1 PD0 和 PD1 在 80 及以上引脚封装默认为模拟模式 PD0 和 PD1 在 80 以下引脚封装复用到 OSC_IN&#x2F;OUT PC13、 PC14、 PC15： PC13～15 为备电域下的三个 IO， 备份域初次上电默认为模拟模式； PB2&#x2F;BOOT1： PB2&#x2F;BOOT1 默认处于下拉输入状态； BOOT0 默认输入下拉，参照下表， 若 BOOT 的引脚未连接，则默认选择 Flash 主存储区。 问题：n32g452系列芯片， 串口2无法发送数据问题 打印测试进入了usart2的串口发送函数，示波器测量，有尖峰异常波形。 解决：串口2引脚为PB4,默认为JTAG引脚，复用时应关闭JTAG功能。 12// 使用jlink引脚复用成GPIO时需要关闭jlink引脚功能，否则无法正常输出。GPIO_ConfigPinRemap(GPIO_RMP_SW_JTAG_SW_ENABLE, ENABLE); 时钟引脚使用问题(n32l406为例)，可能不需要复用，以实际为准。123456789101112/*开启复用的外设时钟使能*/if(pin == 5)&#123; RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_AFIO,ENABLE); GPIO_ConfigPinRemap(GPIOD_PORT_SOURCE,GPIO_PIN_SOURCE14,GPIO_NO_AF); /*映射的使能*/&#125;if(pin == 6)&#123; RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_AFIO,ENABLE); GPIO_ConfigPinRemap(GPIOD_PORT_SOURCE,GPIO_PIN_SOURCE15,GPIO_NO_AF); /*映射的使能*/&#125; printf重定向 MDK版本，勾选Use MicroLIB选项： 123456789101112131415161718192021222324static int is_lr_sent = 0;int fputc(int ch, FILE* f)&#123; if (ch == &#x27;\\r&#x27;) &#123; is_lr_sent = 1; &#125; else if (ch == &#x27;\\n&#x27;) &#123; if (!is_lr_sent) &#123; USART_SendData(USART1, &#x27;\\r&#x27;); while (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET); &#125; is_lr_sent = 0; &#125; else &#123; is_lr_sent = 0; &#125; USART_SendData(USART1, ch); while (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET); return ch;&#125; GCC版本 123456789int _write(int fd, char* pBuffer, int size)&#123; for (int i = 0; i &lt; size; i++) &#123; USART_SendData(USART1, pBuffer[i]); while (USART_GetFlagStatus(USART1, USART_FLAG_TXDE) == RESET); &#125; return size;&#125; RT-THREAD调试问题LETTER SHELL问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// SHELL_USING_LOCK设为 1，则需要初始化互斥锁，否则shell会死机。// LOG_USING_LOCK设为 0，否则log会死机，问题不详。#define SHELL_USING_LOCK 1 #define LOG_USING_LOCK 0#if SHELL_USING_LOCKstatic struct rt_mutex shellMutex;int userShellLock(Shell *sh)&#123; rt_mutex_take(&amp;shellMutex,RT_WAITING_FOREVER); // rt_tick_from_millisecond(100),RT_WAITING_FOREVER return 0;&#125;/** * @brief 用户shell解锁 * @param shell shell * @return int 0 */int userShellUnlock(Shell *sh)&#123; rt_mutex_release(&amp;shellMutex); return 0;&#125;#endif#if LOG_USING_LOCKstatic struct rt_mutex logMutex;int userLogLock(Log *log)&#123; rt_mutex_take(&amp;logMutex, RT_WAITING_FOREVER); //rt_tick_from_millisecond(10) return 0;&#125;int userLogUnlock(Log *log)&#123; rt_mutex_release(&amp;logMutex); return 0;&#125;#endifvoid User_Shell_Init(void)&#123; struct serial_configure config = EC_SERIAL_CONFIG_DEFAULT; config.baud_rate = BAUD_RATE_921600; drv_usart_init(ESERIAL_1, ESERIAL_MODE_DMA_RX | ESERIAL_MODE_DMA_TX, &amp;config);#if SHELL_USING_LOCK rt_mutex_init(&amp;shellMutex,&quot;shellMutex&quot;,RT_IPC_FLAG_FIFO); shell.unlock = userShellUnlock; shell.lock = userShellLock;#endif#if LOG_USING_LOCK rt_mutex_init(&amp;logMutex,&quot;logMutex&quot;,RT_IPC_FLAG_FIFO); uartLog.unlock = userLogUnlock; uartLog.lock = userLogLock;#endif shell.write = User_Shell_Write; shell.read = User_Shell_Read; shellInit(&amp;shell, shell_buffer, sizeof(shell_buffer)); logRegister(&amp;uartLog, &amp;shell);&#125; 串口通信异常 打开UART7接收为DMA IDLE中断，申请一个超时定时器，发送&#x2F;接受各一个任务，发送&#x2F;接受两个队列,以下是错误信息： 1234567891011121314151617181920212223psr: 0x60000000r00: 0x00000000r01: 0x20007978r02: 0x20007978r03: 0x00000000r04: 0x00000000r05: 0x00000000r06: 0x00000000r07: 0x20000920r08: 0x20005908r09: 0x20000568r10: 0xdeadbeefr11: 0xdeadbeefr12: 0x00000000 lr: 0x0801156f pc: 0x00000000hard fault on thread: timerE [00:00:07,324] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue) assertion failed at function:rt_mq_send_wait, line number:2026 E [00:00:00,659] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type(&amp;timer-&gt;parent) == RT_Object_Class_Timer) assertion failed at function:rt_timer_control, line number:474 E [00:00:39,282] (rtt-nano/src/kservice.c) rt_assert_handler [1340]: (rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread) assertion failed at function:rt_thread_resume, line number:760 问题定位到指针变量p_srx_mq[0]和&amp;p_srx_mq[0]的区别，代码如下： 12345678910111213141516171819202122232425#define COMM_MAX_NUM 3static uint8_t *p_srx_mq[COMM_MAX_NUM];static struct comm_serial_mq srx_mq_data[COMM_MAX_NUM];static struct rt_timer comm_rx_stimer[COMM_MAX_NUM];static void comm_serial_recieve_data_deinit(uint8_t num)&#123; srx_mq_data[num].size = 0; p_srx_mq[num] = srx_mq_data[num].data;&#125;static int usart_key_rx_indicate(ESERIAL_DEV serial_dev, uint16_t size)&#123; if(p_srx_mq[0] - srx_mq_data[0].data + size &gt; sizeof(srx_mq_data[0].data)) &#123; comm_serial_recieve_data_deinit(0); return -1; &#125; rt_timer_start(&amp;comm_rx_stimer[0]); // 启动定时器 drv_fifo_data_get(serial_dev, (uint8_t *)p_srx_mq[0], size); logPrintln(&quot;test = [%p][%p][%p]&quot;,p_srx_mq[0],&amp;p_srx_mq[0],srx_mq_data[0].data); p_srx_mq[0] += size; srx_mq_data[0].size += size; return 0;&#125; FlashDB问题（碰巧对上述问题未遇到问题的解决） 上述问题LETTER SHELL问题中SHELL_USING_LOCK设为1，LOG_USING_LOCK需设为0,否则会卡死，经调试后下面会做出解释。 在初始化的时候，不管是KVDB还是TSDB，必须在烧完程序后，reboot一下才能初始化扇区成功，原因待查。 会出现以下打印后卡住： 123456789101112131415161718admin:/$ tsdb_test[D/FAL] (fal_flash_init:47) Flash device | n32_onchip | addr: 0x08000000 | len: 0x00080000 | blk_size: 0x00000800 |initialized finish.[I/FAL] ==================== FAL partition table ====================[I/FAL] | name | flash_dev | offset | length |[I/FAL] -------------------------------------------------------------[I/FAL] | bl | n32_onchip | 0x00000000 | 0x00002800 |[I/FAL] | app | n32_onchip | 0x00002800 | 0x00032000 |[I/FAL] | download | n32_onchip | 0x00034800 | 0x00032000 |[I/FAL] | upflag | n32_onchip | 0x00066800 | 0x00000800 |[I/FAL] | dcd | n32_onchip | 0x00067000 | 0x00000800 |[I/FAL] | mcuinfo | n32_onchip | 0x00067800 | 0x00000800 |[I/FAL] | fdb_kvdb1 | n32_onchip | 0x00068000 | 0x00001000 |[I/FAL] | fdb_tsdb1 | n32_onchip | 0x00069000 | 0x00016800 |[I/FAL] =============================================================[I/FAL] RT-Thread Flash Abstraction Layer (V1.0.0) initialize success.[FlashDB][tsl][log][fdb_tsdb1] Sector (0x00000000) header info is incorrect.// 跑飞卡死 烧录完reboot后，正常的打印： 12345678910111213141516171819202122232425262728293031admin:/$ tsdb_test[D/FAL] (fal_flash_init:47) Flash device | n32_onchip | addr: 0x08000000 | len: 0x00080000 | blk_size: 0x00000800 |initialized finish.[I/FAL] ==================== FAL partition table ====================[I/FAL] | name | flash_dev | offset | length |[I/FAL] -------------------------------------------------------------[I/FAL] | bl | n32_onchip | 0x00000000 | 0x00002800 |[I/FAL] | app | n32_onchip | 0x00002800 | 0x00032000 |[I/FAL] | download | n32_onchip | 0x00034800 | 0x00032000 |[I/FAL] | upflag | n32_onchip | 0x00066800 | 0x00000800 |[I/FAL] | dcd | n32_onchip | 0x00067000 | 0x00000800 |[I/FAL] | mcuinfo | n32_onchip | 0x00067800 | 0x00000800 |[I/FAL] | fdb_kvdb1 | n32_onchip | 0x00068000 | 0x00001000 |[I/FAL] | fdb_tsdb1 | n32_onchip | 0x00069000 | 0x00016800 |[I/FAL] =============================================================[I/FAL] RT-Thread Flash Abstraction Layer (V1.0.0) initialize success.[FlashDB][tsl][log][fdb_tsdb1] Sector (0x00000000) header info is incorrect.[FlashDB][tsl][log][fdb_tsdb1] All sector format finished.[FlashDB][tsl][log][fdb_tsdb1] (components/flashdb/fdb_tsdb.c:980) TSDB (log) oldest sectors is 0x00000000, current using sector is 0x00000000.[FlashDB] FlashDB V2.1.1 is initialize success.[FlashDB] You can get the latest version on https://github.com/armink/FlashDB .[FlashDB][sample][tsdb] ==================== tsdb_sample ====================[FlashDB][sample][tsdb] append the new status.temp (36) and status.humi (85)[FlashDB][sample][tsdb] append the new status.temp (38) and status.humi (90)[FlashDB][sample][tsdb] [query_cb] queried a TSL: time: 1, temp: 36, humi: 85[FlashDB][sample][tsdb] [query_cb] queried a TSL: time: 2, temp: 38, humi: 90[FlashDB][sample][tsdb] [query_by_time_cb] queried a TSL: time: 1, temp: 36, humi: 85[FlashDB][sample][tsdb] [query_by_time_cb] queried a TSL: time: 2, temp: 38, humi: 90[FlashDB][sample][tsdb] query count is: 2[FlashDB][sample][tsdb] set the TSL (time 1) status from 2 to 3[FlashDB][sample][tsdb] set the TSL (time 2) status from 2 to 3[FlashDB][sample][tsdb] =========================================================== 原因：由于flash解锁是给互斥量加锁，之前写成一致了，写反了，导致进去一次之后卡死。 1234567891011121314151617static struct rt_mutex flashMutex;void af_flash_init(void)&#123; rt_mutex_init(&amp;flashMutex, &quot;flashMutex&quot;, RT_IPC_FLAG_FIFO);&#125;void af_flash_unlock(void)&#123; rt_mutex_take(&amp;flashMutex, RT_WAITING_FOREVER); // 错误用例：rt_mutex_release(&amp;flashMutex); FLASH_Unlock();&#125;void af_flash_lock(void)&#123; FLASH_Lock(); rt_mutex_release(&amp;flashMutex); // 错误用例：rt_mutex_take(&amp;flashMutex, RT_WAITING_FOREVER); &#125; 指针取址符&amp;与取值*的区别1. 指针取址符(&amp;) 指针取址符 &amp; 用于获取一个变量的地址，并将该地址存储在一个指针变量中。 具体来说: &amp; 运算符位于变量名前面。 &amp; 运算符的返回值是一个指针，指向该变量的内存地址。 12int num = 10;int *p = &amp;num; // p 指向 num 的地址 2. 取值符(*) 取值符 * 用于获取指针变量所指向的变量的值。 具体来说: 运算符位于指针变量名前面。 运算符的返回值是该指针变量所指向变量的值。 123int num = 10;int *p = &amp;num;int value = *p; // 访问 num 的值 总结： 指针取址符 &amp; 用于获取变量的地址，并将该地址存储在一个指针变量中。 取值符 * 用于获取指针变量所指向的变量的值。 需要注意的是： 不能对不存在的变量进行取址。 **不能对指针变量进行取址**。 取址操作可能会产生空指针，需要进行空指针检查。 为什么不能对指针变量进行取址1. 指针变量本身也是一个变量 指针变量也是一个变量，它存储的是另一个变量的地址。与其他变量一样，**指针变量也存在于内存中，并拥有自己的地址**。 2. 取址操作会产生无限循环 **如果对指针变量进行取址，那么就会得到该指针变量的地址**。但是，该指针变量本身也是一个变量，所以其地址也是存储在另一个变量中的。如此循环往复，就会产生无限循环。 3. 违背了指针的定义 指针的定义是指向另一个变量的地址。如果对指针变量进行取址，那么就意味着指针指向了它自己的地址，这违背了指针的定义。 4. 可能导致程序崩溃 在大多数情况下，对指针变量进行取址会导致程序崩溃。这是因为程序会试图访问一个不存在的内存地址。 结构体偏移操作 offsetof(TYPE, MEMBER) 函数用法：12345678910111213141516/* Offset of member MEMBER in a struct of type TYPE. */#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)typedef struct __attribute__((packed))&#123; uint8_t device; uint8_t version; uint16_t packet_sum; // 大端模式 uint16_t packet_index; // 大端模式 uint8_t len; uint8_t cmd; uint8_t *data; uint16_t check_sum; // 大端模式&#125;ble_comm_protocol;int send_len = offsetof(ble_comm_protocol, data); // send_len 长度为 8 bytes TFT屏ST7735S调试问题硬件&#x2F;软件spi初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//头文件定义#define HARDWARE_SPI_MODE 1 //1：hardware；0：software#define LCD_SCLK_Clr() GPIO_ResetBits(GPIOA, GPIO_PIN_5) //SCL=SCLK#define LCD_SCLK_Set() GPIO_SetBits(GPIOA, GPIO_PIN_5)#define LCD_MOSI_Clr() GPIO_ResetBits(GPIOA, GPIO_PIN_7) //SDA=MOSI#define LCD_MOSI_Set() GPIO_SetBits(GPIOA, GPIO_PIN_7)#define LCD_RES_Clr() GPIO_ResetBits(GPIOB, GPIO_PIN_0) //RES#define LCD_RES_Set() GPIO_SetBits(GPIOB, GPIO_PIN_0)#define LCD_DC_Clr() GPIO_ResetBits(GPIOB, GPIO_PIN_1) //DC#define LCD_DC_Set() GPIO_SetBits(GPIOB, GPIO_PIN_1) #define LCD_CS_Clr() GPIO_ResetBits(GPIOA, GPIO_PIN_4) //CS#define LCD_CS_Set() GPIO_SetBits(GPIOA, GPIO_PIN_4)#define LCD_BLK_Clr() //BLK#define LCD_BLK_Set()void LCD_GPIO_Init(void)&#123; GPIO_InitType GPIO_InitStructure; RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_GPIOA | RCC_APB2_PERIPH_GPIOB , ENABLE);#if HARDWARE_SPI_MODE SPI_InitType SPI_InitStructure; RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_SPI1 | RCC_APB2_PERIPH_AFIO, ENABLE); GPIO_InitStruct(&amp;GPIO_InitStructure); GPIO_InitStructure.Pin = GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7; GPIO_InitStructure.GPIO_Alternate = GPIO_AF0_SPI1; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitPeripheral(GPIOA, &amp;GPIO_InitStructure); /* SPIy Config -------------------------------------------------------------*/ SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_TX; SPI_InitStructure.SpiMode = SPI_MODE_MASTER; SPI_InitStructure.DataLen = SPI_DATA_SIZE_8BITS; SPI_InitStructure.CLKPOL = SPI_CLKPOL_HIGH; SPI_InitStructure.CLKPHA = SPI_CLKPHA_FIRST_EDGE; SPI_InitStructure.NSS = SPI_NSS_HARD; SPI_InitStructure.BaudRatePres = SPI_BR_PRESCALER_2; SPI_InitStructure.FirstBit = SPI_FB_MSB; SPI_InitStructure.CRCPoly = 7; SPI_Init(SPI1, &amp;SPI_InitStructure); SPI_SSOutputEnable(SPI1, ENABLE); SPI_EnableCalculateCrc(SPI1, DISABLE); /* Enable SPIy */ SPI_Enable(SPI1, ENABLE);#else GPIO_InitStruct(&amp;GPIO_InitStructure); GPIO_InitStructure.Pin = GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitPeripheral(GPIOA, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOA, GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7);#endif GPIO_InitStruct(&amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1; GPIO_InitPeripheral(GPIOB, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOB, GPIO_PIN_0 | GPIO_PIN_1);&#125;void LCD_Writ_Bus(u8 dat) &#123; LCD_CS_Clr();#if HARDWARE_SPI_MODE SPI_I2S_TransmitData(SPI1, dat); while (SPI_I2S_GetStatus(SPI1, SPI_I2S_TE_FLAG) == RESET); //必须等到SPI数据发完，才能拉高CS片选，发下一次数据，否则数据会出错#else u8 i; for(i=0;i&lt;8;i++) &#123; LCD_SCLK_Clr(); if(dat&amp;0x80) &#123; LCD_MOSI_Set(); &#125; else &#123; LCD_MOSI_Clr(); &#125; LCD_SCLK_Set(); dat&lt;&lt;=1; &#125;#endif LCD_CS_Set(); &#125;void LCD_WR_DATA8(u8 dat)&#123; LCD_Writ_Bus(dat);&#125;void LCD_WR_DATA(u16 dat)&#123; LCD_Writ_Bus(dat&gt;&gt;8); LCD_Writ_Bus(dat);&#125; Cortex-M系列内核字节对齐汇总 4字节对齐的含义就是变量地址对4求余数为0；8字节对齐就是地址对8求余等于0，依次类推，比如：如果让p去访问0x20000001， 0x20000002，0x20000003这都是不对齐访问。 对于M3和M4而言，可以直接访问非对齐地址（注意芯片要在这个地址有对应的内存空间), 因为M3和M4是支持的，而M0/M0+/M1是不支持的，不支持的内核芯片，只要非对齐访问就会触发硬件异常。 综上所述，我们只讨论Cortex-M3&#x2F;M4内核情况。 全局变量对齐问题 uint8_t定义变量地址要1字节对齐。 uint16_t定义变量地址要2字节对齐。 uint32_t定义变量地址要4字节对齐。 uint64_t定义变量地址要8字节对齐。 指针变量是4字节对齐。 结构体成员对齐问题自然对界例子1（分析结构各成员的默认字节对界条界条件和结构整体的默认字节对界条件）: 1234567struct Test&#123; char x1; // 成员x1为char型(其起始地址必须1字节对界)，其偏移地址为0 char x2; // 成员x2为char型(其起始地址必须1字节对界，其偏移地址为1 float x3; // 成员x3为float型(其起始地址必须4字节对界)，编译器在x2和x3之间填充了两个空字节，其偏移地址为4 char x4; // 成员x4为char型(其起始地址必须1字节对界)，其偏移地址为8 &#125;; 在Test结构体中，最大的成员为float x3，因此结构体的自然对界条件为4字节对齐。则结构体长度就为12字节，内存布局为1100 1111 1000。 指令对齐1. 伪指令#pragma pack 改变缺省的对界条件(指定对界) 使用伪指令#pragma pack (n)，编译器将按照n个字节对齐。 使用伪指令#pragma pack ()，取消自定义字节对齐方式。 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。 结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。 结合推断：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。因此，当使用伪指令#pragma pack (2)时，Test结构体的大小为8，内存布局为1111 1110。 需要注意一点，当结构体中包含一个子结构体时，子结构中的成员按照#pragma pack指定的数值和子结构最大数据成员长度中，比较小的那个进行进行对齐。例子如下： 1234567891011121314#pragma pack(8)struct s1&#123; short a; long b;&#125;; struct s2&#123; char c; s1 d; long long e;&#125;;#pragma pack() sizeof(s2)的结果为24。S1的内存布局为1100 1111，S2的内存布局为1000 1100 1111 0000 1111 1111。 例子2(按照2个字节对齐时)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#pragma pack(2)typedef struct&#123; int aa1; //2个字节对齐 1111 char bb1;//1个字节对齐 1 short cc1;//2个字节对齐 011 char dd1; //1个字节对齐 1&#125; testlength1;int length1 = sizeof(testlength1); //2个字节对齐，占用字节11 11 10 11 10,length = 10 typedef struct&#123; char bb2;//1个字节对齐 1 int aa2; //2个字节对齐 01111 short cc2;//2个字节对齐 11 char dd2; //1个字节对齐 1&#125; testlength2;int length2 = sizeof(testlength2); //2个字节对齐，占用字节10 11 11 11 10,length = 10 typedef struct&#123; char bb3; //1个字节对齐 1 char dd3; //1个字节对齐 1 int aa3; //2个字节对齐 11 11 short cc23//2个字节对齐 11 &#125; testlength3;int length3 = sizeof(testlength3); //2个字节对齐，占用字节11 11 11 11,length = 8 typedef struct&#123; char bb4; //1个字节对齐 1 char dd4; //1个字节对齐 1 short cc4;//2个字节对齐 11 int aa4; //2个字节对齐 11 11&#125; testlength4;int length4 = sizeof(testlength4); //2个字节对齐，占用字节11 11 11 11,length = 8#pragma pack()int main(void)&#123; printf(&quot;length1 = %d.\\n&quot;,length1); printf(&quot;length2 = %d.\\n&quot;,length2); printf(&quot;length3 = %d.\\n&quot;,length3); printf(&quot;length4 = %d.\\n&quot;,length4); return 0;&#125; 2. attribute((aligned(n))) __attribute__是GCC里的编译参数，用法有很多种，感兴趣可以阅读一下gcc的相关文档。这里说一下__attribute__对变量和结构体对齐的影响。这里的影响大概分为两个方面，对齐和本身占用的字节数的大小，即sizeof（变量）的值。 int a attribute((aligned(64))) = 10; 这个修饰的影响主要是对齐，所谓对齐是存储为值的起始地址。变量a的地址&amp;a,本来是4字节对齐，变成了64字节对齐（有的环境对最大对齐数值有限制）。64字节对齐就是&amp;a的最后6位为0。 1sizeof(a) = 4; //a 占用的字节数还是4个字节 typedef int myint attribute((aligned(64))) ; 这样说明myint 声明的变量按照64字节对齐，大小是4字节，这样就会有一个问题，这个变量不能定义数组： 1myint myarray[2]; //这样定义编译器会报err 报错的原因是数组的存储在内存中是连续的，而myint只有4字节确要64字节对齐，这样对齐和连续就不能同时保证，就会报错。 例子1： 12345typedef struct st_tag &#123; int a; char b;&#125; ST1;ST1 myst； 在没有对齐的情况下：sizeof(ST1) = sizeof(myst) = 8;结构体对齐的原则可以总结为： 结构体起始地址(&amp;myst)按最大变量字节数(sizeof(int))对齐； 结构体内每个变量按照自身字节数对齐； 结构体的大小(sizeof(myst))是最大变量字节数的整数倍（8&#x2F;4&#x3D;2）； 123456typedef struct st_tag &#123; int a; char b;&#125; __attribute__((__aligned__(64))) ST1;ST1 myst；sizeof(ST1) = sizeof(myst) = 64; 对比： 123456typedef struct st_tag &#123; int a; char b;&#125; ST1 __attribute__((__aligned__(64)));ST1 myst；sizeof(ST1) = sizeof(myst) = 8 ; 这第二种情况可以理解为__attribute__((aligned(64)))作用于变量ST1 ，只影响对齐，不影响结构的大小。 例子2： 123456typedef struct __attribute__((packed))&#123; uint8_t comm_version; uint8_t comm_lenth; uint8_t device_fw_verion[];&#125;ble_resp_device_info_desc; __attribute__((packed))是GCC编译器提供的一个属性,__attribute__((packed))其中的成员变量不会进行对齐。 HSV 模型123456789101112131415161718192021222324252627282930313233#include &lt;math.h&gt;/** 将HSV颜色转换为RGB颜色* hue,色调:0-360; saturation,纯度:0-1; value,明度:0-1* r,g,b,RGB颜色，此值范围为0-255，但外界传入时的变量须是int类型*/void hsv_to_rgb(float h, float s, float v, int *r, int *g, int *b)&#123; float f, x, y, z; int i; v *= 255.0; if (s == 0.0) &#123; *r = *g = *b = (int)v; &#125; else &#123; while (h &lt; 0) h += 360; h = fmod(h, 360) / 60.0; i = (int)h; f = h - i; x = v * (1.0 - s); y = v * (1.0 - (s * f)); z = v * (1.0 - (s * (1.0 - f))); switch (i) &#123; case 0: *r = v; *g = z; *b = x; break; case 1: *r = y; *g = v; *b = x; break; case 2: *r = x; *g = v; *b = z; break; case 3: *r = x; *g = y; *b = v; break; case 4: *r = z; *g = x; *b = v; break; case 5: *r = v; *g = x; *b = y; break; &#125; &#125;&#125; 使用Demo如下： 123456789void led_set_poll(void)&#123; int red,green,blue; static float hue = 0; hue = fmodf(hue + 1.0, 360.0); // 0-360 色调循环 hsv_to_rgb(hue, 1.0, 1.0, &amp;red, &amp;green, &amp;blue); display_board_rgb_color_set(red, green, blue);&#125; 内存管理RT-Thread和FreeRTOS都是流行的嵌入式实时操作系统（RTOS），它们提供了内存管理机制来处理任务、队列、信号量等对象的创建和删除。尽管两者在内存管理的某些方面有相似之处，但它们在实现和配置上存在一些关键的区别： 内存管理策略： RT-Thread：提供了动态内存堆管理和静态内存池管理两种方式。动态内存堆管理允许在运行时动态分配和释放内存，而内存池管理则分配固定大小的内存块，适用于分配大量大小相同的小内存块的场景。 FreeRTOS：提供了多种内存管理方案，包括简单的静态内存分配（heap_1）和更复杂的动态内存分配策略（如heap_2、heap_3、heap_4和heap_5）。FreeRTOS的动态内存分配策略允许内存的分配和释放，同时也提供了内存碎片管理的方法。 内存分配函数： RT-Thread：使用自己的内存分配函数，如rt_malloc、rt_free、rt_realloc和rt_calloc，这些函数与C标准库中的malloc和free类似，但是专为RT-Thread设计。 FreeRTOS：使用pvPortMalloc和vPortFree函数进行内存分配和释放。FreeRTOS还提供了xPortGetFreeHeapSize等函数来获取内存堆的状态。 内存堆的实现： RT-Thread：内存堆管理根据内存设备的不同，分为小内存块分配管理、大内存块的slab分配管理和多内存堆分配情况的管理。 FreeRTOS：提供了多种内存堆实现，例如heap_1不允许释放内存，heap_2允许释放但不合并相邻空闲块，heap_3包装了标准库的malloc和free，heap_4合并相邻空闲块以减少碎片，heap_5则支持跨多个不相邻内存区域的堆。 内存碎片管理： RT-Thread：通过内存池管理来减少内存碎片，内存池预先分配一块内存，并在其中管理固定大小的内存块。 FreeRTOS：heap_4和heap_5实现了内存碎片管理，通过合并相邻的空闲内存块来减少碎片。 内存管理的配置： RT-Thread：内存管理的配置通常在rtconfig.h中进行，可以选择使用不同的内存管理算法。 FreeRTOS：内存管理的配置也在配置文件中进行，需要选择一个合适的堆管理实现文件，并在FreeRTOSConfig.h中进行相应的配置。 内存管理的适用性： RT-Thread：内存管理机制适用于各种大小的内存块，特别是通过内存池管理来优化小内存块的分配效率。 FreeRTOS：提供了多种内存管理策略，适用于不同的应用场景和内存需求，从简单的静态分配到复杂的动态分配。 总的来说，RT-Thread和FreeRTOS都提供了灵活的内存管理机制来满足不同嵌入式应用的需求。选择哪种内存管理策略取决于具体的应用场景、内存需求和开发偏好。 国民UART+DMA+TX问题改之前： 12345678910111213141516171819202122232425262728static void ec32_uart_dma_tx_config(struct ec_serial_device *serial, uint8_t *buffer, uint16_t length)&#123; if(serial-&gt;Txbuffer-&gt;tail + length &gt; serial-&gt;dma.setting_tx_len) &#123; while(DMA_GetFlagStatus(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type) == RESET)&#123;&#125; DMA_ClearFlag(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type); &#125; DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE); DMA_InitType DMA_InitStructure; uint16_t dma_get_counts = DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch); /* if no data waiting send*/ if(dma_get_counts == 0) &#123; serial-&gt;Txbuffer-&gt;lenth = length &gt; serial-&gt;dma.setting_tx_len ? serial-&gt;dma.setting_tx_len : length; memcpy(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth); DMA_InitStructure.MemAddr = (uint32_t)serial-&gt;Txbuffer-&gt;data; DMA_InitStructure.BufSize = serial-&gt;Txbuffer-&gt;lenth; serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth; &#125;else&#123; memcpy(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail, buffer, length); DMA_InitStructure.MemAddr = (uint32_t)(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail - dma_get_counts); DMA_InitStructure.BufSize = length + dma_get_counts; serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;tail + length; &#125;... ...&#125; 问题解决来自jindu-chen，修改后： 12345678910111213141516171819202122232425262728293031323334static void ec32_uart_dma_tx_config(struct ec_serial_device *serial, uint8_t *buffer, uint16_t length)&#123; DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE); DMA_InitType DMA_InitStructure; uint16_t dma_get_counts = DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch); /* if no data waiting send*/ if(dma_get_counts == 0) &#123; serial-&gt;Txbuffer-&gt;lenth = length &gt; serial-&gt;dma.setting_tx_len ? serial-&gt;dma.setting_tx_len : length; memcpy(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth); DMA_InitStructure.MemAddr = (uint32_t)serial-&gt;Txbuffer-&gt;data; DMA_InitStructure.BufSize = serial-&gt;Txbuffer-&gt;lenth; serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth; &#125;else&#123; if(serial-&gt;Txbuffer-&gt;tail + length &gt; serial-&gt;dma.setting_tx_len) &#123; DMA_EnableChannel(serial-&gt;dma.tx_ch, ENABLE); while(DMA_GetFlagStatus(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type) == RESET)&#123;&#125; DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE); memcpy(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth); DMA_InitStructure.MemAddr = (uint32_t)serial-&gt;Txbuffer-&gt;data; DMA_InitStructure.BufSize = length; serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth; &#125;else&#123; memcpy(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail, buffer, length); DMA_InitStructure.MemAddr = (uint32_t)(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail - dma_get_counts); DMA_InitStructure.BufSize = length + dma_get_counts; serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;tail + length; &#125; &#125;... ...&#125; 修改前tail指针接近缓存区最大边界时，剩余空间不足时会进入以下函数, 一直卡在while中出不来, 需改到后面去： 1234567if(serial-&gt;Txbuffer-&gt;tail + length &gt; serial-&gt;dma.setting_tx_len) &#123; while(DMA_GetFlagStatus(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type) == RESET)&#123;&#125; DMA_ClearFlag(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type);&#125;DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch) 需要实时获取 即以下代码： 1234567891011121314151617181920212223242526272829303132333435363738static void ec32_uart_dma_tx_config(struct ec_serial_device *serial, uint8_t *buffer, uint16_t length)&#123; DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE); DMA_InitType DMA_InitStructure; /* if no data waiting send*/ if(DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch) == 0) &#123; serial-&gt;Txbuffer-&gt;lenth = length &gt; serial-&gt;dma.setting_tx_len ? serial-&gt;dma.setting_tx_len : length; memcpy(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth); DMA_InitStructure.MemAddr = (uint32_t)serial-&gt;Txbuffer-&gt;data; DMA_InitStructure.BufSize = serial-&gt;Txbuffer-&gt;lenth; serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth; &#125;else&#123; if(serial-&gt;Txbuffer-&gt;tail + length &gt; serial-&gt;dma.setting_tx_len) &#123; DMA_EnableChannel(serial-&gt;dma.tx_ch, ENABLE); while(DMA_GetFlagStatus(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type) == RESET)&#123;&#125; //需在serial-&gt;Txbuffer-&gt;lenth赋值之前，否则DMA_InitStructure.BufSize会刷新，会继续发送未知数据。 DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE); //需在DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE)之后 serial-&gt;Txbuffer-&gt;lenth = length &gt; serial-&gt;dma.setting_tx_len ? serial-&gt;dma.setting_tx_len : length; memcpy(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth); DMA_InitStructure.MemAddr = (uint32_t)serial-&gt;Txbuffer-&gt;data; DMA_InitStructure.BufSize = serial-&gt;Txbuffer-&gt;lenth; serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth; &#125;else&#123; memcpy(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail, buffer, length); DMA_InitStructure.MemAddr = (uint32_t)(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail - DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch)); DMA_InitStructure.BufSize = length + DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch); serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;tail + length; &#125; &#125;... ...&#125; 修改后还是会在DMA发送数据满的时候，多出不知名的符号，再次修改： 1234static void ec32_uart_dma_tx_config(struct ec_serial_device *serial, uint8_t *buffer, uint16_t length)&#123; DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE); //去掉这一项，在需要关闭时再关闭DMA，否则会影响数组满时的数据。... ... 修改后代码： 123456789101112131415161718192021222324252627282930313233static void ec32_uart_dma_tx_config(struct ec_serial_device *serial, uint8_t *buffer, uint16_t length)&#123; DMA_InitType DMA_InitStructure; /* if no data waiting send*/ if(DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch) == 0) &#123; DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE); serial-&gt;Txbuffer-&gt;lenth = length &gt; serial-&gt;dma.setting_tx_len ? serial-&gt;dma.setting_tx_len : length; memcpy(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth); DMA_InitStructure.MemAddr = (uint32_t)serial-&gt;Txbuffer-&gt;data; DMA_InitStructure.BufSize = serial-&gt;Txbuffer-&gt;lenth; serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth; &#125;else&#123; if(serial-&gt;Txbuffer-&gt;tail + length &gt; serial-&gt;dma.setting_tx_len) &#123; while(DMA_GetFlagStatus(serial-&gt;dma.tx_gl_flag, serial-&gt;dma.tx_dma_type) == RESET)&#123;&#125; DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE); serial-&gt;Txbuffer-&gt;lenth = length &gt; serial-&gt;dma.setting_tx_len ? serial-&gt;dma.setting_tx_len : length; memcpy(serial-&gt;Txbuffer-&gt;data, buffer, serial-&gt;Txbuffer-&gt;lenth); DMA_InitStructure.MemAddr = (uint32_t)serial-&gt;Txbuffer-&gt;data; DMA_InitStructure.BufSize = serial-&gt;Txbuffer-&gt;lenth; serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;lenth; &#125;else&#123; DMA_EnableChannel(serial-&gt;dma.tx_ch, DISABLE); memcpy(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail, buffer, length); DMA_InitStructure.MemAddr = (uint32_t)(serial-&gt;Txbuffer-&gt;data + serial-&gt;Txbuffer-&gt;tail - DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch)); DMA_InitStructure.BufSize = length + DMA_GetCurrDataCounter(serial-&gt;dma.tx_ch); serial-&gt;Txbuffer-&gt;tail = serial-&gt;Txbuffer-&gt;tail + length; &#125; &#125;... ... RT-THREAD下IAP升级问题当前代码： 1234567891011#define RT_THREAD_PRIORITY_MAX 32 #define RT_THREAD_COMM_TASK_PRIORITY 10static void iap(void)&#123; uint8_t proi = RT_THREAD_COMM_TASK_PRIORITY - 1; rt_thread_t th = rt_thread_find(&quot;tidle&quot;); //fix it（2022.8.30） rt_thread_control(th,RT_THREAD_CTRL_CHANGE_PRIORITY,&amp;proi); SerialDownload(); proi = RT_THREAD_PRIORITY_MAX - 1; rt_thread_control(th,RT_THREAD_CTRL_CHANGE_PRIORITY,&amp;proi);&#125; 思路是进入IAP升级后提高当前优先级，避免其他任务打断，传输数据接收异常，导致升级失败。 后面测试发现如果升级途中被外部字符输入打断，会一直在YMODEM里面出不来，开了看门口也没用（YMODEM接收程序里有看门狗）。 解决方法：目前添加rt_schedule();暂时解决问题，测试中会偶发，最近测试没有发现，待进一步测试。12345678910 rt_thread_t th = rt_thread_find(&quot;tidle&quot;); //fix it（2022.8.30） int original_priority = th-&gt;current_priority; int new_priority = RT_THREAD_COMM_TASK_PRIORITY - 1;rt_err_t ret = rt_thread_control(th,RT_THREAD_CTRL_CHANGE_PRIORITY,&amp;new_priority); // rt_schedule();SerialDownload();ret = rt_thread_control(th,RT_THREAD_CTRL_CHANGE_PRIORITY,&amp;original_priority); rt_schedule(); J-LINK添加芯片J-LINK时常会添加没用过的芯片，有以下步骤可以适配J-LINK的UI界面版和指令板，以GD的GD32E235CBT6举例： 添加GD32E23x.FLM文件到JLink\\Devices\\GigaDevice 在最后面, &lt;/DataBase&gt;之前追加JLinkDevices.xml文件的内容：1234&lt;Device&gt; &lt;ChipInfo Vendor=&quot;GigaDevice&quot; Name=&quot;GD32E235CB&quot; Core=&quot;JLINK_CORE_CORTEX_M23&quot; WorkRAMAddr=&quot;0x20000000&quot; WorkRAMSize=&quot;0x00004000&quot; /&gt; &lt;FlashBankInfo Name=&quot;Flash Bank1&quot; BaseAddr=&quot;0x08000000&quot; MaxSize=&quot;0x00020000&quot; Loader=&quot;Devices\\GigaDevice\\GD32E23x.FLM&quot; LoaderType=&quot;FLASH_ALGO_TYPE_OPEN&quot; AlwaysPresent=&quot;1&quot;/&gt; &lt;/Device&gt; 注意, Name=&quot;GD32E235CB&quot; 中的GD32E235CB 需要跟脚本指令 JLink -device N32G452RC保持一致。 利用正弦曲线模拟呼吸灯 直接上示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 宏定义#include &lt;math.h&gt;#define RLED_WHITE_NUM_MAX 11#define RLED_RGB_TYPE 3#define RLED_LIGHT_PERCENT 0.3f //light percent#define RLED_VALUE_MAX (uint8_t)(255 * RLED_LIGHT_PERCENT) //max 255#define CHARGE_BREATH_TICKS 3000.0 //3s#ifndef M_PI #define M_PI 3.14159265358979323846#endifconst float twoPi = 2.0f * M_PI; // 2 * π// 具体实现static void led_rgb_breath_function(uint8_t *rgb, float tick) //tick-&gt;(0~1) 为一个周期&#123; uint8_t temp[RLED_RGB_TYPE] = &#123;0&#125;; for(int i=0; i&lt;RLED_RGB_TYPE; i++) &#123; temp[i] = (rgb[i] * (1.0f + cos(M_PI + twoPi * tick)) / 2.0f); board_led_rgb_set(i, temp[i]); //具体输出RGB的PWM函数 &#125;&#125;RLED_RUN_MODE rled_ring_charge_function(event_param_t ep)&#123; RLED_RUN_MODE ret = RLED_NONE; static float ticks = 0; uint8_t rgb_temp[] = RGB_LED_COLOR_WHITE; for(int i=0; i&lt;RLED_RGB_TYPE; i++) rgb_temp[i] = (uint8_t)(rgb_temp[i] * RLED_LIGHT_PERCENT); if(ep.first_in)&#123; led_white_all_play(0); ticks = 0; &#125;else&#123; ticks = ticks + LED_MAIN_UPGRATE_TIMES * LED_SINGLE_CHR_IN_CNTS / CHARGE_BREATH_TICKS; // ticks递增 led_rgb_breath_function(rgb_temp, ticks); &#125; ret = ep.mode; if(ep.ret_priv) ret = ep.mode; return ret;&#125; RTC低功耗唤醒问题RTC设置日期时间问题 遇到问题 123456789101112131415161718void drv_low_power_rtc_init(void)&#123; rtc_date_time_default_value(); rtc_alarm_default_value(); rtc_system_clk_config(); if(USER_WRITE_BKP_DAT1_DATA != BKP_ReadBkpData(BKP_DAT1)) &#123; logDebug(&quot;RTC not yet configured.... &quot;); rtc_clk_source_config(RTC_CLK_SRC_TYPE_LSI, true, true); rtc_date_params_set(&amp;RTC_DateDefault); rtc_time_params_set(&amp;RTC_TimeDefault); BKP_WriteBkpData(BKP_DAT1, USER_WRITE_BKP_DAT1_DATA); &#125;else&#123; logDebug(&quot;RTC is haven configured.... &quot;); &#125; wakeup_exti_trigger_init(); wakeup_exti_config_it(true);&#125; rtc_clk_source_config(...)执行完后，设置日期rtc_date_params_set(...)，设置会失败显示The current date (WeekDay-Date-Month-Year) is &lt; 00-01-01-00 &gt;： 123456D [00:00:00,000] (driver/drv_lp_rtc.c) drv_low_power_rtc_init [380]: RTC not yet configured.... D [00:00:00,000] (driver/drv_lp_rtc.c) rtc_clk_source_config [331]: RTC_ClkSrc Is Set LSI!D [00:00:00,001] (driver/drv_lp_rtc.c) rtc_date_params_set [166]: &gt;&gt; RTC Set Date success. &lt;&lt;D [00:00:00,001] (driver/drv_lp_rtc.c) rtc_date_param_show [125]: The current date (WeekDay-Date-Month-Year) is &lt; 00-01-01-00 &gt;D [00:00:00,001] (driver/drv_lp_rtc.c) rtc_time_params_set [186]: &gt;&gt; RTC Set Time success. &lt;&lt;D [00:00:00,001] (driver/drv_lp_rtc.c) rtc_time_param_show [137]: The current time (Hour-Minute-Second) is &lt; 12:00:01 &gt; 原因分析，在函数ErrorStatus RTC_Init(RTC_InitType* RTC_InitStruct)&#123;...&#125;中有以下代码： 12/* Delay for the RTC prescale effect */for(i=0;i&lt;0x2FF;i++); 当跑原厂demo的时候不会出现设置失败，经排查发现demo是的优化等级是O0，而本代码是Os，优化等级Os会将空循环for(i=0;i&lt;0x2FF;i++);导致RTC初始化后，等待寄存器同步过程被优化掉不去执行，导致下一步设置RTC参数失败。 解决方案： 1、将函数for(i=0;i&lt;0x2FF;i++);中i的变量类型改为volatile，将会直接读取寄存器，不会被内存优化。 2、将函数for(i=0;i&lt;0x2FF;i++);替换为for(i=0;i&lt;0x2FF;i++)&#123;__asm(&quot;nop&quot;);&#125;，将会直接执行指令，不会被内存优化。 RTC唤醒偶尔失败（rt-thread操作系统）调试发现按键唤醒和闹钟唤醒均可, RTC自动唤醒有问题。 唤醒例程 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#define RTC_WAKEUP_EN 0#define IWDG_MAX_TIMEOUT_SECS 25#define IWDG_MAX_USER_SECS 21static void board_rtc_alarm_second_set(uint32_t secs)&#123; uint32_t second = IWDG_MAX_USER_SECS; if(secs &lt; IWDG_MAX_USER_SECS) second = secs; rtc_alarm_second_set(second);&#125;// 挂起所有线程的函数void suspend_all_threads(void)&#123; struct rt_thread *thread; struct rt_object_information *information; struct rt_list_node *node; /* 获取线程对象信息 */ information = rt_object_get_information(RT_Object_Class_Thread); RT_ASSERT(information != RT_NULL); /* 进入临界区 */ rt_enter_critical(); //清空tick值，关闭systick中断 SysTick-&gt;VAL = 0x00; SysTick-&gt;CTRL = 0x00; /* 遍历线程对象列表 */ for (node = information-&gt;object_list.next; node != &amp;(information-&gt;object_list); node = node-&gt;next) &#123; thread = rt_list_entry(node, struct rt_thread, list); /* 确保不是挂起当前正在运行的线程 */ if (thread != rt_thread_self()) &#123; /* 挂起线程 */ rt_thread_suspend(thread); &#125; &#125; /* 退出临界区 */ rt_exit_critical();&#125;void board_pwr_enter_stop2(void)&#123; suspend_all_threads();#if RTC_WAKEUP_EN rtc_auto_wakeup_init(5);#endif while(1) &#123; serial_only_print_string(&quot;Start low power mode!\\r\\n\\r\\n&quot;);#if !RTC_WAKEUP_EN board_rtc_alarm_second_set(20);#endif PWR_EnterSTOP2Mode(PWR_STOPENTRY_WFI); system_clock_config_stop2(); system_print_config_stop2(); serial_only_print_string(&quot;Exit low power mode!\\r\\n&quot;); bool botton_sw = GPIO_ReadInputDataBit(GPIOA, GPIO_PIN_0); bool dc_ch = !GPIO_ReadInputDataBit(GPIOA, GPIO_PIN_5); if(botton_sw) // || dc_ch &#123; serial_only_print_string(&quot;botton press!\\r\\n&quot;); reboot(); &#125; &#125;&#125; RTC auto wakeup成功, 需注意唤醒时钟问题: 1234567891011121314151617181920212223242526272829void drv_low_power_rtc_init(void)&#123; rtc_date_time_default_value(); rtc_alarm_default_value(); rtc_system_clk_config(); rtc_auto_wakeup_init(); if(USER_WRITE_BKP_DAT1_DATA != BKP_ReadBkpData(BKP_DAT1)) &#123; logDebug(&quot;RTC not yet configured.... &quot;); rtc_clk_source_config(RTC_CLK_SRC_TYPE_LSI, true, true); RTC_ConfigWakeUpClock(RTC_WKUPCLK_CK_SPRE_16BITS); // 注意：只能设置一次，否则会有异常，不能自动唤醒导致卡死 rtc_date_params_set(&amp;RTC_DateDefault); rtc_time_params_set(&amp;RTC_TimeDefault); BKP_WriteBkpData(BKP_DAT1, USER_WRITE_BKP_DAT1_DATA); &#125;else&#123; logDebug(&quot;RTC is haven configured.... &quot;); &#125; wakeup_exti_trigger_init();&#125;void rtc_auto_wakeup_set(uint8_t seconds)&#123; RTC_SetWakeUpCounter(seconds); EXTI20_RTCWKUP_Configuration(true); RTC_ConfigInt(RTC_INT_WUT, ENABLE); RTC_EnableWakeUp(ENABLE); exti20_alarm_config_it(true); rtc_wakeup_all_config_it(true);&#125; gcc优化等级和标准库问题 O0级优化低功耗会跑飞，Os级优化低功耗就是正常的，原因待查，下一步先查打印函数, 不是打印函数原因，已验证。 arm-none-eabi-gcc的nano系统：添加--specs=nano.specs 打印不了float和64位整数，但是程序缩小20K左右; 但是标准库跑不了低功耗，原因为串口打印函数问题, 待分析。 自写printf函数12345678910111213141516171819202122static int lp_printf(const char *format, ...) &#123; va_list args; char buffer[256]; // 定义一个足够大的缓冲区 int len, size; va_start(args, format); // 初始化args len = vsnprintf(buffer, sizeof(buffer), format, args); // 格式化字符串到buffer va_end(args); // 清理args uint8_t *p_buff = (uint8_t *)buffer; size = len; // 硬件适配层 USART_ClrFlag(USART1, USART_FLAG_TXC); while(len --) &#123; USART_SendData(USART1, *p_buff); while (USART_GetFlagStatus(USART1, USART_FLAG_TXC) == RESET); p_buff ++; &#125; return size; // 返回发送的字符数&#125; 问题点：使用arm-none-eabi-gcc环境在makefile中使用--specs=nano.specs选项，使用的是newlib-nano库，lp_printf进入低功耗后初始化打印正常；使用的是标准库newlib库，lp_printf进入低功耗后初始化打印异常。调试发现在使用vsnprintf函数时会跑飞。 改进方法：将vsnprintf函数替换成rt_vsnprintf函数。 分析原因： 可能问题点：在进入低功耗模式时，系统会关闭一些外设和资源以节省能量。当退出低功耗模式时，需要正确地恢复这些资源。如果 newlib 中的某些功能在资源恢复过程中存在问题，可能会导致程序异常。 newlib-nano 由于实现简单，可能在资源恢复方面更加稳定，不会受到低功耗模式的影响。 解决方法：（感觉无用） 检查资源管理：确保在进入和退出低功耗模式时，所有资源都被正确管理。特别是对于标准库中使用的资源，如内存分配器等，确保它们在低功耗模式下能够正常工作。 使用线程安全的实现：如果在多线程环境中使用标准库，确保所有函数都是线程安全的，以避免在低功耗模式下出现并发问题。 rt-thread 互斥量问题问题点： 低优先级任务在打印时，高优先级任务也有打印，导致打印函数重入互斥量自锁。 解决方法： 使用递归互斥量：在FreeRTOS中，可以使用xSemaphoreCreateRecursiveMutex来创建递归互斥量，并使用xSemaphoreTakeRecursive和xSemaphoreGiveRecursive来获取和释放互斥量, rtthread系统待验证。 优先级继承：当低优先级任务持有互斥量时，如果高优先级任务试图获取同一个互斥量，可以通过优先级继承机制来避免死锁。这样，低优先级任务的优先级会临时提升，以减少高优先级任务的等待时间。 设计合理的资源访问顺序：确保系统中的所有任务以相同的顺序获取互斥量，这可以避免循环等待，从而减少死锁的可能性。 项目中的解决方案及代码： shell是空闲任务，线程优先级最低。 brains_electric_data_send(&amp;send_data, sizeof(send_data));函数会传递队列，接收队列任务优先级要比shell线程优先级高。 在这里进入打印时不设上锁等待时间，会直接重入。 影响：有部分打印会被覆盖，不显示。123456789101112131415161718192021222324252627282930313233343536#if LOG_USING_LOCKstatic struct rt_mutex logMutex;int userLogLock(Log *log)&#123; //互斥量在低优先级使用的时候，切到高优先级任务会导致死锁，不能用RT_WAITING_FOREVER rt_mutex_take(&amp;logMutex, rt_tick_from_millisecond(0)); return 0;&#125;int userLogUnlock(Log *log)&#123; rt_mutex_release(&amp;logMutex); return 0;&#125;#endif// 在shell中void brains_electric_transmit_en(bool en)&#123; uint8_t send_data = 0; if(en) &#123; brains_electric_onoff = true; send_data = &#x27;b&#x27;; brains_electric_data_send(&amp;send_data, sizeof(send_data)); // logVerbose(&quot;brains_electric_serial_tx -&gt; [%c]&quot;, send_data); &#125;else&#123; rt_timer_stop(&amp;brains_timer_stimer); rt_timer_stop(&amp;brains_wait_stimer); send_data = &#x27;s&#x27;; brains_electric_data_send(&amp;send_data, sizeof(send_data)); // logVerbose(&quot;brains_electric_serial_tx -&gt; [%c]&quot;, send_data); &#125;&#125;SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(0)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC)|SHELL_CMD_DISABLE_RETURN, brains_electric_transmit_en, brains_electric_transmit_en,brains_electric_transmit_en); arm-none-eabi-gcc打印不了浮点和64位数据问题分析问题点： arm-none-eabi-gcc环境打印不了浮点和64位数据，测试发现在makefile中使用--specs=nano.specs选项，使用的是nano库而非标准库。 解决方法： 尝试添加LDFLAGS += -lc -lrdimon -u _printf_float，程序会跑飞。 将--specs=nano.specs去掉，默认使用标准库就可以打印浮点和64位数据了。 letter shell调试问题 使用letter shell调试时间戳转换函数时遇到问题，设置时间对不上，代码如下：12345678910111213141516171819202122232425262728// 将UTC的Unix时间戳转换为RTC时间和日期static void rtc_utc_timestamp_set(time_t timestamp)&#123; struct tm *tm = gmtime(&amp;timestamp); RTC_DateType RTC_Date; RTC_TimeType RTC_Time; RTC_Date.Year = tm-&gt;tm_year - 100; // 年份从1900开始计算 RTC_Date.Month = tm-&gt;tm_mon + 1; // 月份从0开始计算 RTC_Date.Date = tm-&gt;tm_mday; RTC_Date.WeekDay = (tm-&gt;tm_wday == 0) ? 7 : tm-&gt;tm_wday; // 星期几，tm结构体是0-6，0是星期天; stm32的RTC返回的是1-7 RTC_Time.Hours = tm-&gt;tm_hour; RTC_Time.Minutes = tm-&gt;tm_min; RTC_Time.Seconds = tm-&gt;tm_sec; RTC_Time.H12 = RTC_AM_H12; rtc_date_params_set(&amp;RTC_Date); rtc_time_params_set(&amp;RTC_Time);&#125;SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(0)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC)|SHELL_CMD_DISABLE_RETURN, utc_timestamp_set, rtc_utc_timestamp_set, rtc_utc_timestamp_set);// 将UTC的Unix时间戳转换为本地RTC时间和日期void rtc_local_timestamp_set(time_t timestamp)&#123; time_t utc_timestamp = timestamp + 8 * 3600; // 本地时间比UTC时间快8小时，UTC时间要加上8小时 rtc_utc_timestamp_set(utc_timestamp);&#125;SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(0)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC)|SHELL_CMD_DISABLE_RETURN, local_timestamp_set, rtc_local_timestamp_set, rtc_local_timestamp_set); 查阅letter shell相关资料发现，参数只支持char(字符)，char(数字)，short(数字)，int(数字)，char *(字符串)，pointer这几个数据类型，并不支持time_t，所以敲shell指令入参的时候，会把数据强制转为int类型，而在使用gmtime(&amp;timestamp)转换的时候，timestamp是需要为time_t类型的，所以做出如下修改：123456789101112131415161718192021222324252627282930// 将UTC的Unix时间戳转换为RTC时间和日期static void rtc_utc_timestamp_set(int timestamp) // 改为int类型&#123; time_t utc_timestamp = (time_t)timestamp; // 强制转换为time_t类型 struct tm *tm = gmtime(&amp;utc_timestamp); RTC_DateType RTC_Date; RTC_TimeType RTC_Time; RTC_Date.Year = tm-&gt;tm_year - 100; // 年份从1900开始计算 RTC_Date.Month = tm-&gt;tm_mon + 1; // 月份从0开始计算 RTC_Date.Date = tm-&gt;tm_mday; RTC_Date.WeekDay = (tm-&gt;tm_wday == 0) ? 7 : tm-&gt;tm_wday; // 星期几，tm结构体是0-6，0是星期天; stm32的RTC返回的是1-7 RTC_Time.Hours = tm-&gt;tm_hour; RTC_Time.Minutes = tm-&gt;tm_min; RTC_Time.Seconds = tm-&gt;tm_sec; RTC_Time.H12 = RTC_AM_H12; rtc_date_params_set(&amp;RTC_Date); rtc_time_params_set(&amp;RTC_Time);&#125;SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(0)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC)|SHELL_CMD_DISABLE_RETURN, utc_timestamp_set, rtc_utc_timestamp_set, rtc_utc_timestamp_set);// 将UTC的Unix时间戳转换为本地RTC时间和日期void rtc_local_timestamp_set(time_t timestamp) // 无需改为int类型能通过?&#123; time_t utc_timestamp = timestamp + 8 * 3600; // 本地时间比UTC时间快8小时，UTC时间要加上8小时 rtc_utc_timestamp_set(utc_timestamp); // 调用UTC时间戳转换为RTC时间和日期的函数&#125;SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(0)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC)|SHELL_CMD_DISABLE_RETURN, local_timestamp_set, rtc_local_timestamp_set, rtc_local_timestamp_set); 串口相关问题不带数据线USB的D+和D-短接 添加shell.c文件中的判断，可能会出现恢复后shell交互键入数据延后：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#define SHELL_SHUTDOWN_CNTS 50static unsigned char shell_shutdown = 0; //TX RX短接处理static int shell_shutdown_cnts = 0; //TX RX短接处理cnts次数void shellInsertByte(Shell *shell, char data)&#123; /* 判断输入数据是否过长 */ if (shell-&gt;parser.length &gt;= shell-&gt;parser.bufferSize - 1) &#123; shell_shutdown_cnts ++; //超长次数过多触发shell不接受标志 if(shell_shutdown_cnts &gt; SHELL_SHUTDOWN_CNTS) shell_shutdown = 1; shellWriteString(shell, shellText[SHELL_TEXT_CMD_TOO_LONG]); shellWritePrompt(shell, 1); shellWriteString(shell, shell-&gt;parser.buffer); return; &#125;...&#125;/** * @brief shell 任务 * * @param param 参数(shell对象) * */void shellTask(void *param)&#123; Shell *shell = (Shell *)param; char data;#if SHELL_TASK_WHILE == 1 while(1) &#123;#endif if(shell_shutdown) //shell_shutdown true 退出, 可外部调用shell_shutdown置为false重新启用 return; if (shell-&gt;read &amp;&amp; shell-&gt;read(&amp;data, 1) == 1) &#123; shellHandler(shell, data); &#125;#if SHELL_TASK_WHILE == 1 &#125;#endif&#125; 串口回环后shell交互键入数据延后解决 使用letter shell的解决方法： 修改shell.c文件中的部分函数，清空缓存区长度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// shell.c 文件 void shellInsertByte(Shell *shell, char data)&#123; /* 判断输入数据是否过长 */ if (shell-&gt;parser.length &gt;= shell-&gt;parser.bufferSize - 1) &#123; shellWriteString(shell, shellText[SHELL_TEXT_CMD_TOO_LONG]); //可以注释掉，也以免一直打印？ shellWritePrompt(shell, 1); shell-&gt;parser.buffer[shell-&gt;parser.length] = 0; // + 增加清空缓存区长度 // shellWriteString(shell, shell-&gt;parser.buffer); //不打印显示超长数据 return; &#125;...&#125;void shellExec(Shell *shell)&#123; ... if (shell-&gt;status.isChecked) &#123; ... if (command != NULL) &#123; shellRunCommand(shell, command); &#125; else &#123; shellWriteString(shell, shellText[SHELL_TEXT_CMD_NOT_FOUND]); shell-&gt;parser.buffer[shell-&gt;parser.length] = 0; // + 缓存字符串清零 &#125; &#125; else &#123; shellCheckPassword(shell); &#125;&#125;static void shellWriteCommandHelp(Shell *shell, char *cmd)&#123; ShellCommand *command = shellSeekCommand(shell, cmd, shell-&gt;commandList.base, 0); if (command) &#123; shellWriteString(shell, shellText[SHELL_TEXT_HELP_HEADER]); shellWriteString(shell, shellGetCommandName(command)); shellWriteString(shell, &quot;\\r\\n&quot;); shellWriteString(shell, shellGetCommandDesc(command)); shellWriteString(shell, &quot;\\r\\n&quot;); &#125; else &#123; shellWriteString(shell, shellText[SHELL_TEXT_CMD_NOT_FOUND]); shell-&gt;parser.buffer[shell-&gt;parser.length] = 0; // + 缓存字符串清零 &#125;&#125; letter shell初始化优化 letter shell新增初始化设置打印等级参数 12345678910111213141516void User_Shell_Init(uint8_t level)&#123; struct serial_configure config = EC_SERIAL_CONFIG_DEFAULT; config.baud_rate = BAUD_RATE_921600; drv_usart_init(ESERIAL_1, ESERIAL_MODE_DMA_RX | ESERIAL_MODE_DMA_TX, &amp;config); shell.write = User_Shell_Write; shell.read = User_Shell_Read; shellInit(&amp;shell, shell_buffer, sizeof(shell_buffer)); if(level &gt; LOG_ALL) &#123; uartLog.level = LOG_ALL; &#125; logRegister(&amp;uartLog, &amp;shell);&#125; 串口升级后清屏指令问题 串口升级后清屏指令打不全导致字符重叠，letter shell优化代码如下：12345678910111213141516static const char *shellText[] =&#123; ... [SHELL_TEXT_CLEAR_CONSOLE] = &quot;\\033[2J\\033[1H&quot;, ...&#125;改为：static const char *shellText[] =&#123; ... [SHELL_TEXT_CLEAR_CONSOLE] = &quot;\\r\\n\\033[2J\\033[1H&quot;, // 添加\\r\\n字符保证终端不会粘连识别 ...&#125; secure CRT问题 在线升级后打印出不完整清屏指令，显示残留2J，不会清屏。 测试两块板，一块有这个问题，另一块没有问题 n32l406的ADC跑飞 问题：n32l406的ADC跑飞，代码复用以前可以跑的。 解决：低级错误，ADC的IO口初始化PORT和PIN写反，CmBacktrace排查出问题。","tags":"mcu"},{"title":"杂项笔记","url":"/2024/01/31/杂项笔记/","text":"J-Link&#x2F;J-FlashJ-Flash批处理脚本配置烧录：当然，前提是要添加J-Link的可执行程序路径到$PATH环境变量中 program.bat脚本代码如下，参考修改即可：123echo start...JLink -device N32L406CB -if swd -speed 4000 -CommanderScript &quot;C:\\Users\\Breo\\Desktop\\Wireless moxibustion\\Software\\program.jlink&quot; program.jlink文件代码如下，其中目标设备、文件路径、烧录地址等根据需要配置：12345678910111213connectdevice N32L406CBsi SWDspeed 4000h // halt-停止r // 复位，可以考虑去掉erase // 或 erase 0x8002800，去掉也行，但可能会出现error fail address 0x00000000错误提示loadfile app.bin 0x8002800 // loadfile app.hex 或 loadfile app.bin 0x8000000verifybin app.bin 0x8002800rgo // r go表示reset and runq // 退出J-Link命令行工具 Ubuntu 无法更新问题Ubuntu 无法使用apt update 更改软件源编辑 /etc/apt/sources.list 文件，将以下内容添加到文件末尾 deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse 清除 apt 缓存sudo apt clean sudo apt autoclean 尝试更新系统sudo apt update 显示 ModuleNotFoundError: No module named &#39;apt_pkg&#39;，重新安装 “apt_pkg“ 模块： sudo apt install --reinstall python3-apt 显示 ERROR： E: Could not read response to hello message from hook [ ! -f /usr/bin/snap ] || /usr/bin/snap advise-snap --from-apt 2&gt;/dev/null || true: Success 如果问题仍然存在，尝试修复 Python 包： sudo apt install --fix-broken 然后就更新系统了： sudo apt update sudo apt upgrade 执行sudo apt upgrade后显示ERROR： Errors were encountered while processing: /tmp/apt-dpkg-install-cQBLJW/626-linux-iot-tools-common_5.4.0-1030.31_all.deb E: Sub-process /usr/bin/dpkg returned an error code (1) 最后一步，修复损坏的软件包配置： sudo dpkg --configure -a sudo apt upgrade Breo蓝牙启动异常Breo蓝牙初始化蓝牙初始化没完成，透传未开启，app就连接蓝牙了。设置透传参数，开启透传的的状态中增加连接蓝牙接受指令。 心跳包回复超时现在是接收&#x2F;刷新设备数据200ms超时，延迟太长还可以缩短。 SPI级联led灯调试小助手产品名称：1209RGB幻彩雾状产品型号：XTQ-016B.RGB-2307125-20 SPI级联led灯问题汇总充电闪灯问题问题分析充电中拔掉电源，立即再次插入，会闪一下灯；若等两秒再插入则不会出现，初步判断是此款芯片有锁存功能，会保存到寄存器中，未完全掉电再次插入则会继续执行上次的寄存器数据。 解决方法充电中拔掉电源，程序不要立即断电，持续两秒反初始化spi灯珠，即给spi寄存器写全灭数据。 呼吸灯闪烁问题问题分析程序中呼吸灯会跑偶尔闪烁，影响显示效果。分析发现，代码中有电机的FG检测，此检测开启了输入捕获功能，会持续中断触发，虽然spi灯的驱动是dma发送，但是也是由CPU来调度的，并不能与中断并行。spi呼吸灯效果需要持续发送数据，且时序要求很高，中断会抢占spi的dma发送，打断spi传输数据，导致数据传输出错，造成闪灯效果。 解决方法1、提高芯片主频，n32l403KB最高主频为64MHz，如果主频提高效果会好一些。2、spi呼吸灯效果持续发送数据，不能与中断频繁的代码一起使用。 某项目充电保护仍充电修改代码： 12345678910111213141516&#123;-1, 1, PIN_CHARGE_CC_DETECT, PIN_MODE_INPUT&#125;, //input/output switchstatic void board_charge_cc_set(bool en)&#123; struct pin_status_desc *pin = pin_handle(PIN_CHARGE_CC_DETECT); if(en) &#123; pin-&gt;type = PIN_MODE_INPUT; drv_pin_mode(pin-&gt;pin_id,pin-&gt;type); pin-&gt;lvl_rt = -1; //重置lvl_rt，以防止output出问题 &#125;else&#123; pin-&gt;type = PIN_MODE_OUTPUT; drv_pin_mode(pin-&gt;pin_id,pin-&gt;type); pin_set_func(pin, PIN_HIGH); &#125;&#125; Git小贴士执行 git pull 会覆盖本地的修改吗？没有冲突的情况下，远端会直接更新至本地上，但不会改变本地未提交的变动；如果本地修改已提交，则会执行一个远端分支和本地分支的合并 git fetch 和 git pull 的区别与联系git fetch用于从远程仓库获取最新的提交，保存到本地的远程跟踪分支中（FETCH_HEAD），可以通过查看此分支了解远程仓库的更新情况 git diff FETCH_HEAD比较查看该分支和当前工作分支的内容 git pull会自动获取远程仓库的更新，并且合并到当前分支上，相当于git fetch + git merge FETCH_HEAD 将远程仓库中指定分支的最新提交 ID 保存到本地的 FETCH_HEAD 分支中 将 FETCH_HEAD 分支合并到当前工作分支中 基础非典型操作本地git配置 配置本地与远端的SSH密钥连接流程： 本地生成SSH公钥和私钥(如果没有的话，另，linux下公钥通常存放于~/.ssh/*.pub) ssh-keygen -t rsa -b 4096 -C xxx@xxx.com 复制公钥，添加至远端平台的SSH设置上 查看本地配置： git config --list查看当前项目的所有配置 git config --global --list查看全局配置 修改用户名(全局&#x2F;当前项目) 此用户名即提交日志上所展示的用户名称 修改全局用户名：git config --global user.name &quot;xxx&quot;，影响用户的所有仓库 修改当前路径项目的用户名：git config user.name &quot;xxx&quot; 查看全局用户名：git config user.name 初始化本地工程并与远端已有仓库的main分支关联： 进入工程根目录，git init初始化本地仓库 添加远程仓库：git remote add origin &lt;远程仓库地址&gt; git branch -M main将当前分支重命名为main，M即--move --force的缩写。（可以分别输入git add --all，git commit -m &quot;first commit&quot;完成对本地分支的首次提交） 使用git pull origin main，将远程仓库的main分支拉取到本地，或者git push -u origin main -f将本地的xxx分支强制推送到远端main分支，其中-u是--set-upstream的缩写，后续会保持这个跟踪关系 可变参数函数详解C语言中的可变参数函数允许您定义函数，其参数个数是不确定的，可以根据具体需求接受可变数量的参数。这在处理不定数量参数的情况下非常有用，比如printf和scanf等函数。让我为您详细解释一下可变参数函数的原理和实现。 1. 原理与实现： 可变参数函数的参数列表是从右往左压入堆栈的。假设堆栈中有以下参数：不可变参数1、不可变参数2、…、不可变参数n、可变参数1、可变参数2、…、可变参数n。 为了获取可变参数，我们需要知道每个可变参数的地址。这是通过前一个不可变参数的地址和类型来实现的。 ANSI标准提供了三个宏来实现这个过程： va_start(va_list arg_ptr, prev_param): 初始化可变参数列表，将arg_ptr指向第一个可变参数。 va_arg(va_list arg_ptr, type): 获取当前参数的值，类型由前面的不可变参数传递。例如，printf中的格式化字符串或者可变参数列表的参数类型和第几个不可变参数的相同。 va_end(va_list arg_ptr): 释放资源，结束可变参数列表的访问。 这些宏的实现细节由编译器和标准库提供，我们只需调用它们即可。 2. 可变参数函数： 可变参数函数允许在函数定义中接受不定数量的参数。 C语言提供了 stdarg.h 头文件来支持可变参数函数的实现。 下面是一个示例代码，展示了如何实现一个可变参数函数 sum，它接受一个整数参数 count，表示接下来的可变参数的数量： 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int sum(int count, ...) &#123; int total = 0; va_list args; va_start(args, count); for (int i = 0; i &lt; count; i++) &#123; int num = va_arg(args, int); total += num; &#125; va_end(args); return total;&#125;int main() &#123; int result = sum(4, 10, 20, 30, 40); printf(&quot;Sum: %d\\n&quot;, result); return 0;&#125; 在这个示例中，我们定义了一个可变参数函数 sum，它计算传入的整数参数的总和。 3. 可变参数宏： 可变参数宏允许在宏调用中接受可变数量的参数。 在C语言中，可变参数宏使用 __VA_ARGS__ 表示可变参数的部分。 下面是一个示例代码，展示了如何定义一个可变参数宏 PRINT_VALUES，它使用 printf 函数来打印可变数量的值: 123456789101112#include &lt;stdio.h&gt;#define PRINT_VALUES(...) do &#123; \\ printf(&quot;Values: &quot;); \\ printf(__VA_ARGS__); \\ printf(&quot;\\n&quot;); \\&#125; while (0)int main() &#123; PRINT_VALUES(&quot;%d %s %f&quot;, 10, &quot;hello&quot;, 3.14); return 0;&#125; 在这个示例中，我们定义了一个可变参数宏 PRINT_VALUES，它使用 printf 函数来打印多个值。 4. 实现自己的 printf 函数： printf 函数接受一个格式字符串作为第一个参数，后面是可变数量的参数，用于替换格式字符串中的格式占位符。 以下是一个简化版的示例代码，展示了一个实现类似于 printf 函数的功能的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;void my_printf(const char* format, ...) &#123; va_list args; va_start(args, format); while (*format != &#x27;\\0&#x27;) &#123; if (*format == &#x27;%&#x27;) &#123; format++; // 移动到占位符的下一个字符 if (*format == &#x27;d&#x27;) &#123; int value = va_arg(args, int); printf(&quot;%d&quot;, value); &#125; else if (*format == &#x27;f&#x27;) &#123; double value = va_arg(args, double); printf(&quot;%f&quot;, value); &#125; else if (*format == &#x27;s&#x27;) &#123; char* value = va_arg(args, char*); printf(&quot;%s&quot;, value); &#125; else if (*format == &#x27;c&#x27;) &#123; int value = va_arg(args, int); printf(&quot;%c&quot;, value); &#125; else &#123; printf(&quot;Unsupported format specifier: %c&quot;, *format); &#125; &#125; else &#123; printf(&quot;%c&quot;, *format); &#125; format++; // 移动到下一个字符 &#125; va_end(args);&#125;int main() &#123; int num = 42; double pi = 3.14159; char str[] = &quot;Hello, world!&quot;; char ch = &#x27;A&#x27;; my_printf(&quot;Integer: %d\\n&quot;, num); my_printf(&quot;Float: %f\\n&quot;, pi); my_printf(&quot;Float: %s\\n&quot;, str); my_printf(&quot;Float: %c\\n&quot;, ch); return 0;&#125; 汇编基础参考文档：汇编语言入门教程 实例分析了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序example.c。 1234567int add_a_and_b(int a, int b) &#123; return a + b;&#125;int main() &#123; return add_a_and_b(2, 3);&#125; gcc 将这个程序转成汇编语言。 1$ gcc -S example.c example.s经过简化以后，大概是下面的样子。 1234567891011121314_add_a_and_b: push %ebx mov %eax, [%esp+8] mov %ebx, [%esp+12] add %eax, %ebx pop %ebx ret _main: push 3 push 2 call _add_a_and_b add %esp, 8 ret 可以看到，原程序的两个函数add_a_and_b和main，对应两个标签_add_a_and_b和_main。每个标签里面是该函数所转成的 CPU 运行流程。","tags":""},{"title":"扎礼","url":"/schedule/notes.html","text":"","tags":""},{"title":"about","url":"/about/index.html","text":"","tags":""},{"title":"schedule","url":"/schedule/index.html","text":"","tags":""},{"title":"categories","url":"/categories/index.html","text":"","tags":""},{"title":"tags","url":"/tags/index.html","text":"","tags":""}]}